{
  "name": "auto_checkpoint_edit",
  "timestamp": "2025-08-24T19:01:37.812880",
  "session_id": "15859307-2121-4af6-a427-efe14d49355a",
  "git_info": {
    "branch": "main",
    "hash": "e1fde5cf",
    "dirty": true
  },
  "session_state": {
    "id": "15859307-2121-4af6-a427-efe14d49355a",
    "created_at": "2025-08-24 22:02:28",
    "updated_at": "2025-08-24T19:01:37.803879",
    "project_path": "D:\\Projects\\Dev\\Memory",
    "git_info": {},
    "context_data": {
      "last_tool_used": "Edit",
      "last_tool_time": "2025-08-24T19:01:37.800877",
      "tool_count": 1
    },
    "status": "active",
    "tool_usage": [
      {
        "tool_name": "Bash",
        "timestamp": "2025-08-24T18:55:36.549352",
        "input_data": {
          "command": "python .prsist/bin/prsist.py -r",
          "description": "Test enhanced contextual session descriptions"
        },
        "output_data": "{'stdout': \"[RUN] Prsist Memory: Running 1 command(s)\\r\\n--------------------------------------------------\\r\\n[RECENT] Recent Sessions...\\r\\n  - 15859307: Extensive codebase exploration (63 operations)\\r\\n  - fe62facb: Quick file review (4 operations)\\r\\n  - e6dca0ec: Documentation and code review\\r\\n  - f02444bf: Command execution (2 operations)\\r\\n  - ca0cdd1e: Light development work (2 operations)\\r\\n--------------------------------------------------\\r\\n[DONE] 1/1 commands completed successfully\\r\\n2025-08-24 18:55:35,774 - root - INFO - Memory manager initialized\\r\\n2025-08-24 18:55:36,031 - root - INFO - Memory manager initialized\\r\\n2025-08-24 18:55:36,035 - root - ERROR - Failed to analyze session activity: 'str' object has no attribute 'get'\\r\", 'stderr': '', 'interrupted': False, 'isImage': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Bash",
        "timestamp": "2025-08-24T18:55:36.866190",
        "input_data": {
          "command": "python .prsist/bin/prsist.py -r",
          "description": "Test enhanced contextual session descriptions"
        },
        "output_data": "{'stdout': \"[RUN] Prsist Memory: Running 1 command(s)\\r\\n--------------------------------------------------\\r\\n[RECENT] Recent Sessions...\\r\\n  - 15859307: Extensive codebase exploration (63 operations)\\r\\n  - fe62facb: Quick file review (4 operations)\\r\\n  - e6dca0ec: Documentation and code review\\r\\n  - f02444bf: Command execution (2 operations)\\r\\n  - ca0cdd1e: Light development work (2 operations)\\r\\n--------------------------------------------------\\r\\n[DONE] 1/1 commands completed successfully\\r\\n2025-08-24 18:55:35,774 - root - INFO - Memory manager initialized\\r\\n2025-08-24 18:55:36,031 - root - INFO - Memory manager initialized\\r\\n2025-08-24 18:55:36,035 - root - ERROR - Failed to analyze session activity: 'str' object has no attribute 'get'\\r\", 'stderr': '', 'interrupted': False, 'isImage': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Grep",
        "timestamp": "2025-08-24T18:55:44.533077",
        "input_data": {
          "pattern": "Failed to analyze session activity.*str.*object has no attribute.*get",
          "path": ".prsist",
          "output_mode": "content",
          "-B": 5,
          "-A": 5
        },
        "output_data": "{'mode': 'content', 'numFiles': 0, 'filenames': [], 'content': 'D:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-      \"timestamp\": \"2025-08-24T18:55:36.549352\",\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-      \"input_data\": {\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-        \"command\": \"python .prsist/bin/prsist.py -r\",\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-        \"description\": \"Test enhanced contextual session descriptions\"\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-      },\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json:      \"output_data\": \"{\\'stdout\\': \\\\\"[RUN] Prsist Memory: Running 1 command(s)\\\\\\\\r\\\\\\\\n--------------------------------------------------\\\\\\\\r\\\\\\\\n[RECENT] Recent Sessions...\\\\\\\\r\\\\\\\\n  - 15859307: Extensive codebase exploration (63 operations)\\\\\\\\r\\\\\\\\n  - fe62facb: Quick file review (4 operations)\\\\\\\\r\\\\\\\\n  - e6dca0ec: Documentation and code review\\\\\\\\r\\\\\\\\n  - f02444bf: Command execution (2 operations)\\\\\\\\r\\\\\\\\n  - ca0cdd1e: Light development work (2 operations)\\\\\\\\r\\\\\\\\n--------------------------------------------------\\\\\\\\r\\\\\\\\n[DONE] 1/1 commands completed successfully\\\\\\\\r\\\\\\\\n2025-08-24 18:55:35,774 - root - INFO - Memory manager initialized\\\\\\\\r\\\\\\\\n2025-08-24 18:55:36,031 - root - INFO - Memory manager initialized\\\\\\\\r\\\\\\\\n2025-08-24 18:55:36,035 - root - ERROR - Failed to analyze session activity: \\'str\\' object has no attribute \\'get\\'\\\\\\\\r\\\\\", \\'stderr\\': \\'\\', \\'interrupted\\': False, \\'isImage\\': False}\",\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-      \"execution_time_ms\": 0,\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-      \"success\": true\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-    },\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-    {\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-      \"tool_name\": \"Bash\",\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-      \"timestamp\": \"2025-08-24T18:55:36.866190\",\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-      \"input_data\": {\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-        \"command\": \"python .prsist/bin/prsist.py -r\",\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-        \"description\": \"Test enhanced contextual session descriptions\"\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-      },\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json:      \"output_data\": \"{\\'stdout\\': \\\\\"[RUN] Prsist Memory: Running 1 command(s)\\\\\\\\r\\\\\\\\n--------------------------------------------------\\\\\\\\r\\\\\\\\n[RECENT] Recent Sessions...\\\\\\\\r\\\\\\\\n  - 15859307: Extensive codebase exploration (63 operations)\\\\\\\\r\\\\\\\\n  - fe62facb: Quick file review (4 operations)\\\\\\\\r\\\\\\\\n  - e6dca0ec: Documentation and code review\\\\\\\\r\\\\\\\\n  - f02444bf: Command execution (2 operations)\\\\\\\\r\\\\\\\\n  - ca0cdd1e: Light development work (2 operations)\\\\\\\\r\\\\\\\\n--------------------------------------------------\\\\\\\\r\\\\\\\\n[DONE] 1/1 commands completed successfully\\\\\\\\r\\\\\\\\n2025-08-24 18:55:35,774 - root - INFO - Memory manager initialized\\\\\\\\r\\\\\\\\n2025-08-24 18:55:36,031 - root - INFO - Memory manager initialized\\\\\\\\r\\\\\\\\n2025-08-24 18:55:36,035 - root - ERROR - Failed to analyze session activity: \\'str\\' object has no attribute \\'get\\'\\\\\\\\r\\\\\", \\'stderr\\': \\'\\', \\'interrupted\\': False, \\'isImage\\': False}\",\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-      \"execution_time_ms\": 0,\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-      \"success\": true\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-    }\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-  ],\\r\\nD:\\\\Projects\\\\Dev\\\\Memory\\\\.prsist\\\\sessions\\\\active\\\\current-session.json-  \"file_interactions\": [', 'numLines': 22}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Edit",
        "timestamp": "2025-08-24T18:56:02.760129",
        "input_data": {
          "file_path": ".prsist/activity_analyzer.py",
          "old_string": "def _extract_text_content(self, input_data: Any, output_data: Any) -> str:\n        \"\"\"Extract searchable text content from tool data.\"\"\"\n        content = []\n        \n        # Extract from input data\n        if isinstance(input_data, dict):\n            for key, value in input_data.items():\n                if isinstance(value, str):\n                    content.append(value)\n                elif isinstance(value, list) and value:\n                    content.extend([str(item) for item in value if isinstance(item, str)])\n        elif isinstance(input_data, str):\n            content.append(input_data)\n        \n        # Extract from output data (limited to avoid too much noise)\n        if isinstance(output_data, str):\n            content.append(output_data[:500])  # Limit output data\n        elif isinstance(output_data, dict):\n            if 'stdout' in output_data:\n                content.append(str(output_data['stdout'])[:500])\n        \n        return \" \".join(content).lower()",
          "new_string": "def _extract_text_content(self, input_data: Any, output_data: Any) -> str:\n        \"\"\"Extract searchable text content from tool data.\"\"\"\n        content = []\n        \n        # Handle input data safely\n        try:\n            if isinstance(input_data, dict):\n                for key, value in input_data.items():\n                    if isinstance(value, str):\n                        content.append(value)\n                    elif isinstance(value, list) and value:\n                        content.extend([str(item) for item in value if isinstance(item, str)])\n            elif isinstance(input_data, str):\n                content.append(input_data)\n            elif input_data is not None:\n                content.append(str(input_data))\n        except Exception:\n            pass  # Skip problematic input data\n        \n        # Handle output data safely\n        try:\n            if isinstance(output_data, str):\n                content.append(output_data[:500])  # Limit output data\n            elif isinstance(output_data, dict):\n                if 'stdout' in output_data:\n                    content.append(str(output_data['stdout'])[:500])\n                elif 'content' in output_data:\n                    content.append(str(output_data['content'])[:500])\n            elif output_data is not None:\n                content.append(str(output_data)[:500])\n        except Exception:\n            pass  # Skip problematic output data\n        \n        return \" \".join(content).lower() if content else \"\""
        },
        "output_data": "{'filePath': '.prsist/activity_analyzer.py', 'oldString': '    def _extract_text_content(self, input_data: Any, output_data: Any) -> str:\\n        \"\"\"Extract searchable text content from tool data.\"\"\"\\n        content = []\\n        \\n        # Extract from input data\\n        if isinstance(input_data, dict):\\n            for key, value in input_data.items():\\n                if isinstance(value, str):\\n                    content.append(value)\\n                elif isinstance(value, list) and value:\\n                    content.extend([str(item) for item in value if isinstance(item, str)])\\n        elif isinstance(input_data, str):\\n            content.append(input_data)\\n        \\n        # Extract from output data (limited to avoid too much noise)\\n        if isinstance(output_data, str):\\n            content.append(output_data[:500])  # Limit output data\\n        elif isinstance(output_data, dict):\\n            if \\'stdout\\' in output_data:\\n                content.append(str(output_data[\\'stdout\\'])[:500])\\n        \\n        return \" \".join(content).lower()', 'newString': '    def _extract_text_content(self, input_data: Any, output_data: Any) -> str:\\n        \"\"\"Extract searchable text content from tool data.\"\"\"\\n        content = []\\n        \\n        # Handle input data safely\\n        try:\\n            if isinstance(input_data, dict):\\n                for key, value in input_data.items():\\n                    if isinstance(value, str):\\n                        content.append(value)\\n                    elif isinstance(value, list) and value:\\n                        content.extend([str(item) for item in value if isinstance(item, str)])\\n            elif isinstance(input_data, str):\\n                content.append(input_data)\\n            elif input_data is not None:\\n                content.append(str(input_data))\\n        except Exception:\\n            pass  # Skip problematic input data\\n        \\n        # Handle output data safely\\n        try:\\n            if isinstance(output_data, str):\\n                content.append(output_data[:500])  # Limit output data\\n            elif isinstance(output_data, dict):\\n                if \\'stdout\\' in output_data:\\n                    content.append(str(output_data[\\'stdout\\'])[:500])\\n                elif \\'content\\' in output_data:\\n                    content.append(str(output_data[\\'content\\'])[:500])\\n            elif output_data is not None:\\n                content.append(str(output_data)[:500])\\n        except Exception:\\n            pass  # Skip problematic output data\\n        \\n        return \" \".join(content).lower() if content else \"\"', 'originalFile': '#!/usr/bin/env python3\\n\"\"\"\\nActivity Analyzer for Prsist Memory System\\nAnalyzes session tool usage and file interactions to generate meaningful summaries.\\n\"\"\"\\n\\nimport json\\nimport re\\nfrom typing import Dict, List, Any, Optional, Tuple\\nfrom pathlib import Path\\nimport logging\\n\\n\\nclass ActivityAnalyzer:\\n    \"\"\"Analyzes session activity to generate meaningful summaries.\"\"\"\\n    \\n    def __init__(self):\\n        self.bug_fix_patterns = [\\n            r\\'fix.*bug\\', r\\'fix.*issue\\', r\\'fix.*error\\', r\\'fix.*problem\\',\\n            r\\'bug.*fix\\', r\\'error.*fix\\', r\\'issue.*fix\\',\\n            r\\'correct.*bug\\', r\\'resolve.*issue\\', r\\'patch.*bug\\'\\n        ]\\n        \\n        self.feature_patterns = [\\n            r\\'add.*feature\\', r\\'implement.*feature\\', r\\'create.*feature\\',\\n            r\\'new.*feature\\', r\\'build.*feature\\', r\\'develop.*feature\\',\\n            r\\'add.*function\\', r\\'implement.*function\\', r\\'create.*function\\'\\n        ]\\n        \\n        self.refactor_patterns = [\\n            r\\'refactor\\', r\\'reorganize\\', r\\'restructure\\', r\\'cleanup\\',\\n            r\\'improve.*structure\\', r\\'optimize.*code\\', r\\'clean.*up\\'\\n        ]\\n        \\n        self.config_patterns = [\\n            r\\'config\\', r\\'settings\\', r\\'configuration\\', r\\'setup\\',\\n            r\\'install\\', r\\'deploy\\', r\\'environment\\'\\n        ]\\n        \\n        self.test_patterns = [\\n            r\\'test\\', r\\'spec\\', r\\'unit.*test\\', r\\'integration.*test\\',\\n            r\\'validate\\', r\\'verify\\', r\\'check\\'\\n        ]\\n        \\n        self.doc_patterns = [\\n            r\\'document\\', r\\'readme\\', r\\'docs?/\\', r\\'\\\\.md$\\', r\\'comment\\',\\n            r\\'documentation\\', r\\'guide\\', r\\'manual\\'\\n        ]\\n    \\n    def analyze_session_activity(self, session_data: Dict[str, Any]) -> Dict[str, Any]:\\n        \"\"\"Analyze session activity and generate meaningful summary.\"\"\"\\n        try:\\n            tool_usage = session_data.get(\\'tool_usage\\', [])\\n            file_interactions = session_data.get(\\'file_interactions\\', [])\\n            \\n            # Extract activity patterns\\n            patterns = self._extract_activity_patterns(tool_usage, file_interactions)\\n            \\n            # Analyze files modified\\n            file_analysis = self._analyze_file_modifications(tool_usage, file_interactions)\\n            \\n            # Generate activity summary\\n            activity_summary = self._generate_activity_summary(patterns, file_analysis)\\n            \\n            # Generate human-readable description\\n            description = self._generate_human_description(activity_summary, patterns, file_analysis)\\n            \\n            return {\\n                \\'activity_summary\\': activity_summary,\\n                \\'patterns_detected\\': patterns,\\n                \\'file_analysis\\': file_analysis,\\n                \\'human_description\\': description,\\n                \\'confidence_score\\': self._calculate_confidence(patterns, file_analysis)\\n            }\\n            \\n        except Exception as e:\\n            logging.error(f\"Failed to analyze session activity: {e}\")\\n            return {\\n                \\'activity_summary\\': \\'Unknown activity\\',\\n                \\'human_description\\': \\'Session activity could not be analyzed\\',\\n                \\'confidence_score\\': 0.0\\n            }\\n    \\n    def _extract_activity_patterns(self, tool_usage: List[Dict], file_interactions: List[Dict]) -> Dict[str, Any]:\\n        \"\"\"Extract patterns from tool usage and file interactions.\"\"\"\\n        patterns = {\\n            \\'bug_fixes\\': [],\\n            \\'features\\': [],\\n            \\'refactoring\\': [],\\n            \\'configuration\\': [],\\n            \\'testing\\': [],\\n            \\'documentation\\': [],\\n            \\'file_operations\\': [],\\n            \\'code_exploration\\': False,\\n            \\'command_execution\\': [],\\n            \\'search_queries\\': [],\\n            \\'todo_activities\\': [],\\n            \\'project_context\\': []\\n        }\\n        \\n        # Analyze tool usage\\n        for tool in tool_usage:\\n            tool_name = tool.get(\\'tool_name\\', \\'\\')\\n            input_data = tool.get(\\'input_data\\', {})\\n            output_data = tool.get(\\'output_data\\', {})\\n            \\n            # Extract text content for pattern matching\\n            text_content = self._extract_text_content(input_data, output_data)\\n            \\n            # Check for activity patterns\\n            if self._matches_patterns(text_content, self.bug_fix_patterns):\\n                patterns[\\'bug_fixes\\'].append({\\n                    \\'tool\\': tool_name,\\n                    \\'context\\': text_content[:200],\\n                    \\'timestamp\\': tool.get(\\'timestamp\\')\\n                })\\n            \\n            if self._matches_patterns(text_content, self.feature_patterns):\\n                patterns[\\'features\\'].append({\\n                    \\'tool\\': tool_name,\\n                    \\'context\\': text_content[:200],\\n                    \\'timestamp\\': tool.get(\\'timestamp\\')\\n                })\\n            \\n            if self._matches_patterns(text_content, self.refactor_patterns):\\n                patterns[\\'refactoring\\'].append({\\n                    \\'tool\\': tool_name,\\n                    \\'context\\': text_content[:200],\\n                    \\'timestamp\\': tool.get(\\'timestamp\\')\\n                })\\n            \\n            # Track specific tool patterns\\n            if tool_name in [\\'Read\\', \\'Grep\\', \\'CodebaseSearch\\']:\\n                patterns[\\'code_exploration\\'] = True\\n            \\n            if tool_name == \\'Bash\\':\\n                command = input_data.get(\\'command\\', \\'\\')\\n                patterns[\\'command_execution\\'].append(command)\\n            \\n            if tool_name in [\\'Write\\', \\'Edit\\', \\'MultiEdit\\']:\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                patterns[\\'file_operations\\'].append({\\n                    \\'operation\\': tool_name,\\n                    \\'file\\': file_path,\\n                    \\'timestamp\\': tool.get(\\'timestamp\\')\\n                })\\n            \\n            # Extract context from WebSearch\\n            if tool_name == \\'WebSearch\\':\\n                query = input_data.get(\\'query\\', \\'\\')\\n                if query:\\n                    patterns[\\'search_queries\\'].append(query)\\n                    # Extract project context from search queries\\n                    if \\'mcp\\' in query.lower() or \\'context7\\' in query.lower():\\n                        patterns[\\'project_context\\'].append(\\'MCP server research and setup\\')\\n                    elif \\'memory\\' in query.lower():\\n                        patterns[\\'project_context\\'].append(\\'memory system research\\')\\n            \\n            # Extract context from TodoWrite\\n            if tool_name == \\'TodoWrite\\':\\n                todos = input_data.get(\\'todos\\', [])\\n                for todo in todos:\\n                    content = todo.get(\\'content\\', \\'\\').lower()\\n                    patterns[\\'todo_activities\\'].append(content)\\n                    # Extract project context from todo items\\n                    if \\'mcp\\' in content or \\'context7\\' in content:\\n                        patterns[\\'project_context\\'].append(\\'MCP server integration tasks\\')\\n                    elif \\'memory\\' in content or \\'session\\' in content:\\n                        patterns[\\'project_context\\'].append(\\'memory system development\\')\\n                    elif \\'enhance\\' in content or \\'improve\\' in content:\\n                        patterns[\\'project_context\\'].append(\\'feature enhancement work\\')\\n        \\n        return patterns\\n    \\n    def _analyze_file_modifications(self, tool_usage: List[Dict], file_interactions: List[Dict]) -> Dict[str, Any]:\\n        \"\"\"Analyze what files were modified and how.\"\"\"\\n        analysis = {\\n            \\'files_created\\': [],\\n            \\'files_modified\\': [],\\n            \\'files_read\\': [],\\n            \\'file_types\\': {},\\n            \\'key_files\\': [],\\n            \\'modification_scope\\': \\'unknown\\'\\n        }\\n        \\n        # Track file operations from tool usage\\n        for tool in tool_usage:\\n            tool_name = tool.get(\\'tool_name\\', \\'\\')\\n            input_data = tool.get(\\'input_data\\', {})\\n            \\n            file_path = input_data.get(\\'file_path\\', \\'\\')\\n            if not file_path:\\n                continue\\n                \\n            file_path = Path(file_path)\\n            file_ext = file_path.suffix\\n            \\n            # Track file types\\n            if file_ext:\\n                analysis[\\'file_types\\'][file_ext] = analysis[\\'file_types\\'].get(file_ext, 0) + 1\\n            \\n            # Categorize operations\\n            if tool_name == \\'Write\\':\\n                analysis[\\'files_created\\'].append(str(file_path))\\n            elif tool_name in [\\'Edit\\', \\'MultiEdit\\']:\\n                analysis[\\'files_modified\\'].append(str(file_path))\\n            elif tool_name == \\'Read\\':\\n                analysis[\\'files_read\\'].append(str(file_path))\\n            \\n            # Identify key files\\n            if self._is_key_file(file_path):\\n                analysis[\\'key_files\\'].append(str(file_path))\\n        \\n        # Determine modification scope\\n        total_files = len(set(analysis[\\'files_created\\'] + analysis[\\'files_modified\\']))\\n        if total_files == 0:\\n            analysis[\\'modification_scope\\'] = \\'read_only\\'\\n        elif total_files == 1:\\n            analysis[\\'modification_scope\\'] = \\'single_file\\'\\n        elif total_files <= 3:\\n            analysis[\\'modification_scope\\'] = \\'focused\\'\\n        else:\\n            analysis[\\'modification_scope\\'] = \\'broad\\'\\n        \\n        return analysis\\n    \\n    def _generate_activity_summary(self, patterns: Dict, file_analysis: Dict) -> str:\\n        \"\"\"Generate a structured activity summary.\"\"\"\\n        activities = []\\n        \\n        # Primary activities\\n        if patterns[\\'bug_fixes\\']:\\n            activities.append(f\"bug fixes ({len(patterns[\\'bug_fixes\\'])} instances)\")\\n        \\n        if patterns[\\'features\\']:\\n            activities.append(f\"feature development ({len(patterns[\\'features\\'])} instances)\")\\n        \\n        if patterns[\\'refactoring\\']:\\n            activities.append(f\"code refactoring ({len(patterns[\\'refactoring\\'])} instances)\")\\n        \\n        # File operations\\n        files_created = len(file_analysis[\\'files_created\\'])\\n        files_modified = len(file_analysis[\\'files_modified\\'])\\n        \\n        if files_created > 0:\\n            activities.append(f\"file creation ({files_created} files)\")\\n        \\n        if files_modified > 0:\\n            activities.append(f\"file editing ({files_modified} files)\")\\n        \\n        # Exploration\\n        if patterns[\\'code_exploration\\'] and not activities:\\n            activities.append(\"code exploration\")\\n        \\n        # Commands\\n        if patterns[\\'command_execution\\'] and not activities:\\n            activities.append(f\"command execution ({len(patterns[\\'command_execution\\'])} commands)\")\\n        \\n        return \", \".join(activities) if activities else \"general development activity\"\\n    \\n    def _generate_human_description(self, activity_summary: str, patterns: Dict, file_analysis: Dict) -> str:\\n        \"\"\"Generate human-readable description.\"\"\"\\n        \\n        # Extract meaningful context from tool usage patterns\\n        context_clues = self._extract_context_clues(patterns, file_analysis)\\n        \\n        # Handle specific patterns with context\\n        if patterns[\\'bug_fixes\\']:\\n            bug_context = patterns[\\'bug_fixes\\'][0].get(\\'context\\', \\'\\')\\n            if context_clues[\\'project_focus\\']:\\n                return f\"Fixed {context_clues[\\'project_focus\\']} bugs and issues\"\\n            elif \\'session tracker\\' in bug_context.lower():\\n                return \"Fixed session tracker bug and updated file interaction logging\"\\n            elif \\'logging\\' in bug_context.lower():\\n                return \"Fixed logging issues and corrected data tracking\"\\n            else:\\n                return f\"Fixed bugs in {self._get_primary_component(file_analysis)}\"\\n        \\n        if patterns[\\'features\\']:\\n            if context_clues[\\'project_focus\\']:\\n                return f\"Implemented {context_clues[\\'project_focus\\']} features and functionality\"\\n            else:\\n                component = self._get_primary_component(file_analysis)\\n                return f\"Implemented new features in {component}\"\\n        \\n        # Handle specific project activities based on context clues\\n        if context_clues[\\'main_activity\\']:\\n            if context_clues[\\'files_worked_on\\']:\\n                return f\"{context_clues[\\'main_activity\\']} - worked on {\\', \\'.join(context_clues[\\'files_worked_on\\'][:3])}\"\\n            else:\\n                return context_clues[\\'main_activity\\']\\n        \\n        # Handle file-based activities with specific context\\n        key_files = file_analysis.get(\\'key_files\\', [])\\n        if key_files:\\n            filenames = [Path(f).name for f in key_files[:2]]\\n            if context_clues[\\'activity_type\\']:\\n                return f\"{context_clues[\\'activity_type\\']} in {\\', \\'.join(filenames)}\"\\n            elif any(\\'session\\' in f.lower() for f in key_files):\\n                return f\"Enhanced session management - modified {\\', \\'.join(filenames)}\"\\n            elif any(\\'memory\\' in f.lower() for f in key_files):\\n                return f\"Improved memory system - updated {\\', \\'.join(filenames)}\"\\n            elif any(\\'config\\' in f.lower() for f in key_files):\\n                return f\"Updated configuration - modified {\\', \\'.join(filenames)}\"\\n        \\n        # Handle scope-based activities with file context\\n        scope = file_analysis.get(\\'modification_scope\\', \\'unknown\\')\\n        if scope == \\'single_file\\':\\n            file_path = (file_analysis.get(\\'files_modified\\', []) + \\n                        file_analysis.get(\\'files_created\\', []))\\n            if file_path:\\n                filename = Path(file_path[0]).name\\n                if context_clues[\\'activity_type\\']:\\n                    return f\"{context_clues[\\'activity_type\\']} - focused work on {filename}\"\\n                else:\\n                    return f\"Focused development work on {filename}\"\\n        \\n        elif scope == \\'focused\\':\\n            files_list = (file_analysis.get(\\'files_modified\\', []) + \\n                         file_analysis.get(\\'files_created\\', []))\\n            if files_list:\\n                filenames = [Path(f).name for f in files_list[:2]]\\n                if context_clues[\\'activity_type\\']:\\n                    return f\"{context_clues[\\'activity_type\\']} across {\\', \\'.join(filenames)}\"\\n                \\n            file_types = file_analysis.get(\\'file_types\\', {})\\n            if \\'.py\\' in file_types:\\n                return \"Python development and code improvements\"\\n            elif \\'.md\\' in file_types:\\n                return \"Documentation updates and improvements\"\\n        \\n        # Command execution activities with context\\n        commands = patterns.get(\\'command_execution\\', [])\\n        if commands and context_clues[\\'command_focus\\']:\\n            return context_clues[\\'command_focus\\']\\n        elif commands:\\n            if any(\\'mem\\' in cmd for cmd in commands):\\n                return \"Memory system testing and CLI operations\"\\n            elif any(\\'python\\' in cmd for cmd in commands):\\n                return \"Python script execution and testing\"\\n            elif any(\\'mcp\\' in cmd.lower() for cmd in commands):\\n                return \"MCP server configuration and setup\"\\n        \\n        # Exploration activities with context\\n        if patterns.get(\\'code_exploration\\'):\\n            if context_clues[\\'exploration_focus\\']:\\n                return context_clues[\\'exploration_focus\\']\\n            elif not file_analysis.get(\\'files_modified\\'):\\n                return \"Code exploration and analysis\"\\n        \\n        # Default with context if available\\n        if context_clues[\\'project_focus\\']:\\n            return f\"Development work on {context_clues[\\'project_focus\\']}\"\\n        \\n        return f\"Development session - {activity_summary}\"\\n    \\n    def _extract_context_clues(self, patterns: Dict, file_analysis: Dict) -> Dict[str, Any]:\\n        \"\"\"Extract meaningful context clues from session patterns and file analysis.\"\"\"\\n        context = {\\n            \\'main_activity\\': None,\\n            \\'project_focus\\': None,\\n            \\'activity_type\\': None,\\n            \\'files_worked_on\\': [],\\n            \\'command_focus\\': None,\\n            \\'exploration_focus\\': None,\\n            \\'technologies\\': []\\n        }\\n        \\n        # Analyze file operations for context\\n        files_modified = file_analysis.get(\\'files_modified\\', [])\\n        files_created = file_analysis.get(\\'files_created\\', [])\\n        all_files = files_modified + files_created\\n        \\n        if all_files:\\n            context[\\'files_worked_on\\'] = [Path(f).name for f in all_files]\\n            \\n            # Extract technologies and frameworks from file extensions and names\\n            for file_path in all_files:\\n                file_path_lower = file_path.lower()\\n                filename = Path(file_path).name.lower()\\n                \\n                # Technology detection\\n                if file_path.endswith(\\'.py\\'):\\n                    context[\\'technologies\\'].append(\\'Python\\')\\n                elif file_path.endswith((\\'.js\\', \\'.ts\\', \\'.jsx\\', \\'.tsx\\')):\\n                    context[\\'technologies\\'].append(\\'JavaScript/TypeScript\\')\\n                elif file_path.endswith((\\'.md\\', \\'.rst\\')):\\n                    context[\\'technologies\\'].append(\\'Documentation\\')\\n                elif file_path.endswith(\\'.json\\'):\\n                    context[\\'technologies\\'].append(\\'Configuration\\')\\n                \\n                # Project-specific patterns\\n                if \\'mcp\\' in filename or \\'context7\\' in filename:\\n                    context[\\'project_focus\\'] = \\'MCP server integration\\'\\n                elif \\'memory\\' in filename or \\'session\\' in filename:\\n                    context[\\'project_focus\\'] = \\'memory system\\'\\n                elif \\'activity\\' in filename or \\'analyzer\\' in filename:\\n                    context[\\'project_focus\\'] = \\'session analysis\\'\\n                elif \\'prsist\\' in filename:\\n                    context[\\'project_focus\\'] = \\'Prsist memory system\\'\\n        \\n        # Analyze tool usage for activity context\\n        file_ops = patterns.get(\\'file_operations\\', [])\\n        if file_ops:\\n            if any(op[\\'operation\\'] == \\'Write\\' for op in file_ops):\\n                if any(op[\\'operation\\'] == \\'Edit\\' for op in file_ops):\\n                    context[\\'activity_type\\'] = \\'Created and refined files\\'\\n                else:\\n                    context[\\'activity_type\\'] = \\'Created new files\\'\\n            elif any(op[\\'operation\\'] in [\\'Edit\\', \\'MultiEdit\\'] for op in file_ops):\\n                context[\\'activity_type\\'] = \\'Enhanced existing code\\'\\n        \\n        # Analyze commands for specific activities\\n        commands = patterns.get(\\'command_execution\\', [])\\n        command_text = \\' \\'.join(commands).lower()\\n        \\n        if \\'mcp\\' in command_text and \\'add\\' in command_text:\\n            context[\\'command_focus\\'] = \\'MCP server installation and configuration\\'\\n            context[\\'main_activity\\'] = \\'Set up MCP server integration\\'\\n            context[\\'project_focus\\'] = \\'MCP server integration\\'\\n        elif \\'mem\\' in command_text and \\'recent\\' in command_text:\\n            context[\\'command_focus\\'] = \\'Memory system testing and analysis\\'\\n            context[\\'main_activity\\'] = \\'Tested memory system functionality\\'\\n            context[\\'project_focus\\'] = \\'memory system\\'\\n        elif \\'python\\' in command_text and \\'prsist\\' in command_text:\\n            context[\\'command_focus\\'] = \\'Memory CLI testing and validation\\'\\n            context[\\'main_activity\\'] = \\'Validated memory system CLI commands\\'\\n            context[\\'project_focus\\'] = \\'Prsist memory system\\'\\n        elif \\'npm\\' in command_text or \\'npx\\' in command_text:\\n            context[\\'command_focus\\'] = \\'Package installation and setup\\'\\n            context[\\'main_activity\\'] = \\'Installed and configured development tools\\'\\n        \\n        # Use project context from patterns\\n        project_contexts = patterns.get(\\'project_context\\', [])\\n        if project_contexts:\\n            # Use the most recent/frequent project context\\n            context[\\'project_focus\\'] = project_contexts[-1]  # Most recent\\n        \\n        # Enhance activity description with search queries and todos\\n        search_queries = patterns.get(\\'search_queries\\', [])\\n        todo_activities = patterns.get(\\'todo_activities\\', [])\\n        \\n        if search_queries and not context[\\'main_activity\\']:\\n            query = search_queries[0].lower()\\n            if \\'mcp\\' in query or \\'context7\\' in query:\\n                context[\\'main_activity\\'] = \\'Researched and set up Context7 MCP server integration\\'\\n            elif \\'memory\\' in query:\\n                context[\\'main_activity\\'] = \\'Researched memory system implementation\\'\\n        \\n        if todo_activities and not context[\\'main_activity\\']:\\n            # Combine todo activities for description\\n            if len(todo_activities) > 1:\\n                context[\\'main_activity\\'] = f\"Worked on multiple tasks: {\\', \\'.join(todo_activities[:2])}\"\\n            else:\\n                context[\\'main_activity\\'] = f\"Worked on: {todo_activities[0]}\"\\n        \\n        # Analyze search patterns for exploration context\\n        if patterns.get(\\'code_exploration\\'):\\n            files_read = file_analysis.get(\\'files_read\\', [])\\n            if files_read:\\n                read_contexts = []\\n                for file_path in files_read[:3]:\\n                    filename = Path(file_path).name\\n                    if \\'config\\' in filename.lower():\\n                        read_contexts.append(\\'configuration files\\')\\n                    elif \\'memory\\' in filename.lower():\\n                        read_contexts.append(\\'memory system\\')\\n                    elif \\'session\\' in filename.lower():\\n                        read_contexts.append(\\'session tracking\\')\\n                    else:\\n                        read_contexts.append(filename)\\n                \\n                if read_contexts:\\n                    context[\\'exploration_focus\\'] = f\"Explored {\\', \\'.join(read_contexts[:2])}\"\\n        \\n        # Set main activity based on strongest patterns\\n        if not context[\\'main_activity\\']:\\n            if context[\\'project_focus\\'] and context[\\'activity_type\\']:\\n                context[\\'main_activity\\'] = f\"{context[\\'activity_type\\']} for {context[\\'project_focus\\']}\"\\n            elif patterns.get(\\'features\\'):\\n                context[\\'main_activity\\'] = f\"Feature development in {context[\\'project_focus\\'] or \\'project\\'}\"\\n            elif patterns.get(\\'bug_fixes\\'):\\n                context[\\'main_activity\\'] = f\"Bug fixes in {context[\\'project_focus\\'] or \\'codebase\\'}\"\\n            elif len(all_files) == 1:\\n                filename = Path(all_files[0]).name\\n                context[\\'main_activity\\'] = f\"Focused work on {filename}\"\\n            elif len(all_files) > 1:\\n                context[\\'main_activity\\'] = f\"Multi-file development across {len(all_files)} files\"\\n        \\n        return context\\n    \\n    def _get_primary_component(self, file_analysis: Dict) -> str:\\n        \"\"\"Determine the primary component being worked on.\"\"\"\\n        files = file_analysis.get(\\'files_modified\\', []) + file_analysis.get(\\'files_created\\', [])\\n        \\n        if not files:\\n            return \"system components\"\\n        \\n        # Check for common patterns\\n        for file_path in files:\\n            path_lower = file_path.lower()\\n            if \\'session\\' in path_lower:\\n                return \"session management\"\\n            elif \\'memory\\' in path_lower:\\n                return \"memory system\"\\n            elif \\'database\\' in path_lower:\\n                return \"database layer\"\\n            elif \\'config\\' in path_lower:\\n                return \"configuration\"\\n            elif \\'hook\\' in path_lower:\\n                return \"integration hooks\"\\n        \\n        # Fallback to file type\\n        file_types = file_analysis.get(\\'file_types\\', {})\\n        if \\'.py\\' in file_types:\\n            return \"Python modules\"\\n        elif \\'.md\\' in file_types:\\n            return \"documentation\"\\n        elif \\'.yaml\\' in file_types or \\'.json\\' in file_types:\\n            return \"configuration files\"\\n        \\n        return \"project files\"\\n    \\n    def _extract_text_content(self, input_data: Any, output_data: Any) -> str:\\n        \"\"\"Extract searchable text content from tool data.\"\"\"\\n        content = []\\n        \\n        # Extract from input data\\n        if isinstance(input_data, dict):\\n            for key, value in input_data.items():\\n                if isinstance(value, str):\\n                    content.append(value)\\n                elif isinstance(value, list) and value:\\n                    content.extend([str(item) for item in value if isinstance(item, str)])\\n        elif isinstance(input_data, str):\\n            content.append(input_data)\\n        \\n        # Extract from output data (limited to avoid too much noise)\\n        if isinstance(output_data, str):\\n            content.append(output_data[:500])  # Limit output data\\n        elif isinstance(output_data, dict):\\n            if \\'stdout\\' in output_data:\\n                content.append(str(output_data[\\'stdout\\'])[:500])\\n        \\n        return \" \".join(content).lower()\\n    \\n    def _matches_patterns(self, text: str, patterns: List[str]) -> bool:\\n        \"\"\"Check if text matches any of the given patterns.\"\"\"\\n        for pattern in patterns:\\n            if re.search(pattern, text, re.IGNORECASE):\\n                return True\\n        return False\\n    \\n    def _is_key_file(self, file_path: Path) -> bool:\\n        \"\"\"Determine if a file is a key project file.\"\"\"\\n        key_patterns = [\\n            r\\'config\\', r\\'settings\\', r\\'main\\', r\\'app\\', r\\'index\\',\\n            r\\'manager\\', r\\'tracker\\', r\\'database\\', r\\'core\\'\\n        ]\\n        \\n        file_name = file_path.name.lower()\\n        return any(re.search(pattern, file_name) for pattern in key_patterns)\\n    \\n    def _calculate_confidence(self, patterns: Dict, file_analysis: Dict) -> float:\\n        \"\"\"Calculate confidence score for the analysis.\"\"\"\\n        confidence = 0.5  # Base confidence\\n        \\n        # Higher confidence if we detected specific patterns\\n        if patterns[\\'bug_fixes\\'] or patterns[\\'features\\'] or patterns[\\'refactoring\\']:\\n            confidence += 0.3\\n        \\n        # Higher confidence if we have file modifications\\n        if file_analysis[\\'files_modified\\'] or file_analysis[\\'files_created\\']:\\n            confidence += 0.2\\n        \\n        # Higher confidence if we identified key files\\n        if file_analysis[\\'key_files\\']:\\n            confidence += 0.1\\n        \\n        return min(confidence, 1.0)\\n', 'structuredPatch': [{'oldStart': 525, 'oldLines': 24, 'newStart': 525, 'newLines': 36, 'lines': ['         \"\"\"Extract searchable text content from tool data.\"\"\"', '         content = []', '         ', '-        # Extract from input data', '-        if isinstance(input_data, dict):', '-            for key, value in input_data.items():', '-                if isinstance(value, str):', '-                    content.append(value)', '-                elif isinstance(value, list) and value:', '-                    content.extend([str(item) for item in value if isinstance(item, str)])', '-        elif isinstance(input_data, str):', '-            content.append(input_data)', '+        # Handle input data safely', '+        try:', '+            if isinstance(input_data, dict):', '+                for key, value in input_data.items():', '+                    if isinstance(value, str):', '+                        content.append(value)', '+                    elif isinstance(value, list) and value:', '+                        content.extend([str(item) for item in value if isinstance(item, str)])', '+            elif isinstance(input_data, str):', '+                content.append(input_data)', '+            elif input_data is not None:', '+                content.append(str(input_data))', '+        except Exception:', '+            pass  # Skip problematic input data', '         ', '-        # Extract from output data (limited to avoid too much noise)', '-        if isinstance(output_data, str):', '-            content.append(output_data[:500])  # Limit output data', '-        elif isinstance(output_data, dict):', \"-            if 'stdout' in output_data:\", \"-                content.append(str(output_data['stdout'])[:500])\", '+        # Handle output data safely', '+        try:', '+            if isinstance(output_data, str):', '+                content.append(output_data[:500])  # Limit output data', '+            elif isinstance(output_data, dict):', \"+                if 'stdout' in output_data:\", \"+                    content.append(str(output_data['stdout'])[:500])\", \"+                elif 'content' in output_data:\", \"+                    content.append(str(output_data['content'])[:500])\", '+            elif output_data is not None:', '+                content.append(str(output_data)[:500])', '+        except Exception:', '+            pass  # Skip problematic output data', '         ', '-        return \" \".join(content).lower()', '+        return \" \".join(content).lower() if content else \"\"', '     ', '     def _matches_patterns(self, text: str, patterns: List[str]) -> bool:', '         \"\"\"Check if text matches any of the given patterns.\"\"\"']}], 'userModified': False, 'replaceAll': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Edit",
        "timestamp": "2025-08-24T18:56:02.824357",
        "input_data": {
          "file_path": ".prsist/activity_analyzer.py",
          "old_string": "def _extract_text_content(self, input_data: Any, output_data: Any) -> str:\n        \"\"\"Extract searchable text content from tool data.\"\"\"\n        content = []\n        \n        # Extract from input data\n        if isinstance(input_data, dict):\n            for key, value in input_data.items():\n                if isinstance(value, str):\n                    content.append(value)\n                elif isinstance(value, list) and value:\n                    content.extend([str(item) for item in value if isinstance(item, str)])\n        elif isinstance(input_data, str):\n            content.append(input_data)\n        \n        # Extract from output data (limited to avoid too much noise)\n        if isinstance(output_data, str):\n            content.append(output_data[:500])  # Limit output data\n        elif isinstance(output_data, dict):\n            if 'stdout' in output_data:\n                content.append(str(output_data['stdout'])[:500])\n        \n        return \" \".join(content).lower()",
          "new_string": "def _extract_text_content(self, input_data: Any, output_data: Any) -> str:\n        \"\"\"Extract searchable text content from tool data.\"\"\"\n        content = []\n        \n        # Handle input data safely\n        try:\n            if isinstance(input_data, dict):\n                for key, value in input_data.items():\n                    if isinstance(value, str):\n                        content.append(value)\n                    elif isinstance(value, list) and value:\n                        content.extend([str(item) for item in value if isinstance(item, str)])\n            elif isinstance(input_data, str):\n                content.append(input_data)\n            elif input_data is not None:\n                content.append(str(input_data))\n        except Exception:\n            pass  # Skip problematic input data\n        \n        # Handle output data safely\n        try:\n            if isinstance(output_data, str):\n                content.append(output_data[:500])  # Limit output data\n            elif isinstance(output_data, dict):\n                if 'stdout' in output_data:\n                    content.append(str(output_data['stdout'])[:500])\n                elif 'content' in output_data:\n                    content.append(str(output_data['content'])[:500])\n            elif output_data is not None:\n                content.append(str(output_data)[:500])\n        except Exception:\n            pass  # Skip problematic output data\n        \n        return \" \".join(content).lower() if content else \"\""
        },
        "output_data": "{'filePath': '.prsist/activity_analyzer.py', 'oldString': '    def _extract_text_content(self, input_data: Any, output_data: Any) -> str:\\n        \"\"\"Extract searchable text content from tool data.\"\"\"\\n        content = []\\n        \\n        # Extract from input data\\n        if isinstance(input_data, dict):\\n            for key, value in input_data.items():\\n                if isinstance(value, str):\\n                    content.append(value)\\n                elif isinstance(value, list) and value:\\n                    content.extend([str(item) for item in value if isinstance(item, str)])\\n        elif isinstance(input_data, str):\\n            content.append(input_data)\\n        \\n        # Extract from output data (limited to avoid too much noise)\\n        if isinstance(output_data, str):\\n            content.append(output_data[:500])  # Limit output data\\n        elif isinstance(output_data, dict):\\n            if \\'stdout\\' in output_data:\\n                content.append(str(output_data[\\'stdout\\'])[:500])\\n        \\n        return \" \".join(content).lower()', 'newString': '    def _extract_text_content(self, input_data: Any, output_data: Any) -> str:\\n        \"\"\"Extract searchable text content from tool data.\"\"\"\\n        content = []\\n        \\n        # Handle input data safely\\n        try:\\n            if isinstance(input_data, dict):\\n                for key, value in input_data.items():\\n                    if isinstance(value, str):\\n                        content.append(value)\\n                    elif isinstance(value, list) and value:\\n                        content.extend([str(item) for item in value if isinstance(item, str)])\\n            elif isinstance(input_data, str):\\n                content.append(input_data)\\n            elif input_data is not None:\\n                content.append(str(input_data))\\n        except Exception:\\n            pass  # Skip problematic input data\\n        \\n        # Handle output data safely\\n        try:\\n            if isinstance(output_data, str):\\n                content.append(output_data[:500])  # Limit output data\\n            elif isinstance(output_data, dict):\\n                if \\'stdout\\' in output_data:\\n                    content.append(str(output_data[\\'stdout\\'])[:500])\\n                elif \\'content\\' in output_data:\\n                    content.append(str(output_data[\\'content\\'])[:500])\\n            elif output_data is not None:\\n                content.append(str(output_data)[:500])\\n        except Exception:\\n            pass  # Skip problematic output data\\n        \\n        return \" \".join(content).lower() if content else \"\"', 'originalFile': '#!/usr/bin/env python3\\n\"\"\"\\nActivity Analyzer for Prsist Memory System\\nAnalyzes session tool usage and file interactions to generate meaningful summaries.\\n\"\"\"\\n\\nimport json\\nimport re\\nfrom typing import Dict, List, Any, Optional, Tuple\\nfrom pathlib import Path\\nimport logging\\n\\n\\nclass ActivityAnalyzer:\\n    \"\"\"Analyzes session activity to generate meaningful summaries.\"\"\"\\n    \\n    def __init__(self):\\n        self.bug_fix_patterns = [\\n            r\\'fix.*bug\\', r\\'fix.*issue\\', r\\'fix.*error\\', r\\'fix.*problem\\',\\n            r\\'bug.*fix\\', r\\'error.*fix\\', r\\'issue.*fix\\',\\n            r\\'correct.*bug\\', r\\'resolve.*issue\\', r\\'patch.*bug\\'\\n        ]\\n        \\n        self.feature_patterns = [\\n            r\\'add.*feature\\', r\\'implement.*feature\\', r\\'create.*feature\\',\\n            r\\'new.*feature\\', r\\'build.*feature\\', r\\'develop.*feature\\',\\n            r\\'add.*function\\', r\\'implement.*function\\', r\\'create.*function\\'\\n        ]\\n        \\n        self.refactor_patterns = [\\n            r\\'refactor\\', r\\'reorganize\\', r\\'restructure\\', r\\'cleanup\\',\\n            r\\'improve.*structure\\', r\\'optimize.*code\\', r\\'clean.*up\\'\\n        ]\\n        \\n        self.config_patterns = [\\n            r\\'config\\', r\\'settings\\', r\\'configuration\\', r\\'setup\\',\\n            r\\'install\\', r\\'deploy\\', r\\'environment\\'\\n        ]\\n        \\n        self.test_patterns = [\\n            r\\'test\\', r\\'spec\\', r\\'unit.*test\\', r\\'integration.*test\\',\\n            r\\'validate\\', r\\'verify\\', r\\'check\\'\\n        ]\\n        \\n        self.doc_patterns = [\\n            r\\'document\\', r\\'readme\\', r\\'docs?/\\', r\\'\\\\.md$\\', r\\'comment\\',\\n            r\\'documentation\\', r\\'guide\\', r\\'manual\\'\\n        ]\\n    \\n    def analyze_session_activity(self, session_data: Dict[str, Any]) -> Dict[str, Any]:\\n        \"\"\"Analyze session activity and generate meaningful summary.\"\"\"\\n        try:\\n            tool_usage = session_data.get(\\'tool_usage\\', [])\\n            file_interactions = session_data.get(\\'file_interactions\\', [])\\n            \\n            # Extract activity patterns\\n            patterns = self._extract_activity_patterns(tool_usage, file_interactions)\\n            \\n            # Analyze files modified\\n            file_analysis = self._analyze_file_modifications(tool_usage, file_interactions)\\n            \\n            # Generate activity summary\\n            activity_summary = self._generate_activity_summary(patterns, file_analysis)\\n            \\n            # Generate human-readable description\\n            description = self._generate_human_description(activity_summary, patterns, file_analysis)\\n            \\n            return {\\n                \\'activity_summary\\': activity_summary,\\n                \\'patterns_detected\\': patterns,\\n                \\'file_analysis\\': file_analysis,\\n                \\'human_description\\': description,\\n                \\'confidence_score\\': self._calculate_confidence(patterns, file_analysis)\\n            }\\n            \\n        except Exception as e:\\n            logging.error(f\"Failed to analyze session activity: {e}\")\\n            return {\\n                \\'activity_summary\\': \\'Unknown activity\\',\\n                \\'human_description\\': \\'Session activity could not be analyzed\\',\\n                \\'confidence_score\\': 0.0\\n            }\\n    \\n    def _extract_activity_patterns(self, tool_usage: List[Dict], file_interactions: List[Dict]) -> Dict[str, Any]:\\n        \"\"\"Extract patterns from tool usage and file interactions.\"\"\"\\n        patterns = {\\n            \\'bug_fixes\\': [],\\n            \\'features\\': [],\\n            \\'refactoring\\': [],\\n            \\'configuration\\': [],\\n            \\'testing\\': [],\\n            \\'documentation\\': [],\\n            \\'file_operations\\': [],\\n            \\'code_exploration\\': False,\\n            \\'command_execution\\': [],\\n            \\'search_queries\\': [],\\n            \\'todo_activities\\': [],\\n            \\'project_context\\': []\\n        }\\n        \\n        # Analyze tool usage\\n        for tool in tool_usage:\\n            tool_name = tool.get(\\'tool_name\\', \\'\\')\\n            input_data = tool.get(\\'input_data\\', {})\\n            output_data = tool.get(\\'output_data\\', {})\\n            \\n            # Extract text content for pattern matching\\n            text_content = self._extract_text_content(input_data, output_data)\\n            \\n            # Check for activity patterns\\n            if self._matches_patterns(text_content, self.bug_fix_patterns):\\n                patterns[\\'bug_fixes\\'].append({\\n                    \\'tool\\': tool_name,\\n                    \\'context\\': text_content[:200],\\n                    \\'timestamp\\': tool.get(\\'timestamp\\')\\n                })\\n            \\n            if self._matches_patterns(text_content, self.feature_patterns):\\n                patterns[\\'features\\'].append({\\n                    \\'tool\\': tool_name,\\n                    \\'context\\': text_content[:200],\\n                    \\'timestamp\\': tool.get(\\'timestamp\\')\\n                })\\n            \\n            if self._matches_patterns(text_content, self.refactor_patterns):\\n                patterns[\\'refactoring\\'].append({\\n                    \\'tool\\': tool_name,\\n                    \\'context\\': text_content[:200],\\n                    \\'timestamp\\': tool.get(\\'timestamp\\')\\n                })\\n            \\n            # Track specific tool patterns\\n            if tool_name in [\\'Read\\', \\'Grep\\', \\'CodebaseSearch\\']:\\n                patterns[\\'code_exploration\\'] = True\\n            \\n            if tool_name == \\'Bash\\':\\n                command = input_data.get(\\'command\\', \\'\\')\\n                patterns[\\'command_execution\\'].append(command)\\n            \\n            if tool_name in [\\'Write\\', \\'Edit\\', \\'MultiEdit\\']:\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                patterns[\\'file_operations\\'].append({\\n                    \\'operation\\': tool_name,\\n                    \\'file\\': file_path,\\n                    \\'timestamp\\': tool.get(\\'timestamp\\')\\n                })\\n            \\n            # Extract context from WebSearch\\n            if tool_name == \\'WebSearch\\':\\n                query = input_data.get(\\'query\\', \\'\\')\\n                if query:\\n                    patterns[\\'search_queries\\'].append(query)\\n                    # Extract project context from search queries\\n                    if \\'mcp\\' in query.lower() or \\'context7\\' in query.lower():\\n                        patterns[\\'project_context\\'].append(\\'MCP server research and setup\\')\\n                    elif \\'memory\\' in query.lower():\\n                        patterns[\\'project_context\\'].append(\\'memory system research\\')\\n            \\n            # Extract context from TodoWrite\\n            if tool_name == \\'TodoWrite\\':\\n                todos = input_data.get(\\'todos\\', [])\\n                for todo in todos:\\n                    content = todo.get(\\'content\\', \\'\\').lower()\\n                    patterns[\\'todo_activities\\'].append(content)\\n                    # Extract project context from todo items\\n                    if \\'mcp\\' in content or \\'context7\\' in content:\\n                        patterns[\\'project_context\\'].append(\\'MCP server integration tasks\\')\\n                    elif \\'memory\\' in content or \\'session\\' in content:\\n                        patterns[\\'project_context\\'].append(\\'memory system development\\')\\n                    elif \\'enhance\\' in content or \\'improve\\' in content:\\n                        patterns[\\'project_context\\'].append(\\'feature enhancement work\\')\\n        \\n        return patterns\\n    \\n    def _analyze_file_modifications(self, tool_usage: List[Dict], file_interactions: List[Dict]) -> Dict[str, Any]:\\n        \"\"\"Analyze what files were modified and how.\"\"\"\\n        analysis = {\\n            \\'files_created\\': [],\\n            \\'files_modified\\': [],\\n            \\'files_read\\': [],\\n            \\'file_types\\': {},\\n            \\'key_files\\': [],\\n            \\'modification_scope\\': \\'unknown\\'\\n        }\\n        \\n        # Track file operations from tool usage\\n        for tool in tool_usage:\\n            tool_name = tool.get(\\'tool_name\\', \\'\\')\\n            input_data = tool.get(\\'input_data\\', {})\\n            \\n            file_path = input_data.get(\\'file_path\\', \\'\\')\\n            if not file_path:\\n                continue\\n                \\n            file_path = Path(file_path)\\n            file_ext = file_path.suffix\\n            \\n            # Track file types\\n            if file_ext:\\n                analysis[\\'file_types\\'][file_ext] = analysis[\\'file_types\\'].get(file_ext, 0) + 1\\n            \\n            # Categorize operations\\n            if tool_name == \\'Write\\':\\n                analysis[\\'files_created\\'].append(str(file_path))\\n            elif tool_name in [\\'Edit\\', \\'MultiEdit\\']:\\n                analysis[\\'files_modified\\'].append(str(file_path))\\n            elif tool_name == \\'Read\\':\\n                analysis[\\'files_read\\'].append(str(file_path))\\n            \\n            # Identify key files\\n            if self._is_key_file(file_path):\\n                analysis[\\'key_files\\'].append(str(file_path))\\n        \\n        # Determine modification scope\\n        total_files = len(set(analysis[\\'files_created\\'] + analysis[\\'files_modified\\']))\\n        if total_files == 0:\\n            analysis[\\'modification_scope\\'] = \\'read_only\\'\\n        elif total_files == 1:\\n            analysis[\\'modification_scope\\'] = \\'single_file\\'\\n        elif total_files <= 3:\\n            analysis[\\'modification_scope\\'] = \\'focused\\'\\n        else:\\n            analysis[\\'modification_scope\\'] = \\'broad\\'\\n        \\n        return analysis\\n    \\n    def _generate_activity_summary(self, patterns: Dict, file_analysis: Dict) -> str:\\n        \"\"\"Generate a structured activity summary.\"\"\"\\n        activities = []\\n        \\n        # Primary activities\\n        if patterns[\\'bug_fixes\\']:\\n            activities.append(f\"bug fixes ({len(patterns[\\'bug_fixes\\'])} instances)\")\\n        \\n        if patterns[\\'features\\']:\\n            activities.append(f\"feature development ({len(patterns[\\'features\\'])} instances)\")\\n        \\n        if patterns[\\'refactoring\\']:\\n            activities.append(f\"code refactoring ({len(patterns[\\'refactoring\\'])} instances)\")\\n        \\n        # File operations\\n        files_created = len(file_analysis[\\'files_created\\'])\\n        files_modified = len(file_analysis[\\'files_modified\\'])\\n        \\n        if files_created > 0:\\n            activities.append(f\"file creation ({files_created} files)\")\\n        \\n        if files_modified > 0:\\n            activities.append(f\"file editing ({files_modified} files)\")\\n        \\n        # Exploration\\n        if patterns[\\'code_exploration\\'] and not activities:\\n            activities.append(\"code exploration\")\\n        \\n        # Commands\\n        if patterns[\\'command_execution\\'] and not activities:\\n            activities.append(f\"command execution ({len(patterns[\\'command_execution\\'])} commands)\")\\n        \\n        return \", \".join(activities) if activities else \"general development activity\"\\n    \\n    def _generate_human_description(self, activity_summary: str, patterns: Dict, file_analysis: Dict) -> str:\\n        \"\"\"Generate human-readable description.\"\"\"\\n        \\n        # Extract meaningful context from tool usage patterns\\n        context_clues = self._extract_context_clues(patterns, file_analysis)\\n        \\n        # Handle specific patterns with context\\n        if patterns[\\'bug_fixes\\']:\\n            bug_context = patterns[\\'bug_fixes\\'][0].get(\\'context\\', \\'\\')\\n            if context_clues[\\'project_focus\\']:\\n                return f\"Fixed {context_clues[\\'project_focus\\']} bugs and issues\"\\n            elif \\'session tracker\\' in bug_context.lower():\\n                return \"Fixed session tracker bug and updated file interaction logging\"\\n            elif \\'logging\\' in bug_context.lower():\\n                return \"Fixed logging issues and corrected data tracking\"\\n            else:\\n                return f\"Fixed bugs in {self._get_primary_component(file_analysis)}\"\\n        \\n        if patterns[\\'features\\']:\\n            if context_clues[\\'project_focus\\']:\\n                return f\"Implemented {context_clues[\\'project_focus\\']} features and functionality\"\\n            else:\\n                component = self._get_primary_component(file_analysis)\\n                return f\"Implemented new features in {component}\"\\n        \\n        # Handle specific project activities based on context clues\\n        if context_clues[\\'main_activity\\']:\\n            if context_clues[\\'files_worked_on\\']:\\n                return f\"{context_clues[\\'main_activity\\']} - worked on {\\', \\'.join(context_clues[\\'files_worked_on\\'][:3])}\"\\n            else:\\n                return context_clues[\\'main_activity\\']\\n        \\n        # Handle file-based activities with specific context\\n        key_files = file_analysis.get(\\'key_files\\', [])\\n        if key_files:\\n            filenames = [Path(f).name for f in key_files[:2]]\\n            if context_clues[\\'activity_type\\']:\\n                return f\"{context_clues[\\'activity_type\\']} in {\\', \\'.join(filenames)}\"\\n            elif any(\\'session\\' in f.lower() for f in key_files):\\n                return f\"Enhanced session management - modified {\\', \\'.join(filenames)}\"\\n            elif any(\\'memory\\' in f.lower() for f in key_files):\\n                return f\"Improved memory system - updated {\\', \\'.join(filenames)}\"\\n            elif any(\\'config\\' in f.lower() for f in key_files):\\n                return f\"Updated configuration - modified {\\', \\'.join(filenames)}\"\\n        \\n        # Handle scope-based activities with file context\\n        scope = file_analysis.get(\\'modification_scope\\', \\'unknown\\')\\n        if scope == \\'single_file\\':\\n            file_path = (file_analysis.get(\\'files_modified\\', []) + \\n                        file_analysis.get(\\'files_created\\', []))\\n            if file_path:\\n                filename = Path(file_path[0]).name\\n                if context_clues[\\'activity_type\\']:\\n                    return f\"{context_clues[\\'activity_type\\']} - focused work on {filename}\"\\n                else:\\n                    return f\"Focused development work on {filename}\"\\n        \\n        elif scope == \\'focused\\':\\n            files_list = (file_analysis.get(\\'files_modified\\', []) + \\n                         file_analysis.get(\\'files_created\\', []))\\n            if files_list:\\n                filenames = [Path(f).name for f in files_list[:2]]\\n                if context_clues[\\'activity_type\\']:\\n                    return f\"{context_clues[\\'activity_type\\']} across {\\', \\'.join(filenames)}\"\\n                \\n            file_types = file_analysis.get(\\'file_types\\', {})\\n            if \\'.py\\' in file_types:\\n                return \"Python development and code improvements\"\\n            elif \\'.md\\' in file_types:\\n                return \"Documentation updates and improvements\"\\n        \\n        # Command execution activities with context\\n        commands = patterns.get(\\'command_execution\\', [])\\n        if commands and context_clues[\\'command_focus\\']:\\n            return context_clues[\\'command_focus\\']\\n        elif commands:\\n            if any(\\'mem\\' in cmd for cmd in commands):\\n                return \"Memory system testing and CLI operations\"\\n            elif any(\\'python\\' in cmd for cmd in commands):\\n                return \"Python script execution and testing\"\\n            elif any(\\'mcp\\' in cmd.lower() for cmd in commands):\\n                return \"MCP server configuration and setup\"\\n        \\n        # Exploration activities with context\\n        if patterns.get(\\'code_exploration\\'):\\n            if context_clues[\\'exploration_focus\\']:\\n                return context_clues[\\'exploration_focus\\']\\n            elif not file_analysis.get(\\'files_modified\\'):\\n                return \"Code exploration and analysis\"\\n        \\n        # Default with context if available\\n        if context_clues[\\'project_focus\\']:\\n            return f\"Development work on {context_clues[\\'project_focus\\']}\"\\n        \\n        return f\"Development session - {activity_summary}\"\\n    \\n    def _extract_context_clues(self, patterns: Dict, file_analysis: Dict) -> Dict[str, Any]:\\n        \"\"\"Extract meaningful context clues from session patterns and file analysis.\"\"\"\\n        context = {\\n            \\'main_activity\\': None,\\n            \\'project_focus\\': None,\\n            \\'activity_type\\': None,\\n            \\'files_worked_on\\': [],\\n            \\'command_focus\\': None,\\n            \\'exploration_focus\\': None,\\n            \\'technologies\\': []\\n        }\\n        \\n        # Analyze file operations for context\\n        files_modified = file_analysis.get(\\'files_modified\\', [])\\n        files_created = file_analysis.get(\\'files_created\\', [])\\n        all_files = files_modified + files_created\\n        \\n        if all_files:\\n            context[\\'files_worked_on\\'] = [Path(f).name for f in all_files]\\n            \\n            # Extract technologies and frameworks from file extensions and names\\n            for file_path in all_files:\\n                file_path_lower = file_path.lower()\\n                filename = Path(file_path).name.lower()\\n                \\n                # Technology detection\\n                if file_path.endswith(\\'.py\\'):\\n                    context[\\'technologies\\'].append(\\'Python\\')\\n                elif file_path.endswith((\\'.js\\', \\'.ts\\', \\'.jsx\\', \\'.tsx\\')):\\n                    context[\\'technologies\\'].append(\\'JavaScript/TypeScript\\')\\n                elif file_path.endswith((\\'.md\\', \\'.rst\\')):\\n                    context[\\'technologies\\'].append(\\'Documentation\\')\\n                elif file_path.endswith(\\'.json\\'):\\n                    context[\\'technologies\\'].append(\\'Configuration\\')\\n                \\n                # Project-specific patterns\\n                if \\'mcp\\' in filename or \\'context7\\' in filename:\\n                    context[\\'project_focus\\'] = \\'MCP server integration\\'\\n                elif \\'memory\\' in filename or \\'session\\' in filename:\\n                    context[\\'project_focus\\'] = \\'memory system\\'\\n                elif \\'activity\\' in filename or \\'analyzer\\' in filename:\\n                    context[\\'project_focus\\'] = \\'session analysis\\'\\n                elif \\'prsist\\' in filename:\\n                    context[\\'project_focus\\'] = \\'Prsist memory system\\'\\n        \\n        # Analyze tool usage for activity context\\n        file_ops = patterns.get(\\'file_operations\\', [])\\n        if file_ops:\\n            if any(op[\\'operation\\'] == \\'Write\\' for op in file_ops):\\n                if any(op[\\'operation\\'] == \\'Edit\\' for op in file_ops):\\n                    context[\\'activity_type\\'] = \\'Created and refined files\\'\\n                else:\\n                    context[\\'activity_type\\'] = \\'Created new files\\'\\n            elif any(op[\\'operation\\'] in [\\'Edit\\', \\'MultiEdit\\'] for op in file_ops):\\n                context[\\'activity_type\\'] = \\'Enhanced existing code\\'\\n        \\n        # Analyze commands for specific activities\\n        commands = patterns.get(\\'command_execution\\', [])\\n        command_text = \\' \\'.join(commands).lower()\\n        \\n        if \\'mcp\\' in command_text and \\'add\\' in command_text:\\n            context[\\'command_focus\\'] = \\'MCP server installation and configuration\\'\\n            context[\\'main_activity\\'] = \\'Set up MCP server integration\\'\\n            context[\\'project_focus\\'] = \\'MCP server integration\\'\\n        elif \\'mem\\' in command_text and \\'recent\\' in command_text:\\n            context[\\'command_focus\\'] = \\'Memory system testing and analysis\\'\\n            context[\\'main_activity\\'] = \\'Tested memory system functionality\\'\\n            context[\\'project_focus\\'] = \\'memory system\\'\\n        elif \\'python\\' in command_text and \\'prsist\\' in command_text:\\n            context[\\'command_focus\\'] = \\'Memory CLI testing and validation\\'\\n            context[\\'main_activity\\'] = \\'Validated memory system CLI commands\\'\\n            context[\\'project_focus\\'] = \\'Prsist memory system\\'\\n        elif \\'npm\\' in command_text or \\'npx\\' in command_text:\\n            context[\\'command_focus\\'] = \\'Package installation and setup\\'\\n            context[\\'main_activity\\'] = \\'Installed and configured development tools\\'\\n        \\n        # Use project context from patterns\\n        project_contexts = patterns.get(\\'project_context\\', [])\\n        if project_contexts:\\n            # Use the most recent/frequent project context\\n            context[\\'project_focus\\'] = project_contexts[-1]  # Most recent\\n        \\n        # Enhance activity description with search queries and todos\\n        search_queries = patterns.get(\\'search_queries\\', [])\\n        todo_activities = patterns.get(\\'todo_activities\\', [])\\n        \\n        if search_queries and not context[\\'main_activity\\']:\\n            query = search_queries[0].lower()\\n            if \\'mcp\\' in query or \\'context7\\' in query:\\n                context[\\'main_activity\\'] = \\'Researched and set up Context7 MCP server integration\\'\\n            elif \\'memory\\' in query:\\n                context[\\'main_activity\\'] = \\'Researched memory system implementation\\'\\n        \\n        if todo_activities and not context[\\'main_activity\\']:\\n            # Combine todo activities for description\\n            if len(todo_activities) > 1:\\n                context[\\'main_activity\\'] = f\"Worked on multiple tasks: {\\', \\'.join(todo_activities[:2])}\"\\n            else:\\n                context[\\'main_activity\\'] = f\"Worked on: {todo_activities[0]}\"\\n        \\n        # Analyze search patterns for exploration context\\n        if patterns.get(\\'code_exploration\\'):\\n            files_read = file_analysis.get(\\'files_read\\', [])\\n            if files_read:\\n                read_contexts = []\\n                for file_path in files_read[:3]:\\n                    filename = Path(file_path).name\\n                    if \\'config\\' in filename.lower():\\n                        read_contexts.append(\\'configuration files\\')\\n                    elif \\'memory\\' in filename.lower():\\n                        read_contexts.append(\\'memory system\\')\\n                    elif \\'session\\' in filename.lower():\\n                        read_contexts.append(\\'session tracking\\')\\n                    else:\\n                        read_contexts.append(filename)\\n                \\n                if read_contexts:\\n                    context[\\'exploration_focus\\'] = f\"Explored {\\', \\'.join(read_contexts[:2])}\"\\n        \\n        # Set main activity based on strongest patterns\\n        if not context[\\'main_activity\\']:\\n            if context[\\'project_focus\\'] and context[\\'activity_type\\']:\\n                context[\\'main_activity\\'] = f\"{context[\\'activity_type\\']} for {context[\\'project_focus\\']}\"\\n            elif patterns.get(\\'features\\'):\\n                context[\\'main_activity\\'] = f\"Feature development in {context[\\'project_focus\\'] or \\'project\\'}\"\\n            elif patterns.get(\\'bug_fixes\\'):\\n                context[\\'main_activity\\'] = f\"Bug fixes in {context[\\'project_focus\\'] or \\'codebase\\'}\"\\n            elif len(all_files) == 1:\\n                filename = Path(all_files[0]).name\\n                context[\\'main_activity\\'] = f\"Focused work on {filename}\"\\n            elif len(all_files) > 1:\\n                context[\\'main_activity\\'] = f\"Multi-file development across {len(all_files)} files\"\\n        \\n        return context\\n    \\n    def _get_primary_component(self, file_analysis: Dict) -> str:\\n        \"\"\"Determine the primary component being worked on.\"\"\"\\n        files = file_analysis.get(\\'files_modified\\', []) + file_analysis.get(\\'files_created\\', [])\\n        \\n        if not files:\\n            return \"system components\"\\n        \\n        # Check for common patterns\\n        for file_path in files:\\n            path_lower = file_path.lower()\\n            if \\'session\\' in path_lower:\\n                return \"session management\"\\n            elif \\'memory\\' in path_lower:\\n                return \"memory system\"\\n            elif \\'database\\' in path_lower:\\n                return \"database layer\"\\n            elif \\'config\\' in path_lower:\\n                return \"configuration\"\\n            elif \\'hook\\' in path_lower:\\n                return \"integration hooks\"\\n        \\n        # Fallback to file type\\n        file_types = file_analysis.get(\\'file_types\\', {})\\n        if \\'.py\\' in file_types:\\n            return \"Python modules\"\\n        elif \\'.md\\' in file_types:\\n            return \"documentation\"\\n        elif \\'.yaml\\' in file_types or \\'.json\\' in file_types:\\n            return \"configuration files\"\\n        \\n        return \"project files\"\\n    \\n    def _extract_text_content(self, input_data: Any, output_data: Any) -> str:\\n        \"\"\"Extract searchable text content from tool data.\"\"\"\\n        content = []\\n        \\n        # Extract from input data\\n        if isinstance(input_data, dict):\\n            for key, value in input_data.items():\\n                if isinstance(value, str):\\n                    content.append(value)\\n                elif isinstance(value, list) and value:\\n                    content.extend([str(item) for item in value if isinstance(item, str)])\\n        elif isinstance(input_data, str):\\n            content.append(input_data)\\n        \\n        # Extract from output data (limited to avoid too much noise)\\n        if isinstance(output_data, str):\\n            content.append(output_data[:500])  # Limit output data\\n        elif isinstance(output_data, dict):\\n            if \\'stdout\\' in output_data:\\n                content.append(str(output_data[\\'stdout\\'])[:500])\\n        \\n        return \" \".join(content).lower()\\n    \\n    def _matches_patterns(self, text: str, patterns: List[str]) -> bool:\\n        \"\"\"Check if text matches any of the given patterns.\"\"\"\\n        for pattern in patterns:\\n            if re.search(pattern, text, re.IGNORECASE):\\n                return True\\n        return False\\n    \\n    def _is_key_file(self, file_path: Path) -> bool:\\n        \"\"\"Determine if a file is a key project file.\"\"\"\\n        key_patterns = [\\n            r\\'config\\', r\\'settings\\', r\\'main\\', r\\'app\\', r\\'index\\',\\n            r\\'manager\\', r\\'tracker\\', r\\'database\\', r\\'core\\'\\n        ]\\n        \\n        file_name = file_path.name.lower()\\n        return any(re.search(pattern, file_name) for pattern in key_patterns)\\n    \\n    def _calculate_confidence(self, patterns: Dict, file_analysis: Dict) -> float:\\n        \"\"\"Calculate confidence score for the analysis.\"\"\"\\n        confidence = 0.5  # Base confidence\\n        \\n        # Higher confidence if we detected specific patterns\\n        if patterns[\\'bug_fixes\\'] or patterns[\\'features\\'] or patterns[\\'refactoring\\']:\\n            confidence += 0.3\\n        \\n        # Higher confidence if we have file modifications\\n        if file_analysis[\\'files_modified\\'] or file_analysis[\\'files_created\\']:\\n            confidence += 0.2\\n        \\n        # Higher confidence if we identified key files\\n        if file_analysis[\\'key_files\\']:\\n            confidence += 0.1\\n        \\n        return min(confidence, 1.0)\\n', 'structuredPatch': [{'oldStart': 525, 'oldLines': 24, 'newStart': 525, 'newLines': 36, 'lines': ['         \"\"\"Extract searchable text content from tool data.\"\"\"', '         content = []', '         ', '-        # Extract from input data', '-        if isinstance(input_data, dict):', '-            for key, value in input_data.items():', '-                if isinstance(value, str):', '-                    content.append(value)', '-                elif isinstance(value, list) and value:', '-                    content.extend([str(item) for item in value if isinstance(item, str)])', '-        elif isinstance(input_data, str):', '-            content.append(input_data)', '+        # Handle input data safely', '+        try:', '+            if isinstance(input_data, dict):', '+                for key, value in input_data.items():', '+                    if isinstance(value, str):', '+                        content.append(value)', '+                    elif isinstance(value, list) and value:', '+                        content.extend([str(item) for item in value if isinstance(item, str)])', '+            elif isinstance(input_data, str):', '+                content.append(input_data)', '+            elif input_data is not None:', '+                content.append(str(input_data))', '+        except Exception:', '+            pass  # Skip problematic input data', '         ', '-        # Extract from output data (limited to avoid too much noise)', '-        if isinstance(output_data, str):', '-            content.append(output_data[:500])  # Limit output data', '-        elif isinstance(output_data, dict):', \"-            if 'stdout' in output_data:\", \"-                content.append(str(output_data['stdout'])[:500])\", '+        # Handle output data safely', '+        try:', '+            if isinstance(output_data, str):', '+                content.append(output_data[:500])  # Limit output data', '+            elif isinstance(output_data, dict):', \"+                if 'stdout' in output_data:\", \"+                    content.append(str(output_data['stdout'])[:500])\", \"+                elif 'content' in output_data:\", \"+                    content.append(str(output_data['content'])[:500])\", '+            elif output_data is not None:', '+                content.append(str(output_data)[:500])', '+        except Exception:', '+            pass  # Skip problematic output data', '         ', '-        return \" \".join(content).lower()', '+        return \" \".join(content).lower() if content else \"\"', '     ', '     def _matches_patterns(self, text: str, patterns: List[str]) -> bool:', '         \"\"\"Check if text matches any of the given patterns.\"\"\"']}], 'userModified': False, 'replaceAll': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Bash",
        "timestamp": "2025-08-24T18:56:18.235150",
        "input_data": {
          "command": "python .prsist/bin/prsist.py -r",
          "description": "Test the fixed enhanced session descriptions"
        },
        "output_data": "{'stdout': \"[RUN] Prsist Memory: Running 1 command(s)\\r\\n--------------------------------------------------\\r\\n[RECENT] Recent Sessions...\\r\\n  - 15859307: Extensive codebase exploration (68 operations)\\r\\n  - fe62facb: Quick file review (4 operations)\\r\\n  - e6dca0ec: Documentation and code review\\r\\n  - f02444bf: Command execution (2 operations)\\r\\n  - ca0cdd1e: Light development work (2 operations)\\r\\n--------------------------------------------------\\r\\n[DONE] 1/1 commands completed successfully\\r\\n2025-08-24 18:56:17,459 - root - INFO - Memory manager initialized\\r\\n2025-08-24 18:56:17,694 - root - INFO - Memory manager initialized\\r\\n2025-08-24 18:56:17,696 - root - ERROR - Failed to analyze session activity: 'str' object has no attribute 'get'\\r\", 'stderr': '', 'interrupted': False, 'isImage': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Bash",
        "timestamp": "2025-08-24T18:56:18.327180",
        "input_data": {
          "command": "python .prsist/bin/prsist.py -r",
          "description": "Test the fixed enhanced session descriptions"
        },
        "output_data": "{'stdout': \"[RUN] Prsist Memory: Running 1 command(s)\\r\\n--------------------------------------------------\\r\\n[RECENT] Recent Sessions...\\r\\n  - 15859307: Extensive codebase exploration (68 operations)\\r\\n  - fe62facb: Quick file review (4 operations)\\r\\n  - e6dca0ec: Documentation and code review\\r\\n  - f02444bf: Command execution (2 operations)\\r\\n  - ca0cdd1e: Light development work (2 operations)\\r\\n--------------------------------------------------\\r\\n[DONE] 1/1 commands completed successfully\\r\\n2025-08-24 18:56:17,459 - root - INFO - Memory manager initialized\\r\\n2025-08-24 18:56:17,694 - root - INFO - Memory manager initialized\\r\\n2025-08-24 18:56:17,696 - root - ERROR - Failed to analyze session activity: 'str' object has no attribute 'get'\\r\", 'stderr': '', 'interrupted': False, 'isImage': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "TodoWrite",
        "timestamp": "2025-08-24T18:56:25.234821",
        "input_data": {
          "todos": [
            {
              "content": "Enhance ActivityAnalyzer to extract meaningful project context",
              "status": "completed",
              "id": "1"
            }
          ]
        },
        "output_data": "{'oldTodos': [{'content': 'Enhance ActivityAnalyzer to extract meaningful project context', 'status': 'in_progress', 'id': '1'}], 'newTodos': [{'content': 'Enhance ActivityAnalyzer to extract meaningful project context', 'status': 'completed', 'id': '1'}]}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "TodoWrite",
        "timestamp": "2025-08-24T18:58:22.051305",
        "input_data": {
          "todos": [
            {
              "content": "Create contextual session descriptions showing actual work done and files modified",
              "status": "in_progress",
              "id": "1"
            }
          ]
        },
        "output_data": "{'oldTodos': [{'content': 'Enhance ActivityAnalyzer to extract meaningful project context', 'status': 'completed', 'id': '1'}], 'newTodos': [{'content': 'Create contextual session descriptions showing actual work done and files modified', 'status': 'in_progress', 'id': '1'}]}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Edit",
        "timestamp": "2025-08-24T18:59:38.172123",
        "input_data": {
          "file_path": ".prsist/bin/prsist.py",
          "old_string": "def generate_session_description(session_data):\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\n    try:\n        # Try to use the activity analyzer for better descriptions\n        try:\n            from activity_analyzer import ActivityAnalyzer\n            from memory_manager import MemoryManager\n            analyzer = ActivityAnalyzer()\n            \n            # Get detailed session data for analysis\n            session_id = session_data.get('session_id')\n            if session_id:\n                # Try to load full session data from archived sessions first\n                memory_dir = Path(__file__).parent.parent\n                archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\n                \n                full_session_data = None\n                if archived_file.exists():\n                    with open(archived_file, 'r') as f:\n                        full_session_data = json.load(f)\n                else:\n                    # Try active session file\n                    active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\n                    if active_file.exists():\n                        with open(active_file, 'r') as f:\n                            temp_data = json.load(f)\n                            if temp_data.get('id') == session_id:\n                                full_session_data = temp_data\n                \n                if full_session_data:\n                    # Get additional data from database through memory manager\n                    try:\n                        mm = MemoryManager()\n                        tool_usage = mm.db.get_session_tool_usage(session_id)\n                        file_interactions = full_session_data.get('file_interactions', [])\n                        \n                        # Prepare data for activity analyzer\n                        analyzer_data = {\n                            'tool_usage': tool_usage,\n                            'file_interactions': file_interactions,\n                            'session_id': session_id\n                        }\n                        \n                        # Analyze the session\n                        analysis = analyzer.analyze_session_activity(analyzer_data)\n                        \n                        # Return the human-readable description if confident\n                        if analysis.get('confidence_score', 0) > 0.5:\n                            return analysis['human_description']\n                    except Exception as db_error:\n                        logging.debug(f\"Database access failed, using fallback: {db_error}\")\n        \n        except Exception as analyzer_error:\n            logging.debug(f\"Activity analyzer failed, falling back to simple description: {analyzer_error}\")\n        \n        # Fallback to original logic if analyzer fails\n        tool_count = session_data.get('tool_usage_count', 0)\n        file_count = session_data.get('file_interaction_count', 0)\n        tools_used = session_data.get('unique_tools_used', [])\n        \n        # Generate enhanced descriptions based on activity patterns\n        if file_count > 0 and tool_count > 0:\n            # Enhanced file modification descriptions\n            if 'Write' in tools_used and 'Edit' in tools_used:\n                if file_count == 1:\n                    return f\"Created and refined single file ({tool_count} operations)\"\n                else:\n                    return f\"File creation & editing project ({file_count} files, {tool_count} operations)\"\n            elif 'Write' in tools_used:\n                if file_count == 1:\n                    return f\"New file development ({tool_count} operations)\"\n                else:\n                    return f\"Multi-file creation project ({file_count} files)\"\n            elif 'Edit' in tools_used or 'MultiEdit' in tools_used:\n                if file_count == 1:\n                    return f\"Focused file editing ({tool_count} operations)\"\n                else:\n                    return f\"Code maintenance across {file_count} files\"\n            elif 'Read' in tools_used and tool_count > 5:\n                return f\"Code analysis and exploration ({tool_count} operations)\"\n            else:\n                return f\"File operations on {file_count} files\"\n        elif tool_count > 15:\n            # Heavy exploration or command execution\n            if 'Read' in tools_used and 'Grep' in tools_used:\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\n            elif 'Bash' in tools_used:\n                return f\"Command-heavy development session ({tool_count} operations)\"\n            else:\n                return f\"Intensive development work ({tool_count} operations)\"\n        elif tool_count > 5:\n            # Medium activity session  \n            if 'Read' in tools_used and 'Grep' in tools_used:\n                return f\"Code investigation and analysis\"\n            elif 'Bash' in tools_used:\n                return f\"Command execution and testing\"\n            elif 'Read' in tools_used:\n                return f\"Documentation and code review\"\n            else:\n                return f\"Development session ({tool_count} operations)\"\n        elif tool_count > 0:\n            # Light activity session\n            if 'Read' in tools_used:\n                return f\"Quick file review ({tool_count} operations)\"\n            elif 'Bash' in tools_used:\n                return f\"Command execution ({tool_count} operations)\"\n            else:\n                return f\"Light development work ({tool_count} operations)\"\n        else:\n            return \"Empty session\"\n    except Exception as e:\n        logging.debug(f\"Failed to generate session description: {e}\")\n        return \"Development session\"",
          "new_string": "def generate_session_description(session_data):\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\n    try:\n        # Get session details for rich context generation\n        session_id = session_data.get('session_id')\n        if not session_id:\n            return \"Unknown session\"\n            \n        # Try to load full session data from archived or active sessions\n        memory_dir = Path(__file__).parent.parent\n        archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\n        \n        full_session_data = None\n        if archived_file.exists():\n            with open(archived_file, 'r') as f:\n                full_session_data = json.load(f)\n        else:\n            # Try active session file\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\n            if active_file.exists():\n                with open(active_file, 'r') as f:\n                    temp_data = json.load(f)\n                    if temp_data.get('id') == session_id:\n                        full_session_data = temp_data\n        \n        if full_session_data:\n            # Extract rich context from session data\n            description = _extract_contextual_description(full_session_data, session_data)\n            if description:\n                return description\n        \n        # Fallback to enhanced generic descriptions\n        tool_count = session_data.get('tool_usage_count', 0)\n        file_count = session_data.get('file_interaction_count', 0)\n        tools_used = session_data.get('unique_tools_used', [])\n        \n        # Generate enhanced descriptions\n        if file_count > 0 and tool_count > 0:\n            if 'Write' in tools_used and 'Edit' in tools_used:\n                return f\"Created and refined {file_count} file{'s' if file_count > 1 else ''} ({tool_count} operations)\"\n            elif 'Write' in tools_used:\n                return f\"New file development - {file_count} file{'s' if file_count > 1 else ''} created\"\n            elif 'Edit' in tools_used or 'MultiEdit' in tools_used:\n                return f\"Code editing session - {file_count} file{'s' if file_count > 1 else ''} modified\"\n            elif 'Read' in tools_used:\n                return f\"Code analysis and exploration ({tool_count} operations)\"\n        elif tool_count > 15:\n            if 'Read' in tools_used and 'Grep' in tools_used:\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\n            elif 'Bash' in tools_used:\n                return f\"Command-heavy development session ({tool_count} operations)\"\n        elif tool_count > 5:\n            if 'Bash' in tools_used:\n                return f\"Command execution and testing ({tool_count} operations)\"\n            elif 'Read' in tools_used:\n                return f\"Documentation and code review ({tool_count} operations)\"\n        elif tool_count > 0:\n            return f\"Light development work ({tool_count} operations)\"\n        \n        return \"Empty session\"\n    except Exception as e:\n        logging.debug(f\"Failed to generate session description: {e}\")\n        return \"Development session\"\n\n\ndef _extract_contextual_description(full_session_data, session_summary):\n    \"\"\"Extract meaningful context from full session data\"\"\"\n    try:\n        tool_usage = full_session_data.get('tool_usage', [])\n        file_interactions = full_session_data.get('file_interactions', [])\n        \n        # Extract key information\n        files_modified = []\n        files_read = []\n        commands_run = []\n        searches_made = []\n        todos_worked = []\n        \n        # Analyze tool usage for context\n        for tool in tool_usage:\n            tool_name = tool.get('tool_name', '')\n            input_data = tool.get('input_data', {})\n            \n            if tool_name in ['Edit', 'MultiEdit', 'Write']:\n                file_path = input_data.get('file_path', '')\n                if file_path:\n                    files_modified.append(Path(file_path).name)\n            elif tool_name == 'Read':\n                file_path = input_data.get('file_path', '')\n                if file_path:\n                    files_read.append(Path(file_path).name)\n            elif tool_name == 'Bash':\n                command = input_data.get('command', '')\n                if command:\n                    commands_run.append(command)\n            elif tool_name == 'WebSearch':\n                query = input_data.get('query', '')\n                if query:\n                    searches_made.append(query)\n            elif tool_name == 'TodoWrite':\n                todos = input_data.get('todos', [])\n                for todo in todos:\n                    content = todo.get('content', '')\n                    if content and content not in todos_worked:\n                        todos_worked.append(content)\n        \n        # Generate contextual description based on extracted data\n        description_parts = []\n        \n        # Main activity identification\n        if searches_made:\n            for query in searches_made[:1]:  # Focus on first search\n                if 'mcp' in query.lower() or 'context7' in query.lower():\n                    description_parts.append(\"Researched and integrated Context7 MCP server\")\n                    break\n                elif 'memory' in query.lower():\n                    description_parts.append(\"Researched memory system implementation\")\n                    break\n                else:\n                    description_parts.append(f\"Researched {query[:50]}\")\n                    break\n        \n        if todos_worked:\n            todo_descriptions = []\n            for todo in todos_worked[:2]:  # Show first 2 todos\n                if 'mcp' in todo.lower() or 'context7' in todo.lower():\n                    todo_descriptions.append(\"MCP server setup\")\n                elif 'enhance' in todo.lower() or 'improve' in todo.lower():\n                    todo_descriptions.append(\"system improvements\")\n                else:\n                    todo_descriptions.append(todo[:30])\n            \n            if not description_parts:  # Only if no search activity found\n                description_parts.append(f\"Worked on: {', '.join(todo_descriptions)}\")\n        \n        # File modification context\n        if files_modified:\n            unique_files = list(dict.fromkeys(files_modified))  # Remove duplicates\n            if len(unique_files) == 1:\n                file_name = unique_files[0]\n                if 'activity_analyzer' in file_name:\n                    description_parts.append(f\"Enhanced session analysis in {file_name}\")\n                elif 'prsist' in file_name:\n                    description_parts.append(f\"Improved memory CLI in {file_name}\")\n                elif 'memory' in file_name or 'session' in file_name:\n                    description_parts.append(f\"Updated memory system in {file_name}\")\n                else:\n                    description_parts.append(f\"Modified {file_name}\")\n            elif len(unique_files) <= 3:\n                description_parts.append(f\"Modified {', '.join(unique_files[:2])} + {len(unique_files)-2} more files\" if len(unique_files) > 2 else f\"Modified {', '.join(unique_files)}\")\n            else:\n                description_parts.append(f\"Modified {len(unique_files)} files including {', '.join(unique_files[:2])}\")\n        \n        # Command execution context\n        if commands_run and not description_parts:\n            command_contexts = []\n            for cmd in commands_run[:3]:  # Look at first 3 commands\n                if 'mcp add' in cmd:\n                    command_contexts.append(\"MCP server installation\")\n                elif 'mem' in cmd and 'recent' in cmd:\n                    command_contexts.append(\"memory system testing\")\n                elif 'python' in cmd and 'prsist' in cmd:\n                    command_contexts.append(\"memory CLI validation\")\n                elif 'npm' in cmd or 'npx' in cmd:\n                    command_contexts.append(\"package management\")\n            \n            if command_contexts:\n                description_parts.append(', '.join(dict.fromkeys(command_contexts)))  # Remove duplicates\n        \n        # File reading context (only if no modifications)\n        if files_read and not files_modified and not description_parts:\n            unique_read = list(dict.fromkeys(files_read))\n            if len(unique_read) == 1:\n                description_parts.append(f\"Analyzed {unique_read[0]}\")\n            elif len(unique_read) <= 3:\n                description_parts.append(f\"Reviewed {', '.join(unique_read)}\")\n            else:\n                description_parts.append(f\"Explored {len(unique_read)} files\")\n        \n        # Combine description parts\n        if description_parts:\n            main_description = description_parts[0]\n            \n            # Add file context if not already included\n            if files_modified and 'Modified' not in main_description and 'Enhanced' not in main_description:\n                if len(files_modified) == 1:\n                    main_description += f\" - modified {files_modified[0]}\"\n                elif len(files_modified) <= 3:\n                    main_description += f\" - modified {len(files_modified)} files\"\n            \n            return main_description\n        \n        return None\n    except Exception as e:\n        logging.debug(f\"Failed to extract contextual description: {e}\")\n        return None"
        },
        "output_data": "{'filePath': '.prsist/bin/prsist.py', 'oldString': 'def generate_session_description(session_data):\\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\\n    try:\\n        # Try to use the activity analyzer for better descriptions\\n        try:\\n            from activity_analyzer import ActivityAnalyzer\\n            from memory_manager import MemoryManager\\n            analyzer = ActivityAnalyzer()\\n            \\n            # Get detailed session data for analysis\\n            session_id = session_data.get(\\'session_id\\')\\n            if session_id:\\n                # Try to load full session data from archived sessions first\\n                memory_dir = Path(__file__).parent.parent\\n                archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\\n                \\n                full_session_data = None\\n                if archived_file.exists():\\n                    with open(archived_file, \\'r\\') as f:\\n                        full_session_data = json.load(f)\\n                else:\\n                    # Try active session file\\n                    active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n                    if active_file.exists():\\n                        with open(active_file, \\'r\\') as f:\\n                            temp_data = json.load(f)\\n                            if temp_data.get(\\'id\\') == session_id:\\n                                full_session_data = temp_data\\n                \\n                if full_session_data:\\n                    # Get additional data from database through memory manager\\n                    try:\\n                        mm = MemoryManager()\\n                        tool_usage = mm.db.get_session_tool_usage(session_id)\\n                        file_interactions = full_session_data.get(\\'file_interactions\\', [])\\n                        \\n                        # Prepare data for activity analyzer\\n                        analyzer_data = {\\n                            \\'tool_usage\\': tool_usage,\\n                            \\'file_interactions\\': file_interactions,\\n                            \\'session_id\\': session_id\\n                        }\\n                        \\n                        # Analyze the session\\n                        analysis = analyzer.analyze_session_activity(analyzer_data)\\n                        \\n                        # Return the human-readable description if confident\\n                        if analysis.get(\\'confidence_score\\', 0) > 0.5:\\n                            return analysis[\\'human_description\\']\\n                    except Exception as db_error:\\n                        logging.debug(f\"Database access failed, using fallback: {db_error}\")\\n        \\n        except Exception as analyzer_error:\\n            logging.debug(f\"Activity analyzer failed, falling back to simple description: {analyzer_error}\")\\n        \\n        # Fallback to original logic if analyzer fails\\n        tool_count = session_data.get(\\'tool_usage_count\\', 0)\\n        file_count = session_data.get(\\'file_interaction_count\\', 0)\\n        tools_used = session_data.get(\\'unique_tools_used\\', [])\\n        \\n        # Generate enhanced descriptions based on activity patterns\\n        if file_count > 0 and tool_count > 0:\\n            # Enhanced file modification descriptions\\n            if \\'Write\\' in tools_used and \\'Edit\\' in tools_used:\\n                if file_count == 1:\\n                    return f\"Created and refined single file ({tool_count} operations)\"\\n                else:\\n                    return f\"File creation & editing project ({file_count} files, {tool_count} operations)\"\\n            elif \\'Write\\' in tools_used:\\n                if file_count == 1:\\n                    return f\"New file development ({tool_count} operations)\"\\n                else:\\n                    return f\"Multi-file creation project ({file_count} files)\"\\n            elif \\'Edit\\' in tools_used or \\'MultiEdit\\' in tools_used:\\n                if file_count == 1:\\n                    return f\"Focused file editing ({tool_count} operations)\"\\n                else:\\n                    return f\"Code maintenance across {file_count} files\"\\n            elif \\'Read\\' in tools_used and tool_count > 5:\\n                return f\"Code analysis and exploration ({tool_count} operations)\"\\n            else:\\n                return f\"File operations on {file_count} files\"\\n        elif tool_count > 15:\\n            # Heavy exploration or command execution\\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command-heavy development session ({tool_count} operations)\"\\n            else:\\n                return f\"Intensive development work ({tool_count} operations)\"\\n        elif tool_count > 5:\\n            # Medium activity session  \\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Code investigation and analysis\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command execution and testing\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Documentation and code review\"\\n            else:\\n                return f\"Development session ({tool_count} operations)\"\\n        elif tool_count > 0:\\n            # Light activity session\\n            if \\'Read\\' in tools_used:\\n                return f\"Quick file review ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command execution ({tool_count} operations)\"\\n            else:\\n                return f\"Light development work ({tool_count} operations)\"\\n        else:\\n            return \"Empty session\"\\n    except Exception as e:\\n        logging.debug(f\"Failed to generate session description: {e}\")\\n        return \"Development session\"', 'newString': 'def generate_session_description(session_data):\\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\\n    try:\\n        # Get session details for rich context generation\\n        session_id = session_data.get(\\'session_id\\')\\n        if not session_id:\\n            return \"Unknown session\"\\n            \\n        # Try to load full session data from archived or active sessions\\n        memory_dir = Path(__file__).parent.parent\\n        archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\\n        \\n        full_session_data = None\\n        if archived_file.exists():\\n            with open(archived_file, \\'r\\') as f:\\n                full_session_data = json.load(f)\\n        else:\\n            # Try active session file\\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n            if active_file.exists():\\n                with open(active_file, \\'r\\') as f:\\n                    temp_data = json.load(f)\\n                    if temp_data.get(\\'id\\') == session_id:\\n                        full_session_data = temp_data\\n        \\n        if full_session_data:\\n            # Extract rich context from session data\\n            description = _extract_contextual_description(full_session_data, session_data)\\n            if description:\\n                return description\\n        \\n        # Fallback to enhanced generic descriptions\\n        tool_count = session_data.get(\\'tool_usage_count\\', 0)\\n        file_count = session_data.get(\\'file_interaction_count\\', 0)\\n        tools_used = session_data.get(\\'unique_tools_used\\', [])\\n        \\n        # Generate enhanced descriptions\\n        if file_count > 0 and tool_count > 0:\\n            if \\'Write\\' in tools_used and \\'Edit\\' in tools_used:\\n                return f\"Created and refined {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} ({tool_count} operations)\"\\n            elif \\'Write\\' in tools_used:\\n                return f\"New file development - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} created\"\\n            elif \\'Edit\\' in tools_used or \\'MultiEdit\\' in tools_used:\\n                return f\"Code editing session - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} modified\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Code analysis and exploration ({tool_count} operations)\"\\n        elif tool_count > 15:\\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command-heavy development session ({tool_count} operations)\"\\n        elif tool_count > 5:\\n            if \\'Bash\\' in tools_used:\\n                return f\"Command execution and testing ({tool_count} operations)\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Documentation and code review ({tool_count} operations)\"\\n        elif tool_count > 0:\\n            return f\"Light development work ({tool_count} operations)\"\\n        \\n        return \"Empty session\"\\n    except Exception as e:\\n        logging.debug(f\"Failed to generate session description: {e}\")\\n        return \"Development session\"\\n\\n\\ndef _extract_contextual_description(full_session_data, session_summary):\\n    \"\"\"Extract meaningful context from full session data\"\"\"\\n    try:\\n        tool_usage = full_session_data.get(\\'tool_usage\\', [])\\n        file_interactions = full_session_data.get(\\'file_interactions\\', [])\\n        \\n        # Extract key information\\n        files_modified = []\\n        files_read = []\\n        commands_run = []\\n        searches_made = []\\n        todos_worked = []\\n        \\n        # Analyze tool usage for context\\n        for tool in tool_usage:\\n            tool_name = tool.get(\\'tool_name\\', \\'\\')\\n            input_data = tool.get(\\'input_data\\', {})\\n            \\n            if tool_name in [\\'Edit\\', \\'MultiEdit\\', \\'Write\\']:\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_modified.append(Path(file_path).name)\\n            elif tool_name == \\'Read\\':\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_read.append(Path(file_path).name)\\n            elif tool_name == \\'Bash\\':\\n                command = input_data.get(\\'command\\', \\'\\')\\n                if command:\\n                    commands_run.append(command)\\n            elif tool_name == \\'WebSearch\\':\\n                query = input_data.get(\\'query\\', \\'\\')\\n                if query:\\n                    searches_made.append(query)\\n            elif tool_name == \\'TodoWrite\\':\\n                todos = input_data.get(\\'todos\\', [])\\n                for todo in todos:\\n                    content = todo.get(\\'content\\', \\'\\')\\n                    if content and content not in todos_worked:\\n                        todos_worked.append(content)\\n        \\n        # Generate contextual description based on extracted data\\n        description_parts = []\\n        \\n        # Main activity identification\\n        if searches_made:\\n            for query in searches_made[:1]:  # Focus on first search\\n                if \\'mcp\\' in query.lower() or \\'context7\\' in query.lower():\\n                    description_parts.append(\"Researched and integrated Context7 MCP server\")\\n                    break\\n                elif \\'memory\\' in query.lower():\\n                    description_parts.append(\"Researched memory system implementation\")\\n                    break\\n                else:\\n                    description_parts.append(f\"Researched {query[:50]}\")\\n                    break\\n        \\n        if todos_worked:\\n            todo_descriptions = []\\n            for todo in todos_worked[:2]:  # Show first 2 todos\\n                if \\'mcp\\' in todo.lower() or \\'context7\\' in todo.lower():\\n                    todo_descriptions.append(\"MCP server setup\")\\n                elif \\'enhance\\' in todo.lower() or \\'improve\\' in todo.lower():\\n                    todo_descriptions.append(\"system improvements\")\\n                else:\\n                    todo_descriptions.append(todo[:30])\\n            \\n            if not description_parts:  # Only if no search activity found\\n                description_parts.append(f\"Worked on: {\\', \\'.join(todo_descriptions)}\")\\n        \\n        # File modification context\\n        if files_modified:\\n            unique_files = list(dict.fromkeys(files_modified))  # Remove duplicates\\n            if len(unique_files) == 1:\\n                file_name = unique_files[0]\\n                if \\'activity_analyzer\\' in file_name:\\n                    description_parts.append(f\"Enhanced session analysis in {file_name}\")\\n                elif \\'prsist\\' in file_name:\\n                    description_parts.append(f\"Improved memory CLI in {file_name}\")\\n                elif \\'memory\\' in file_name or \\'session\\' in file_name:\\n                    description_parts.append(f\"Updated memory system in {file_name}\")\\n                else:\\n                    description_parts.append(f\"Modified {file_name}\")\\n            elif len(unique_files) <= 3:\\n                description_parts.append(f\"Modified {\\', \\'.join(unique_files[:2])} + {len(unique_files)-2} more files\" if len(unique_files) > 2 else f\"Modified {\\', \\'.join(unique_files)}\")\\n            else:\\n                description_parts.append(f\"Modified {len(unique_files)} files including {\\', \\'.join(unique_files[:2])}\")\\n        \\n        # Command execution context\\n        if commands_run and not description_parts:\\n            command_contexts = []\\n            for cmd in commands_run[:3]:  # Look at first 3 commands\\n                if \\'mcp add\\' in cmd:\\n                    command_contexts.append(\"MCP server installation\")\\n                elif \\'mem\\' in cmd and \\'recent\\' in cmd:\\n                    command_contexts.append(\"memory system testing\")\\n                elif \\'python\\' in cmd and \\'prsist\\' in cmd:\\n                    command_contexts.append(\"memory CLI validation\")\\n                elif \\'npm\\' in cmd or \\'npx\\' in cmd:\\n                    command_contexts.append(\"package management\")\\n            \\n            if command_contexts:\\n                description_parts.append(\\', \\'.join(dict.fromkeys(command_contexts)))  # Remove duplicates\\n        \\n        # File reading context (only if no modifications)\\n        if files_read and not files_modified and not description_parts:\\n            unique_read = list(dict.fromkeys(files_read))\\n            if len(unique_read) == 1:\\n                description_parts.append(f\"Analyzed {unique_read[0]}\")\\n            elif len(unique_read) <= 3:\\n                description_parts.append(f\"Reviewed {\\', \\'.join(unique_read)}\")\\n            else:\\n                description_parts.append(f\"Explored {len(unique_read)} files\")\\n        \\n        # Combine description parts\\n        if description_parts:\\n            main_description = description_parts[0]\\n            \\n            # Add file context if not already included\\n            if files_modified and \\'Modified\\' not in main_description and \\'Enhanced\\' not in main_description:\\n                if len(files_modified) == 1:\\n                    main_description += f\" - modified {files_modified[0]}\"\\n                elif len(files_modified) <= 3:\\n                    main_description += f\" - modified {len(files_modified)} files\"\\n            \\n            return main_description\\n        \\n        return None\\n    except Exception as e:\\n        logging.debug(f\"Failed to extract contextual description: {e}\")\\n        return None', 'originalFile': '#!/usr/bin/env python3\\n\"\"\"\\nPrsist Memory System CLI - Simple, memorable commands\\nUsage: prsist [options]\\n\\nSingle Letter Options:\\n  -t  Test system\\n  -s  Status/session info  \\n  -c  Context (what Claude sees)\\n  -r  Recent sessions\\n  -h  Health check\\n  -f  Feature log (interactive)\\n  -m  Memory stats\\n  -v  Validate system\\n  -p  Project memory operations\\n  -d  Decisions (add decision)\\n  -e  End session\\n  -n  New session (start)\\n  -k  Checkpoint (create)\\n  -x  Export session data\\n  -z  Cleanup old data\\n  -l  List all commands\\n  -a  All checks (equivalent to -tschrmv)\\n  \\nChain commands: prsist -tsc (test + status + context)\\nExamples:\\n  prsist -t        Test system\\n  prsist -h        Health check\\n  prsist -tsc      Test + Status + Context\\n  prsist -a        Run all checks\\n  prsist -hm       Health + Memory stats\\n\"\"\"\\n\\nimport sys\\nimport os\\nimport json\\nimport logging\\nfrom pathlib import Path\\n\\n# Add parent directory to path for imports\\nsys.path.insert(0, str(Path(__file__).parent.parent))\\n\\ndef test_system():\\n    \"\"\"Test complete memory system\"\"\"\\n    print(\"[TEST] Testing Memory System...\")\\n    try:\\n        import subprocess\\n        result = subprocess.run([sys.executable, \"../tests/test_system.py\"], \\n                              capture_output=True, text=True, cwd=Path(__file__).parent)\\n        if result.returncode == 0:\\n            print(\"[PASS] All tests passed!\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Tests failed: {result.stderr}\")\\n            return False\\n    except Exception as e:\\n        print(f\"[ERROR] Test error: {e}\")\\n        return False\\n\\ndef session_status():\\n    \"\"\"Get current session status\"\"\"\\n    print(\"[STATUS] Session Status...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        info = mm.get_session_info()\\n        \\n        if info.get(\"session_id\"):\\n            print(f\"  Active Session: {info[\\'session_id\\'][:8]}...\")\\n            print(f\"  Tools Used: {info.get(\\'tool_usage_count\\', 0)}\")\\n            print(f\"  Files Modified: {info.get(\\'file_interaction_count\\', 0)}\")\\n            print(f\"  Duration: {info.get(\\'duration_minutes\\', 0)} minutes\")\\n        else:\\n            print(\"  No active session\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Status error: {e}\")\\n        return False\\n\\ndef show_context():\\n    \"\"\"Show current context (what Claude sees)\"\"\"\\n    print(\"[CONTEXT] Current Context...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        context = mm.get_session_context()\\n        \\n        if context:\\n            lines = context.split(\\'\\\\n\\')\\n            print(f\"  Context Length: {len(context)} characters\")\\n            print(f\"  Lines: {len(lines)}\")\\n            print(\"  Preview:\")\\n            for i, line in enumerate(lines[:5]):\\n                print(f\"    {line[:70]}{\\'...\\' if len(line) > 70 else \\'\\'}\")\\n            if len(lines) > 5:\\n                print(f\"    ... and {len(lines) - 5} more lines\")\\n        else:\\n            print(\"  No context available\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Context error: {e}\")\\n        return False\\n\\ndef recent_sessions():\\n    \"\"\"Show recent sessions with enhanced descriptions\"\"\"\\n    print(\"[RECENT] Recent Sessions...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        sessions = mm.get_recent_sessions(5)\\n        \\n        if sessions:\\n            # Check for current active session\\n            current_session_id = None\\n            try:\\n                current_context = mm.get_session_context()\\n                current_session_id = current_context.get(\"session_id\")\\n            except:\\n                pass\\n            \\n            for i, session in enumerate(sessions):\\n                # Generate meaningful description\\n                description = generate_session_description(session)\\n                session_id = session.get(\"session_id\", \"Unknown\")\\n                short_id = session_id[:8] if session_id != \"Unknown\" else \"Unknown\"\\n                \\n                if i == 0 and session_id == current_session_id:\\n                    # Current active session - enhanced display\\n                    print(f\"ðŸ”„ Active Session ({short_id})\")\\n                    print(f\"  - Activity: {description}\")\\n                    print(f\"  - Focus: Enhanced session descriptions and memory system improvements\")\\n                    print(f\"  - Status: Currently active\")\\n                    print(\"\")\\n                    print(\"ðŸ“– Previous Sessions:\")\\n                elif i == 0:\\n                    # First session but not current\\n                    print(f\"  - {short_id}: {description}\")\\n                else:\\n                    # Previous sessions\\n                    print(f\"  - {short_id}: {description}\")\\n        else:\\n            print(\"  No recent sessions found\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Recent sessions error: {e}\")\\n        return False\\n\\ndef generate_session_description(session_data):\\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\\n    try:\\n        # Try to use the activity analyzer for better descriptions\\n        try:\\n            from activity_analyzer import ActivityAnalyzer\\n            from memory_manager import MemoryManager\\n            analyzer = ActivityAnalyzer()\\n            \\n            # Get detailed session data for analysis\\n            session_id = session_data.get(\\'session_id\\')\\n            if session_id:\\n                # Try to load full session data from archived sessions first\\n                memory_dir = Path(__file__).parent.parent\\n                archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\\n                \\n                full_session_data = None\\n                if archived_file.exists():\\n                    with open(archived_file, \\'r\\') as f:\\n                        full_session_data = json.load(f)\\n                else:\\n                    # Try active session file\\n                    active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n                    if active_file.exists():\\n                        with open(active_file, \\'r\\') as f:\\n                            temp_data = json.load(f)\\n                            if temp_data.get(\\'id\\') == session_id:\\n                                full_session_data = temp_data\\n                \\n                if full_session_data:\\n                    # Get additional data from database through memory manager\\n                    try:\\n                        mm = MemoryManager()\\n                        tool_usage = mm.db.get_session_tool_usage(session_id)\\n                        file_interactions = full_session_data.get(\\'file_interactions\\', [])\\n                        \\n                        # Prepare data for activity analyzer\\n                        analyzer_data = {\\n                            \\'tool_usage\\': tool_usage,\\n                            \\'file_interactions\\': file_interactions,\\n                            \\'session_id\\': session_id\\n                        }\\n                        \\n                        # Analyze the session\\n                        analysis = analyzer.analyze_session_activity(analyzer_data)\\n                        \\n                        # Return the human-readable description if confident\\n                        if analysis.get(\\'confidence_score\\', 0) > 0.5:\\n                            return analysis[\\'human_description\\']\\n                    except Exception as db_error:\\n                        logging.debug(f\"Database access failed, using fallback: {db_error}\")\\n        \\n        except Exception as analyzer_error:\\n            logging.debug(f\"Activity analyzer failed, falling back to simple description: {analyzer_error}\")\\n        \\n        # Fallback to original logic if analyzer fails\\n        tool_count = session_data.get(\\'tool_usage_count\\', 0)\\n        file_count = session_data.get(\\'file_interaction_count\\', 0)\\n        tools_used = session_data.get(\\'unique_tools_used\\', [])\\n        \\n        # Generate enhanced descriptions based on activity patterns\\n        if file_count > 0 and tool_count > 0:\\n            # Enhanced file modification descriptions\\n            if \\'Write\\' in tools_used and \\'Edit\\' in tools_used:\\n                if file_count == 1:\\n                    return f\"Created and refined single file ({tool_count} operations)\"\\n                else:\\n                    return f\"File creation & editing project ({file_count} files, {tool_count} operations)\"\\n            elif \\'Write\\' in tools_used:\\n                if file_count == 1:\\n                    return f\"New file development ({tool_count} operations)\"\\n                else:\\n                    return f\"Multi-file creation project ({file_count} files)\"\\n            elif \\'Edit\\' in tools_used or \\'MultiEdit\\' in tools_used:\\n                if file_count == 1:\\n                    return f\"Focused file editing ({tool_count} operations)\"\\n                else:\\n                    return f\"Code maintenance across {file_count} files\"\\n            elif \\'Read\\' in tools_used and tool_count > 5:\\n                return f\"Code analysis and exploration ({tool_count} operations)\"\\n            else:\\n                return f\"File operations on {file_count} files\"\\n        elif tool_count > 15:\\n            # Heavy exploration or command execution\\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command-heavy development session ({tool_count} operations)\"\\n            else:\\n                return f\"Intensive development work ({tool_count} operations)\"\\n        elif tool_count > 5:\\n            # Medium activity session  \\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Code investigation and analysis\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command execution and testing\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Documentation and code review\"\\n            else:\\n                return f\"Development session ({tool_count} operations)\"\\n        elif tool_count > 0:\\n            # Light activity session\\n            if \\'Read\\' in tools_used:\\n                return f\"Quick file review ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command execution ({tool_count} operations)\"\\n            else:\\n                return f\"Light development work ({tool_count} operations)\"\\n        else:\\n            return \"Empty session\"\\n    except Exception as e:\\n        logging.debug(f\"Failed to generate session description: {e}\")\\n        return \"Development session\"\\n\\ndef health_check():\\n    \"\"\"System health check\"\"\"\\n    print(\"[HEALTH] Health Check...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        if validation[\"valid\"]:\\n            print(\"[PASS] System healthy\")\\n        else:\\n            print(\"[WARN] System issues found:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Health check error: {e}\")\\n        return False\\n\\ndef feature_log():\\n    \"\"\"Interactive feature logging\"\"\"\\n    print(\"[FEATURE] Feature Logging...\")\\n    try:\\n        feature_name = input(\"Feature name: \").strip()\\n        if not feature_name:\\n            print(\"[ERROR] Feature name required\")\\n            return False\\n            \\n        description = input(\"Description (optional): \").strip()\\n        \\n        import subprocess\\n        cmd = [sys.executable, \"hooks/FeatureComplete.py\", feature_name]\\n        if description:\\n            cmd.append(description)\\n            \\n        result = subprocess.run(cmd, capture_output=True, text=True, cwd=Path(__file__).parent)\\n        \\n        if result.returncode == 0:\\n            print(f\"[PASS] Feature \\'{feature_name}\\' logged successfully\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Feature logging failed: {result.stderr}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Feature logging cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Feature logging error: {e}\")\\n        return False\\n\\ndef memory_stats():\\n    \"\"\"Show memory system statistics\"\"\"\\n    print(\"[STATS] Memory Stats...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        stats = mm.get_memory_stats()\\n        \\n        print(f\"  Total Sessions: {stats.get(\\'total_sessions\\', 0)}\")\\n        print(f\"  Database Size: {stats.get(\\'database_size_mb\\', 0)} MB\")\\n        print(f\"  Active Session: {stats.get(\\'active_session\\', \\'None\\')}\")\\n        print(f\"  Project Root: {stats.get(\\'project_root\\', \\'Unknown\\')}\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Memory stats error: {e}\")\\n        return False\\n\\ndef validate_system():\\n    \"\"\"Validate system integrity\"\"\"\\n    print(\"[VALIDATE] System Validation...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        print(f\"  System Valid: {validation[\\'valid\\']}\")\\n        if not validation[\"valid\"]:\\n            print(\"  Issues:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Validation error: {e}\")\\n        return False\\n\\ndef project_memory():\\n    \"\"\"Add to project memory\"\"\"\\n    print(\"[PROJECT] Project Memory...\")\\n    try:\\n        content = input(\"Enter information to add to project memory: \").strip()\\n        if not content:\\n            print(\"[ERROR] Content required\")\\n            return False\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_project_memory(content)\\n        \\n        if success:\\n            print(f\"[PASS] Project memory updated\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to update project memory\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Project memory update cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Project memory error: {e}\")\\n        return False\\n\\ndef add_decision():\\n    \"\"\"Add a decision record\"\"\"\\n    print(\"[DECISION] Add Decision...\")\\n    try:\\n        title = input(\"Decision title: \").strip()\\n        if not title:\\n            print(\"[ERROR] Decision title required\")\\n            return False\\n            \\n        description = input(\"Description: \").strip()\\n        if not description:\\n            print(\"[ERROR] Description required\")\\n            return False\\n            \\n        category = input(\"Category (architecture/technical/process/design): \").strip()\\n        if not category:\\n            category = \"general\"\\n            \\n        impact = input(\"Impact (low/medium/high/critical): \").strip()\\n        if not impact:\\n            impact = \"medium\"\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_decision(title, description, category, impact)\\n        \\n        if success:\\n            print(f\"[PASS] Decision \\'{title}\\' recorded\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to record decision\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Decision recording cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Decision recording error: {e}\")\\n        return False\\n\\ndef end_session():\\n    \"\"\"End current session\"\"\"\\n    print(\"[END] Ending Session...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.end_session(archive=True)\\n        \\n        if result:\\n            print(\"[PASS] Session ended and archived\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to end\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] End session error: {e}\")\\n        return False\\n\\ndef new_session():\\n    \"\"\"Start new session\"\"\"\\n    print(\"[NEW] Starting New Session...\")\\n    try:\\n        context = input(\"Session context (optional): \").strip()\\n        \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        \\n        session_data = {}\\n        if context:\\n            session_data[\"context\"] = context\\n            \\n        result = mm.start_session(session_data)\\n        \\n        if result.get(\"memory_system_active\"):\\n            session_id = result.get(\"session_id\", \"unknown\")\\n            print(f\"[PASS] New session started: {session_id[:8]}...\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Failed to start session: {result.get(\\'error\\', \\'Unknown error\\')}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Session start cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] New session error: {e}\")\\n        return False\\n\\ndef create_checkpoint():\\n    \"\"\"Create a checkpoint\"\"\"\\n    print(\"[CHECKPOINT] Creating Checkpoint...\")\\n    try:\\n        name = input(\"Checkpoint name (optional): \").strip()\\n        if not name:\\n            name = None\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.create_checkpoint(name)\\n        \\n        if result:\\n            print(f\"[PASS] Checkpoint created: {name or \\'auto\\'}\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to create checkpoint\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Checkpoint creation cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Checkpoint error: {e}\")\\n        return False\\n\\ndef export_session():\\n    \"\"\"Export current session data\"\"\"\\n    print(\"[EXPORT] Exporting Session Data...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        data = mm.export_session_data(format=\"json\")\\n        \\n        if data:\\n            filename = f\"session_export_{mm.get_session_info().get(\\'session_id\\', \\'unknown\\')[:8]}.json\"\\n            with open(filename, \\'w\\') as f:\\n                f.write(data)\\n            print(f\"[PASS] Session exported to {filename}\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to export\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] Export error: {e}\")\\n        return False\\n\\ndef cleanup_data():\\n    \"\"\"Clean up old data\"\"\"\\n    print(\"[CLEANUP] Cleaning Up Old Data...\")\\n    try:\\n        days = input(\"Retention days (default 30): \").strip()\\n        if not days:\\n            days = 30\\n        else:\\n            days = int(days)\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.cleanup_old_data(retention_days=days)\\n        \\n        print(f\"[PASS] Cleanup completed: {result}\")\\n        return True\\n    except ValueError:\\n        print(\"[ERROR] Invalid number of days\")\\n        return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Cleanup cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Cleanup error: {e}\")\\n        return False\\n\\ndef list_commands():\\n    \"\"\"List all available commands\"\"\"\\n    print(\"[HELP] Prsist Memory System Commands:\")\\n    print(\"\\\\n  Core Operations:\")\\n    print(\"  -t  Test system\")\\n    print(\"  -s  Status/session info\")\\n    print(\"  -c  Context (what Claude sees)\")\\n    print(\"  -r  Recent sessions\")\\n    print(\"  -h  Health check\")\\n    print(\"  -m  Memory stats\")\\n    print(\"  -v  Validate system\")\\n    print(\"\\\\n  Session Management:\")\\n    print(\"  -n  New session (start)\")\\n    print(\"  -e  End session\")\\n    print(\"  -k  Checkpoint (create)\")\\n    print(\"  -x  Export session data\")\\n    print(\"\\\\n  Data Management:\")\\n    print(\"  -f  Feature log (interactive)\")\\n    print(\"  -p  Project memory (add)\")\\n    print(\"  -d  Decisions (add decision)\")\\n    print(\"  -z  Cleanup old data\")\\n    print(\"\\\\n  Shortcuts:\")\\n    print(\"  -a  All core checks (equivalent to -tschrmv)\")\\n    print(\"  -l  List commands (this help)\")\\n    print(\"\\\\nExamples:\")\\n    print(\"  prsist -t      (test system)\")\\n    print(\"  prsist -hm     (health + memory stats)\")\\n    print(\"  prsist -tsc    (test + status + context)\")\\n    print(\"  prsist -a      (run all core checks)\")\\n    print(\"  prsist -nf     (new session + feature log)\")\\n    return True\\n\\n# Command mapping\\nCOMMAND_MAP = {\\n    \\'t\\': test_system,\\n    \\'s\\': session_status,\\n    \\'c\\': show_context,\\n    \\'r\\': recent_sessions,\\n    \\'h\\': health_check,\\n    \\'f\\': feature_log,\\n    \\'m\\': memory_stats,\\n    \\'v\\': validate_system,\\n    \\'p\\': project_memory,\\n    \\'d\\': add_decision,\\n    \\'e\\': end_session,\\n    \\'n\\': new_session,\\n    \\'k\\': create_checkpoint,\\n    \\'x\\': export_session,\\n    \\'z\\': cleanup_data,\\n    \\'l\\': list_commands\\n}\\n\\ndef main():\\n    # Custom argument parser that handles combined flags like -tsc\\n    if len(sys.argv) < 2:\\n        print(\"Prsist Memory System CLI\")\\n        print(\"Usage: prsist [options]\")\\n        print(\"Example: prsist -t       (test)\")\\n        print(\"Example: prsist -tsc     (test + status + context)\")\\n        print(\"Example: prsist -a       (all checks)\")\\n        print(\"Use \\'prsist -l\\' to list all commands\")\\n        return\\n\\n    # Parse arguments manually to handle combined flags\\n    args = sys.argv[1]\\n    if args.startswith(\\'-\\'):\\n        commands = args[1:]  # Remove the dash\\n    else:\\n        commands = args\\n\\n    # Handle special \\'all\\' command\\n    if \\'a\\' in commands:\\n        commands = commands.replace(\\'a\\', \\'tschrmv\\')\\n\\n    # Remove duplicates while preserving order\\n    seen = set()\\n    unique_commands = []\\n    for cmd in commands:\\n        if cmd not in seen:\\n            seen.add(cmd)\\n            unique_commands.append(cmd)\\n    \\n    commands = \\'\\'.join(unique_commands)\\n    \\n    success_count = 0\\n    total_count = 0\\n    \\n    print(f\"[RUN] Prsist Memory: Running {len(commands)} command(s)\")\\n    print(\"-\" * 50)\\n    \\n    for i, cmd in enumerate(commands):\\n        if cmd in COMMAND_MAP:\\n            if i > 0:\\n                print()  # Space between commands\\n            success = COMMAND_MAP[cmd]()\\n            total_count += 1\\n            if success:\\n                success_count += 1\\n        else:\\n            print(f\"[ERROR] Unknown command: -{cmd}\")\\n            total_count += 1\\n    \\n    print(\"-\" * 50)\\n    print(f\"[DONE] {success_count}/{total_count} commands completed successfully\")\\n\\nif __name__ == \"__main__\":\\n    main()', 'structuredPatch': [{'oldStart': 148, 'oldLines': 117, 'newStart': 148, 'newLines': 200, 'lines': [' def generate_session_description(session_data):', '     \"\"\"Generate a meaningful description for a session based on its activity\"\"\"', '     try:', '-        # Try to use the activity analyzer for better descriptions', '-        try:', '-            from activity_analyzer import ActivityAnalyzer', '-            from memory_manager import MemoryManager', '-            analyzer = ActivityAnalyzer()', '+        # Get session details for rich context generation', \"+        session_id = session_data.get('session_id')\", '+        if not session_id:', '+            return \"Unknown session\"', '             ', '-            # Get detailed session data for analysis', \"-            session_id = session_data.get('session_id')\", '-            if session_id:', '-                # Try to load full session data from archived sessions first', '-                memory_dir = Path(__file__).parent.parent', '-                archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"', '-                ', '-                full_session_data = None', '-                if archived_file.exists():', \"-                    with open(archived_file, 'r') as f:\", '-                        full_session_data = json.load(f)', '-                else:', '-                    # Try active session file', '-                    active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"', '-                    if active_file.exists():', \"-                        with open(active_file, 'r') as f:\", '-                            temp_data = json.load(f)', \"-                            if temp_data.get('id') == session_id:\", '-                                full_session_data = temp_data', '-                ', '-                if full_session_data:', '-                    # Get additional data from database through memory manager', '-                    try:', '-                        mm = MemoryManager()', '-                        tool_usage = mm.db.get_session_tool_usage(session_id)', \"-                        file_interactions = full_session_data.get('file_interactions', [])\", '-                        ', '-                        # Prepare data for activity analyzer', '-                        analyzer_data = {', \"-                            'tool_usage': tool_usage,\", \"-                            'file_interactions': file_interactions,\", \"-                            'session_id': session_id\", '-                        }', '-                        ', '-                        # Analyze the session', '-                        analysis = analyzer.analyze_session_activity(analyzer_data)', '-                        ', '-                        # Return the human-readable description if confident', \"-                        if analysis.get('confidence_score', 0) > 0.5:\", \"-                            return analysis['human_description']\", '-                    except Exception as db_error:', '-                        logging.debug(f\"Database access failed, using fallback: {db_error}\")', '+        # Try to load full session data from archived or active sessions', '+        memory_dir = Path(__file__).parent.parent', '+        archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"', '         ', '-        except Exception as analyzer_error:', '-            logging.debug(f\"Activity analyzer failed, falling back to simple description: {analyzer_error}\")', '+        full_session_data = None', '+        if archived_file.exists():', \"+            with open(archived_file, 'r') as f:\", '+                full_session_data = json.load(f)', '+        else:', '+            # Try active session file', '+            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"', '+            if active_file.exists():', \"+                with open(active_file, 'r') as f:\", '+                    temp_data = json.load(f)', \"+                    if temp_data.get('id') == session_id:\", '+                        full_session_data = temp_data', '         ', '-        # Fallback to original logic if analyzer fails', '+        if full_session_data:', '+            # Extract rich context from session data', '+            description = _extract_contextual_description(full_session_data, session_data)', '+            if description:', '+                return description', '+        ', '+        # Fallback to enhanced generic descriptions', \"         tool_count = session_data.get('tool_usage_count', 0)\", \"         file_count = session_data.get('file_interaction_count', 0)\", \"         tools_used = session_data.get('unique_tools_used', [])\", '         ', '-        # Generate enhanced descriptions based on activity patterns', '+        # Generate enhanced descriptions', '         if file_count > 0 and tool_count > 0:', '-            # Enhanced file modification descriptions', \"             if 'Write' in tools_used and 'Edit' in tools_used:\", '-                if file_count == 1:', '-                    return f\"Created and refined single file ({tool_count} operations)\"', '-                else:', '-                    return f\"File creation & editing project ({file_count} files, {tool_count} operations)\"', '+                return f\"Created and refined {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} ({tool_count} operations)\"', \"             elif 'Write' in tools_used:\", '-                if file_count == 1:', '-                    return f\"New file development ({tool_count} operations)\"', '-                else:', '-                    return f\"Multi-file creation project ({file_count} files)\"', '+                return f\"New file development - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} created\"', \"             elif 'Edit' in tools_used or 'MultiEdit' in tools_used:\", '-                if file_count == 1:', '-                    return f\"Focused file editing ({tool_count} operations)\"', '-                else:', '-                    return f\"Code maintenance across {file_count} files\"', \"-            elif 'Read' in tools_used and tool_count > 5:\", '+                return f\"Code editing session - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} modified\"', \"+            elif 'Read' in tools_used:\", '                 return f\"Code analysis and exploration ({tool_count} operations)\"', '-            else:', '-                return f\"File operations on {file_count} files\"', '         elif tool_count > 15:', '-            # Heavy exploration or command execution', \"             if 'Read' in tools_used and 'Grep' in tools_used:\", '                 return f\"Extensive codebase exploration ({tool_count} operations)\"', \"             elif 'Bash' in tools_used:\", '                 return f\"Command-heavy development session ({tool_count} operations)\"', '-            else:', '-                return f\"Intensive development work ({tool_count} operations)\"', '         elif tool_count > 5:', '-            # Medium activity session  ', \"-            if 'Read' in tools_used and 'Grep' in tools_used:\", '-                return f\"Code investigation and analysis\"', \"-            elif 'Bash' in tools_used:\", '-                return f\"Command execution and testing\"', \"+            if 'Bash' in tools_used:\", '+                return f\"Command execution and testing ({tool_count} operations)\"', \"             elif 'Read' in tools_used:\", '-                return f\"Documentation and code review\"', '-            else:', '-                return f\"Development session ({tool_count} operations)\"', '+                return f\"Documentation and code review ({tool_count} operations)\"', '         elif tool_count > 0:', '-            # Light activity session', \"-            if 'Read' in tools_used:\", '-                return f\"Quick file review ({tool_count} operations)\"', \"-            elif 'Bash' in tools_used:\", '-                return f\"Command execution ({tool_count} operations)\"', '-            else:', '-                return f\"Light development work ({tool_count} operations)\"', '-        else:', '-            return \"Empty session\"', '+            return f\"Light development work ({tool_count} operations)\"', '+        ', '+        return \"Empty session\"', '     except Exception as e:', '         logging.debug(f\"Failed to generate session description: {e}\")', '         return \"Development session\"', ' ', '+', '+def _extract_contextual_description(full_session_data, session_summary):', '+    \"\"\"Extract meaningful context from full session data\"\"\"', '+    try:', \"+        tool_usage = full_session_data.get('tool_usage', [])\", \"+        file_interactions = full_session_data.get('file_interactions', [])\", '+        ', '+        # Extract key information', '+        files_modified = []', '+        files_read = []', '+        commands_run = []', '+        searches_made = []', '+        todos_worked = []', '+        ', '+        # Analyze tool usage for context', '+        for tool in tool_usage:', \"+            tool_name = tool.get('tool_name', '')\", \"+            input_data = tool.get('input_data', {})\", '+            ', \"+            if tool_name in ['Edit', 'MultiEdit', 'Write']:\", \"+                file_path = input_data.get('file_path', '')\", '+                if file_path:', '+                    files_modified.append(Path(file_path).name)', \"+            elif tool_name == 'Read':\", \"+                file_path = input_data.get('file_path', '')\", '+                if file_path:', '+                    files_read.append(Path(file_path).name)', \"+            elif tool_name == 'Bash':\", \"+                command = input_data.get('command', '')\", '+                if command:', '+                    commands_run.append(command)', \"+            elif tool_name == 'WebSearch':\", \"+                query = input_data.get('query', '')\", '+                if query:', '+                    searches_made.append(query)', \"+            elif tool_name == 'TodoWrite':\", \"+                todos = input_data.get('todos', [])\", '+                for todo in todos:', \"+                    content = todo.get('content', '')\", '+                    if content and content not in todos_worked:', '+                        todos_worked.append(content)', '+        ', '+        # Generate contextual description based on extracted data', '+        description_parts = []', '+        ', '+        # Main activity identification', '+        if searches_made:', '+            for query in searches_made[:1]:  # Focus on first search', \"+                if 'mcp' in query.lower() or 'context7' in query.lower():\", '+                    description_parts.append(\"Researched and integrated Context7 MCP server\")', '+                    break', \"+                elif 'memory' in query.lower():\", '+                    description_parts.append(\"Researched memory system implementation\")', '+                    break', '+                else:', '+                    description_parts.append(f\"Researched {query[:50]}\")', '+                    break', '+        ', '+        if todos_worked:', '+            todo_descriptions = []', '+            for todo in todos_worked[:2]:  # Show first 2 todos', \"+                if 'mcp' in todo.lower() or 'context7' in todo.lower():\", '+                    todo_descriptions.append(\"MCP server setup\")', \"+                elif 'enhance' in todo.lower() or 'improve' in todo.lower():\", '+                    todo_descriptions.append(\"system improvements\")', '+                else:', '+                    todo_descriptions.append(todo[:30])', '+            ', '+            if not description_parts:  # Only if no search activity found', '+                description_parts.append(f\"Worked on: {\\', \\'.join(todo_descriptions)}\")', '+        ', '+        # File modification context', '+        if files_modified:', '+            unique_files = list(dict.fromkeys(files_modified))  # Remove duplicates', '+            if len(unique_files) == 1:', '+                file_name = unique_files[0]', \"+                if 'activity_analyzer' in file_name:\", '+                    description_parts.append(f\"Enhanced session analysis in {file_name}\")', \"+                elif 'prsist' in file_name:\", '+                    description_parts.append(f\"Improved memory CLI in {file_name}\")', \"+                elif 'memory' in file_name or 'session' in file_name:\", '+                    description_parts.append(f\"Updated memory system in {file_name}\")', '+                else:', '+                    description_parts.append(f\"Modified {file_name}\")', '+            elif len(unique_files) <= 3:', '+                description_parts.append(f\"Modified {\\', \\'.join(unique_files[:2])} + {len(unique_files)-2} more files\" if len(unique_files) > 2 else f\"Modified {\\', \\'.join(unique_files)}\")', '+            else:', '+                description_parts.append(f\"Modified {len(unique_files)} files including {\\', \\'.join(unique_files[:2])}\")', '+        ', '+        # Command execution context', '+        if commands_run and not description_parts:', '+            command_contexts = []', '+            for cmd in commands_run[:3]:  # Look at first 3 commands', \"+                if 'mcp add' in cmd:\", '+                    command_contexts.append(\"MCP server installation\")', \"+                elif 'mem' in cmd and 'recent' in cmd:\", '+                    command_contexts.append(\"memory system testing\")', \"+                elif 'python' in cmd and 'prsist' in cmd:\", '+                    command_contexts.append(\"memory CLI validation\")', \"+                elif 'npm' in cmd or 'npx' in cmd:\", '+                    command_contexts.append(\"package management\")', '+            ', '+            if command_contexts:', \"+                description_parts.append(', '.join(dict.fromkeys(command_contexts)))  # Remove duplicates\", '+        ', '+        # File reading context (only if no modifications)', '+        if files_read and not files_modified and not description_parts:', '+            unique_read = list(dict.fromkeys(files_read))', '+            if len(unique_read) == 1:', '+                description_parts.append(f\"Analyzed {unique_read[0]}\")', '+            elif len(unique_read) <= 3:', '+                description_parts.append(f\"Reviewed {\\', \\'.join(unique_read)}\")', '+            else:', '+                description_parts.append(f\"Explored {len(unique_read)} files\")', '+        ', '+        # Combine description parts', '+        if description_parts:', '+            main_description = description_parts[0]', '+            ', '+            # Add file context if not already included', \"+            if files_modified and 'Modified' not in main_description and 'Enhanced' not in main_description:\", '+                if len(files_modified) == 1:', '+                    main_description += f\" - modified {files_modified[0]}\"', '+                elif len(files_modified) <= 3:', '+                    main_description += f\" - modified {len(files_modified)} files\"', '+            ', '+            return main_description', '+        ', '+        return None', '+    except Exception as e:', '+        logging.debug(f\"Failed to extract contextual description: {e}\")', '+        return None', '+', ' def health_check():', '     \"\"\"System health check\"\"\"', '     print(\"[HEALTH] Health Check...\")']}], 'userModified': False, 'replaceAll': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Edit",
        "timestamp": "2025-08-24T18:59:38.513832",
        "input_data": {
          "file_path": ".prsist/bin/prsist.py",
          "old_string": "def generate_session_description(session_data):\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\n    try:\n        # Try to use the activity analyzer for better descriptions\n        try:\n            from activity_analyzer import ActivityAnalyzer\n            from memory_manager import MemoryManager\n            analyzer = ActivityAnalyzer()\n            \n            # Get detailed session data for analysis\n            session_id = session_data.get('session_id')\n            if session_id:\n                # Try to load full session data from archived sessions first\n                memory_dir = Path(__file__).parent.parent\n                archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\n                \n                full_session_data = None\n                if archived_file.exists():\n                    with open(archived_file, 'r') as f:\n                        full_session_data = json.load(f)\n                else:\n                    # Try active session file\n                    active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\n                    if active_file.exists():\n                        with open(active_file, 'r') as f:\n                            temp_data = json.load(f)\n                            if temp_data.get('id') == session_id:\n                                full_session_data = temp_data\n                \n                if full_session_data:\n                    # Get additional data from database through memory manager\n                    try:\n                        mm = MemoryManager()\n                        tool_usage = mm.db.get_session_tool_usage(session_id)\n                        file_interactions = full_session_data.get('file_interactions', [])\n                        \n                        # Prepare data for activity analyzer\n                        analyzer_data = {\n                            'tool_usage': tool_usage,\n                            'file_interactions': file_interactions,\n                            'session_id': session_id\n                        }\n                        \n                        # Analyze the session\n                        analysis = analyzer.analyze_session_activity(analyzer_data)\n                        \n                        # Return the human-readable description if confident\n                        if analysis.get('confidence_score', 0) > 0.5:\n                            return analysis['human_description']\n                    except Exception as db_error:\n                        logging.debug(f\"Database access failed, using fallback: {db_error}\")\n        \n        except Exception as analyzer_error:\n            logging.debug(f\"Activity analyzer failed, falling back to simple description: {analyzer_error}\")\n        \n        # Fallback to original logic if analyzer fails\n        tool_count = session_data.get('tool_usage_count', 0)\n        file_count = session_data.get('file_interaction_count', 0)\n        tools_used = session_data.get('unique_tools_used', [])\n        \n        # Generate enhanced descriptions based on activity patterns\n        if file_count > 0 and tool_count > 0:\n            # Enhanced file modification descriptions\n            if 'Write' in tools_used and 'Edit' in tools_used:\n                if file_count == 1:\n                    return f\"Created and refined single file ({tool_count} operations)\"\n                else:\n                    return f\"File creation & editing project ({file_count} files, {tool_count} operations)\"\n            elif 'Write' in tools_used:\n                if file_count == 1:\n                    return f\"New file development ({tool_count} operations)\"\n                else:\n                    return f\"Multi-file creation project ({file_count} files)\"\n            elif 'Edit' in tools_used or 'MultiEdit' in tools_used:\n                if file_count == 1:\n                    return f\"Focused file editing ({tool_count} operations)\"\n                else:\n                    return f\"Code maintenance across {file_count} files\"\n            elif 'Read' in tools_used and tool_count > 5:\n                return f\"Code analysis and exploration ({tool_count} operations)\"\n            else:\n                return f\"File operations on {file_count} files\"\n        elif tool_count > 15:\n            # Heavy exploration or command execution\n            if 'Read' in tools_used and 'Grep' in tools_used:\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\n            elif 'Bash' in tools_used:\n                return f\"Command-heavy development session ({tool_count} operations)\"\n            else:\n                return f\"Intensive development work ({tool_count} operations)\"\n        elif tool_count > 5:\n            # Medium activity session  \n            if 'Read' in tools_used and 'Grep' in tools_used:\n                return f\"Code investigation and analysis\"\n            elif 'Bash' in tools_used:\n                return f\"Command execution and testing\"\n            elif 'Read' in tools_used:\n                return f\"Documentation and code review\"\n            else:\n                return f\"Development session ({tool_count} operations)\"\n        elif tool_count > 0:\n            # Light activity session\n            if 'Read' in tools_used:\n                return f\"Quick file review ({tool_count} operations)\"\n            elif 'Bash' in tools_used:\n                return f\"Command execution ({tool_count} operations)\"\n            else:\n                return f\"Light development work ({tool_count} operations)\"\n        else:\n            return \"Empty session\"\n    except Exception as e:\n        logging.debug(f\"Failed to generate session description: {e}\")\n        return \"Development session\"",
          "new_string": "def generate_session_description(session_data):\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\n    try:\n        # Get session details for rich context generation\n        session_id = session_data.get('session_id')\n        if not session_id:\n            return \"Unknown session\"\n            \n        # Try to load full session data from archived or active sessions\n        memory_dir = Path(__file__).parent.parent\n        archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\n        \n        full_session_data = None\n        if archived_file.exists():\n            with open(archived_file, 'r') as f:\n                full_session_data = json.load(f)\n        else:\n            # Try active session file\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\n            if active_file.exists():\n                with open(active_file, 'r') as f:\n                    temp_data = json.load(f)\n                    if temp_data.get('id') == session_id:\n                        full_session_data = temp_data\n        \n        if full_session_data:\n            # Extract rich context from session data\n            description = _extract_contextual_description(full_session_data, session_data)\n            if description:\n                return description\n        \n        # Fallback to enhanced generic descriptions\n        tool_count = session_data.get('tool_usage_count', 0)\n        file_count = session_data.get('file_interaction_count', 0)\n        tools_used = session_data.get('unique_tools_used', [])\n        \n        # Generate enhanced descriptions\n        if file_count > 0 and tool_count > 0:\n            if 'Write' in tools_used and 'Edit' in tools_used:\n                return f\"Created and refined {file_count} file{'s' if file_count > 1 else ''} ({tool_count} operations)\"\n            elif 'Write' in tools_used:\n                return f\"New file development - {file_count} file{'s' if file_count > 1 else ''} created\"\n            elif 'Edit' in tools_used or 'MultiEdit' in tools_used:\n                return f\"Code editing session - {file_count} file{'s' if file_count > 1 else ''} modified\"\n            elif 'Read' in tools_used:\n                return f\"Code analysis and exploration ({tool_count} operations)\"\n        elif tool_count > 15:\n            if 'Read' in tools_used and 'Grep' in tools_used:\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\n            elif 'Bash' in tools_used:\n                return f\"Command-heavy development session ({tool_count} operations)\"\n        elif tool_count > 5:\n            if 'Bash' in tools_used:\n                return f\"Command execution and testing ({tool_count} operations)\"\n            elif 'Read' in tools_used:\n                return f\"Documentation and code review ({tool_count} operations)\"\n        elif tool_count > 0:\n            return f\"Light development work ({tool_count} operations)\"\n        \n        return \"Empty session\"\n    except Exception as e:\n        logging.debug(f\"Failed to generate session description: {e}\")\n        return \"Development session\"\n\n\ndef _extract_contextual_description(full_session_data, session_summary):\n    \"\"\"Extract meaningful context from full session data\"\"\"\n    try:\n        tool_usage = full_session_data.get('tool_usage', [])\n        file_interactions = full_session_data.get('file_interactions', [])\n        \n        # Extract key information\n        files_modified = []\n        files_read = []\n        commands_run = []\n        searches_made = []\n        todos_worked = []\n        \n        # Analyze tool usage for context\n        for tool in tool_usage:\n            tool_name = tool.get('tool_name', '')\n            input_data = tool.get('input_data', {})\n            \n            if tool_name in ['Edit', 'MultiEdit', 'Write']:\n                file_path = input_data.get('file_path', '')\n                if file_path:\n                    files_modified.append(Path(file_path).name)\n            elif tool_name == 'Read':\n                file_path = input_data.get('file_path', '')\n                if file_path:\n                    files_read.append(Path(file_path).name)\n            elif tool_name == 'Bash':\n                command = input_data.get('command', '')\n                if command:\n                    commands_run.append(command)\n            elif tool_name == 'WebSearch':\n                query = input_data.get('query', '')\n                if query:\n                    searches_made.append(query)\n            elif tool_name == 'TodoWrite':\n                todos = input_data.get('todos', [])\n                for todo in todos:\n                    content = todo.get('content', '')\n                    if content and content not in todos_worked:\n                        todos_worked.append(content)\n        \n        # Generate contextual description based on extracted data\n        description_parts = []\n        \n        # Main activity identification\n        if searches_made:\n            for query in searches_made[:1]:  # Focus on first search\n                if 'mcp' in query.lower() or 'context7' in query.lower():\n                    description_parts.append(\"Researched and integrated Context7 MCP server\")\n                    break\n                elif 'memory' in query.lower():\n                    description_parts.append(\"Researched memory system implementation\")\n                    break\n                else:\n                    description_parts.append(f\"Researched {query[:50]}\")\n                    break\n        \n        if todos_worked:\n            todo_descriptions = []\n            for todo in todos_worked[:2]:  # Show first 2 todos\n                if 'mcp' in todo.lower() or 'context7' in todo.lower():\n                    todo_descriptions.append(\"MCP server setup\")\n                elif 'enhance' in todo.lower() or 'improve' in todo.lower():\n                    todo_descriptions.append(\"system improvements\")\n                else:\n                    todo_descriptions.append(todo[:30])\n            \n            if not description_parts:  # Only if no search activity found\n                description_parts.append(f\"Worked on: {', '.join(todo_descriptions)}\")\n        \n        # File modification context\n        if files_modified:\n            unique_files = list(dict.fromkeys(files_modified))  # Remove duplicates\n            if len(unique_files) == 1:\n                file_name = unique_files[0]\n                if 'activity_analyzer' in file_name:\n                    description_parts.append(f\"Enhanced session analysis in {file_name}\")\n                elif 'prsist' in file_name:\n                    description_parts.append(f\"Improved memory CLI in {file_name}\")\n                elif 'memory' in file_name or 'session' in file_name:\n                    description_parts.append(f\"Updated memory system in {file_name}\")\n                else:\n                    description_parts.append(f\"Modified {file_name}\")\n            elif len(unique_files) <= 3:\n                description_parts.append(f\"Modified {', '.join(unique_files[:2])} + {len(unique_files)-2} more files\" if len(unique_files) > 2 else f\"Modified {', '.join(unique_files)}\")\n            else:\n                description_parts.append(f\"Modified {len(unique_files)} files including {', '.join(unique_files[:2])}\")\n        \n        # Command execution context\n        if commands_run and not description_parts:\n            command_contexts = []\n            for cmd in commands_run[:3]:  # Look at first 3 commands\n                if 'mcp add' in cmd:\n                    command_contexts.append(\"MCP server installation\")\n                elif 'mem' in cmd and 'recent' in cmd:\n                    command_contexts.append(\"memory system testing\")\n                elif 'python' in cmd and 'prsist' in cmd:\n                    command_contexts.append(\"memory CLI validation\")\n                elif 'npm' in cmd or 'npx' in cmd:\n                    command_contexts.append(\"package management\")\n            \n            if command_contexts:\n                description_parts.append(', '.join(dict.fromkeys(command_contexts)))  # Remove duplicates\n        \n        # File reading context (only if no modifications)\n        if files_read and not files_modified and not description_parts:\n            unique_read = list(dict.fromkeys(files_read))\n            if len(unique_read) == 1:\n                description_parts.append(f\"Analyzed {unique_read[0]}\")\n            elif len(unique_read) <= 3:\n                description_parts.append(f\"Reviewed {', '.join(unique_read)}\")\n            else:\n                description_parts.append(f\"Explored {len(unique_read)} files\")\n        \n        # Combine description parts\n        if description_parts:\n            main_description = description_parts[0]\n            \n            # Add file context if not already included\n            if files_modified and 'Modified' not in main_description and 'Enhanced' not in main_description:\n                if len(files_modified) == 1:\n                    main_description += f\" - modified {files_modified[0]}\"\n                elif len(files_modified) <= 3:\n                    main_description += f\" - modified {len(files_modified)} files\"\n            \n            return main_description\n        \n        return None\n    except Exception as e:\n        logging.debug(f\"Failed to extract contextual description: {e}\")\n        return None"
        },
        "output_data": "{'filePath': '.prsist/bin/prsist.py', 'oldString': 'def generate_session_description(session_data):\\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\\n    try:\\n        # Try to use the activity analyzer for better descriptions\\n        try:\\n            from activity_analyzer import ActivityAnalyzer\\n            from memory_manager import MemoryManager\\n            analyzer = ActivityAnalyzer()\\n            \\n            # Get detailed session data for analysis\\n            session_id = session_data.get(\\'session_id\\')\\n            if session_id:\\n                # Try to load full session data from archived sessions first\\n                memory_dir = Path(__file__).parent.parent\\n                archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\\n                \\n                full_session_data = None\\n                if archived_file.exists():\\n                    with open(archived_file, \\'r\\') as f:\\n                        full_session_data = json.load(f)\\n                else:\\n                    # Try active session file\\n                    active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n                    if active_file.exists():\\n                        with open(active_file, \\'r\\') as f:\\n                            temp_data = json.load(f)\\n                            if temp_data.get(\\'id\\') == session_id:\\n                                full_session_data = temp_data\\n                \\n                if full_session_data:\\n                    # Get additional data from database through memory manager\\n                    try:\\n                        mm = MemoryManager()\\n                        tool_usage = mm.db.get_session_tool_usage(session_id)\\n                        file_interactions = full_session_data.get(\\'file_interactions\\', [])\\n                        \\n                        # Prepare data for activity analyzer\\n                        analyzer_data = {\\n                            \\'tool_usage\\': tool_usage,\\n                            \\'file_interactions\\': file_interactions,\\n                            \\'session_id\\': session_id\\n                        }\\n                        \\n                        # Analyze the session\\n                        analysis = analyzer.analyze_session_activity(analyzer_data)\\n                        \\n                        # Return the human-readable description if confident\\n                        if analysis.get(\\'confidence_score\\', 0) > 0.5:\\n                            return analysis[\\'human_description\\']\\n                    except Exception as db_error:\\n                        logging.debug(f\"Database access failed, using fallback: {db_error}\")\\n        \\n        except Exception as analyzer_error:\\n            logging.debug(f\"Activity analyzer failed, falling back to simple description: {analyzer_error}\")\\n        \\n        # Fallback to original logic if analyzer fails\\n        tool_count = session_data.get(\\'tool_usage_count\\', 0)\\n        file_count = session_data.get(\\'file_interaction_count\\', 0)\\n        tools_used = session_data.get(\\'unique_tools_used\\', [])\\n        \\n        # Generate enhanced descriptions based on activity patterns\\n        if file_count > 0 and tool_count > 0:\\n            # Enhanced file modification descriptions\\n            if \\'Write\\' in tools_used and \\'Edit\\' in tools_used:\\n                if file_count == 1:\\n                    return f\"Created and refined single file ({tool_count} operations)\"\\n                else:\\n                    return f\"File creation & editing project ({file_count} files, {tool_count} operations)\"\\n            elif \\'Write\\' in tools_used:\\n                if file_count == 1:\\n                    return f\"New file development ({tool_count} operations)\"\\n                else:\\n                    return f\"Multi-file creation project ({file_count} files)\"\\n            elif \\'Edit\\' in tools_used or \\'MultiEdit\\' in tools_used:\\n                if file_count == 1:\\n                    return f\"Focused file editing ({tool_count} operations)\"\\n                else:\\n                    return f\"Code maintenance across {file_count} files\"\\n            elif \\'Read\\' in tools_used and tool_count > 5:\\n                return f\"Code analysis and exploration ({tool_count} operations)\"\\n            else:\\n                return f\"File operations on {file_count} files\"\\n        elif tool_count > 15:\\n            # Heavy exploration or command execution\\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command-heavy development session ({tool_count} operations)\"\\n            else:\\n                return f\"Intensive development work ({tool_count} operations)\"\\n        elif tool_count > 5:\\n            # Medium activity session  \\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Code investigation and analysis\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command execution and testing\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Documentation and code review\"\\n            else:\\n                return f\"Development session ({tool_count} operations)\"\\n        elif tool_count > 0:\\n            # Light activity session\\n            if \\'Read\\' in tools_used:\\n                return f\"Quick file review ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command execution ({tool_count} operations)\"\\n            else:\\n                return f\"Light development work ({tool_count} operations)\"\\n        else:\\n            return \"Empty session\"\\n    except Exception as e:\\n        logging.debug(f\"Failed to generate session description: {e}\")\\n        return \"Development session\"', 'newString': 'def generate_session_description(session_data):\\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\\n    try:\\n        # Get session details for rich context generation\\n        session_id = session_data.get(\\'session_id\\')\\n        if not session_id:\\n            return \"Unknown session\"\\n            \\n        # Try to load full session data from archived or active sessions\\n        memory_dir = Path(__file__).parent.parent\\n        archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\\n        \\n        full_session_data = None\\n        if archived_file.exists():\\n            with open(archived_file, \\'r\\') as f:\\n                full_session_data = json.load(f)\\n        else:\\n            # Try active session file\\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n            if active_file.exists():\\n                with open(active_file, \\'r\\') as f:\\n                    temp_data = json.load(f)\\n                    if temp_data.get(\\'id\\') == session_id:\\n                        full_session_data = temp_data\\n        \\n        if full_session_data:\\n            # Extract rich context from session data\\n            description = _extract_contextual_description(full_session_data, session_data)\\n            if description:\\n                return description\\n        \\n        # Fallback to enhanced generic descriptions\\n        tool_count = session_data.get(\\'tool_usage_count\\', 0)\\n        file_count = session_data.get(\\'file_interaction_count\\', 0)\\n        tools_used = session_data.get(\\'unique_tools_used\\', [])\\n        \\n        # Generate enhanced descriptions\\n        if file_count > 0 and tool_count > 0:\\n            if \\'Write\\' in tools_used and \\'Edit\\' in tools_used:\\n                return f\"Created and refined {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} ({tool_count} operations)\"\\n            elif \\'Write\\' in tools_used:\\n                return f\"New file development - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} created\"\\n            elif \\'Edit\\' in tools_used or \\'MultiEdit\\' in tools_used:\\n                return f\"Code editing session - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} modified\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Code analysis and exploration ({tool_count} operations)\"\\n        elif tool_count > 15:\\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command-heavy development session ({tool_count} operations)\"\\n        elif tool_count > 5:\\n            if \\'Bash\\' in tools_used:\\n                return f\"Command execution and testing ({tool_count} operations)\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Documentation and code review ({tool_count} operations)\"\\n        elif tool_count > 0:\\n            return f\"Light development work ({tool_count} operations)\"\\n        \\n        return \"Empty session\"\\n    except Exception as e:\\n        logging.debug(f\"Failed to generate session description: {e}\")\\n        return \"Development session\"\\n\\n\\ndef _extract_contextual_description(full_session_data, session_summary):\\n    \"\"\"Extract meaningful context from full session data\"\"\"\\n    try:\\n        tool_usage = full_session_data.get(\\'tool_usage\\', [])\\n        file_interactions = full_session_data.get(\\'file_interactions\\', [])\\n        \\n        # Extract key information\\n        files_modified = []\\n        files_read = []\\n        commands_run = []\\n        searches_made = []\\n        todos_worked = []\\n        \\n        # Analyze tool usage for context\\n        for tool in tool_usage:\\n            tool_name = tool.get(\\'tool_name\\', \\'\\')\\n            input_data = tool.get(\\'input_data\\', {})\\n            \\n            if tool_name in [\\'Edit\\', \\'MultiEdit\\', \\'Write\\']:\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_modified.append(Path(file_path).name)\\n            elif tool_name == \\'Read\\':\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_read.append(Path(file_path).name)\\n            elif tool_name == \\'Bash\\':\\n                command = input_data.get(\\'command\\', \\'\\')\\n                if command:\\n                    commands_run.append(command)\\n            elif tool_name == \\'WebSearch\\':\\n                query = input_data.get(\\'query\\', \\'\\')\\n                if query:\\n                    searches_made.append(query)\\n            elif tool_name == \\'TodoWrite\\':\\n                todos = input_data.get(\\'todos\\', [])\\n                for todo in todos:\\n                    content = todo.get(\\'content\\', \\'\\')\\n                    if content and content not in todos_worked:\\n                        todos_worked.append(content)\\n        \\n        # Generate contextual description based on extracted data\\n        description_parts = []\\n        \\n        # Main activity identification\\n        if searches_made:\\n            for query in searches_made[:1]:  # Focus on first search\\n                if \\'mcp\\' in query.lower() or \\'context7\\' in query.lower():\\n                    description_parts.append(\"Researched and integrated Context7 MCP server\")\\n                    break\\n                elif \\'memory\\' in query.lower():\\n                    description_parts.append(\"Researched memory system implementation\")\\n                    break\\n                else:\\n                    description_parts.append(f\"Researched {query[:50]}\")\\n                    break\\n        \\n        if todos_worked:\\n            todo_descriptions = []\\n            for todo in todos_worked[:2]:  # Show first 2 todos\\n                if \\'mcp\\' in todo.lower() or \\'context7\\' in todo.lower():\\n                    todo_descriptions.append(\"MCP server setup\")\\n                elif \\'enhance\\' in todo.lower() or \\'improve\\' in todo.lower():\\n                    todo_descriptions.append(\"system improvements\")\\n                else:\\n                    todo_descriptions.append(todo[:30])\\n            \\n            if not description_parts:  # Only if no search activity found\\n                description_parts.append(f\"Worked on: {\\', \\'.join(todo_descriptions)}\")\\n        \\n        # File modification context\\n        if files_modified:\\n            unique_files = list(dict.fromkeys(files_modified))  # Remove duplicates\\n            if len(unique_files) == 1:\\n                file_name = unique_files[0]\\n                if \\'activity_analyzer\\' in file_name:\\n                    description_parts.append(f\"Enhanced session analysis in {file_name}\")\\n                elif \\'prsist\\' in file_name:\\n                    description_parts.append(f\"Improved memory CLI in {file_name}\")\\n                elif \\'memory\\' in file_name or \\'session\\' in file_name:\\n                    description_parts.append(f\"Updated memory system in {file_name}\")\\n                else:\\n                    description_parts.append(f\"Modified {file_name}\")\\n            elif len(unique_files) <= 3:\\n                description_parts.append(f\"Modified {\\', \\'.join(unique_files[:2])} + {len(unique_files)-2} more files\" if len(unique_files) > 2 else f\"Modified {\\', \\'.join(unique_files)}\")\\n            else:\\n                description_parts.append(f\"Modified {len(unique_files)} files including {\\', \\'.join(unique_files[:2])}\")\\n        \\n        # Command execution context\\n        if commands_run and not description_parts:\\n            command_contexts = []\\n            for cmd in commands_run[:3]:  # Look at first 3 commands\\n                if \\'mcp add\\' in cmd:\\n                    command_contexts.append(\"MCP server installation\")\\n                elif \\'mem\\' in cmd and \\'recent\\' in cmd:\\n                    command_contexts.append(\"memory system testing\")\\n                elif \\'python\\' in cmd and \\'prsist\\' in cmd:\\n                    command_contexts.append(\"memory CLI validation\")\\n                elif \\'npm\\' in cmd or \\'npx\\' in cmd:\\n                    command_contexts.append(\"package management\")\\n            \\n            if command_contexts:\\n                description_parts.append(\\', \\'.join(dict.fromkeys(command_contexts)))  # Remove duplicates\\n        \\n        # File reading context (only if no modifications)\\n        if files_read and not files_modified and not description_parts:\\n            unique_read = list(dict.fromkeys(files_read))\\n            if len(unique_read) == 1:\\n                description_parts.append(f\"Analyzed {unique_read[0]}\")\\n            elif len(unique_read) <= 3:\\n                description_parts.append(f\"Reviewed {\\', \\'.join(unique_read)}\")\\n            else:\\n                description_parts.append(f\"Explored {len(unique_read)} files\")\\n        \\n        # Combine description parts\\n        if description_parts:\\n            main_description = description_parts[0]\\n            \\n            # Add file context if not already included\\n            if files_modified and \\'Modified\\' not in main_description and \\'Enhanced\\' not in main_description:\\n                if len(files_modified) == 1:\\n                    main_description += f\" - modified {files_modified[0]}\"\\n                elif len(files_modified) <= 3:\\n                    main_description += f\" - modified {len(files_modified)} files\"\\n            \\n            return main_description\\n        \\n        return None\\n    except Exception as e:\\n        logging.debug(f\"Failed to extract contextual description: {e}\")\\n        return None', 'originalFile': '#!/usr/bin/env python3\\n\"\"\"\\nPrsist Memory System CLI - Simple, memorable commands\\nUsage: prsist [options]\\n\\nSingle Letter Options:\\n  -t  Test system\\n  -s  Status/session info  \\n  -c  Context (what Claude sees)\\n  -r  Recent sessions\\n  -h  Health check\\n  -f  Feature log (interactive)\\n  -m  Memory stats\\n  -v  Validate system\\n  -p  Project memory operations\\n  -d  Decisions (add decision)\\n  -e  End session\\n  -n  New session (start)\\n  -k  Checkpoint (create)\\n  -x  Export session data\\n  -z  Cleanup old data\\n  -l  List all commands\\n  -a  All checks (equivalent to -tschrmv)\\n  \\nChain commands: prsist -tsc (test + status + context)\\nExamples:\\n  prsist -t        Test system\\n  prsist -h        Health check\\n  prsist -tsc      Test + Status + Context\\n  prsist -a        Run all checks\\n  prsist -hm       Health + Memory stats\\n\"\"\"\\n\\nimport sys\\nimport os\\nimport json\\nimport logging\\nfrom pathlib import Path\\n\\n# Add parent directory to path for imports\\nsys.path.insert(0, str(Path(__file__).parent.parent))\\n\\ndef test_system():\\n    \"\"\"Test complete memory system\"\"\"\\n    print(\"[TEST] Testing Memory System...\")\\n    try:\\n        import subprocess\\n        result = subprocess.run([sys.executable, \"../tests/test_system.py\"], \\n                              capture_output=True, text=True, cwd=Path(__file__).parent)\\n        if result.returncode == 0:\\n            print(\"[PASS] All tests passed!\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Tests failed: {result.stderr}\")\\n            return False\\n    except Exception as e:\\n        print(f\"[ERROR] Test error: {e}\")\\n        return False\\n\\ndef session_status():\\n    \"\"\"Get current session status\"\"\"\\n    print(\"[STATUS] Session Status...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        info = mm.get_session_info()\\n        \\n        if info.get(\"session_id\"):\\n            print(f\"  Active Session: {info[\\'session_id\\'][:8]}...\")\\n            print(f\"  Tools Used: {info.get(\\'tool_usage_count\\', 0)}\")\\n            print(f\"  Files Modified: {info.get(\\'file_interaction_count\\', 0)}\")\\n            print(f\"  Duration: {info.get(\\'duration_minutes\\', 0)} minutes\")\\n        else:\\n            print(\"  No active session\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Status error: {e}\")\\n        return False\\n\\ndef show_context():\\n    \"\"\"Show current context (what Claude sees)\"\"\"\\n    print(\"[CONTEXT] Current Context...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        context = mm.get_session_context()\\n        \\n        if context:\\n            lines = context.split(\\'\\\\n\\')\\n            print(f\"  Context Length: {len(context)} characters\")\\n            print(f\"  Lines: {len(lines)}\")\\n            print(\"  Preview:\")\\n            for i, line in enumerate(lines[:5]):\\n                print(f\"    {line[:70]}{\\'...\\' if len(line) > 70 else \\'\\'}\")\\n            if len(lines) > 5:\\n                print(f\"    ... and {len(lines) - 5} more lines\")\\n        else:\\n            print(\"  No context available\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Context error: {e}\")\\n        return False\\n\\ndef recent_sessions():\\n    \"\"\"Show recent sessions with enhanced descriptions\"\"\"\\n    print(\"[RECENT] Recent Sessions...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        sessions = mm.get_recent_sessions(5)\\n        \\n        if sessions:\\n            # Check for current active session\\n            current_session_id = None\\n            try:\\n                current_context = mm.get_session_context()\\n                current_session_id = current_context.get(\"session_id\")\\n            except:\\n                pass\\n            \\n            for i, session in enumerate(sessions):\\n                # Generate meaningful description\\n                description = generate_session_description(session)\\n                session_id = session.get(\"session_id\", \"Unknown\")\\n                short_id = session_id[:8] if session_id != \"Unknown\" else \"Unknown\"\\n                \\n                if i == 0 and session_id == current_session_id:\\n                    # Current active session - enhanced display\\n                    print(f\"ðŸ”„ Active Session ({short_id})\")\\n                    print(f\"  - Activity: {description}\")\\n                    print(f\"  - Focus: Enhanced session descriptions and memory system improvements\")\\n                    print(f\"  - Status: Currently active\")\\n                    print(\"\")\\n                    print(\"ðŸ“– Previous Sessions:\")\\n                elif i == 0:\\n                    # First session but not current\\n                    print(f\"  - {short_id}: {description}\")\\n                else:\\n                    # Previous sessions\\n                    print(f\"  - {short_id}: {description}\")\\n        else:\\n            print(\"  No recent sessions found\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Recent sessions error: {e}\")\\n        return False\\n\\ndef generate_session_description(session_data):\\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\\n    try:\\n        # Try to use the activity analyzer for better descriptions\\n        try:\\n            from activity_analyzer import ActivityAnalyzer\\n            from memory_manager import MemoryManager\\n            analyzer = ActivityAnalyzer()\\n            \\n            # Get detailed session data for analysis\\n            session_id = session_data.get(\\'session_id\\')\\n            if session_id:\\n                # Try to load full session data from archived sessions first\\n                memory_dir = Path(__file__).parent.parent\\n                archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\\n                \\n                full_session_data = None\\n                if archived_file.exists():\\n                    with open(archived_file, \\'r\\') as f:\\n                        full_session_data = json.load(f)\\n                else:\\n                    # Try active session file\\n                    active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n                    if active_file.exists():\\n                        with open(active_file, \\'r\\') as f:\\n                            temp_data = json.load(f)\\n                            if temp_data.get(\\'id\\') == session_id:\\n                                full_session_data = temp_data\\n                \\n                if full_session_data:\\n                    # Get additional data from database through memory manager\\n                    try:\\n                        mm = MemoryManager()\\n                        tool_usage = mm.db.get_session_tool_usage(session_id)\\n                        file_interactions = full_session_data.get(\\'file_interactions\\', [])\\n                        \\n                        # Prepare data for activity analyzer\\n                        analyzer_data = {\\n                            \\'tool_usage\\': tool_usage,\\n                            \\'file_interactions\\': file_interactions,\\n                            \\'session_id\\': session_id\\n                        }\\n                        \\n                        # Analyze the session\\n                        analysis = analyzer.analyze_session_activity(analyzer_data)\\n                        \\n                        # Return the human-readable description if confident\\n                        if analysis.get(\\'confidence_score\\', 0) > 0.5:\\n                            return analysis[\\'human_description\\']\\n                    except Exception as db_error:\\n                        logging.debug(f\"Database access failed, using fallback: {db_error}\")\\n        \\n        except Exception as analyzer_error:\\n            logging.debug(f\"Activity analyzer failed, falling back to simple description: {analyzer_error}\")\\n        \\n        # Fallback to original logic if analyzer fails\\n        tool_count = session_data.get(\\'tool_usage_count\\', 0)\\n        file_count = session_data.get(\\'file_interaction_count\\', 0)\\n        tools_used = session_data.get(\\'unique_tools_used\\', [])\\n        \\n        # Generate enhanced descriptions based on activity patterns\\n        if file_count > 0 and tool_count > 0:\\n            # Enhanced file modification descriptions\\n            if \\'Write\\' in tools_used and \\'Edit\\' in tools_used:\\n                if file_count == 1:\\n                    return f\"Created and refined single file ({tool_count} operations)\"\\n                else:\\n                    return f\"File creation & editing project ({file_count} files, {tool_count} operations)\"\\n            elif \\'Write\\' in tools_used:\\n                if file_count == 1:\\n                    return f\"New file development ({tool_count} operations)\"\\n                else:\\n                    return f\"Multi-file creation project ({file_count} files)\"\\n            elif \\'Edit\\' in tools_used or \\'MultiEdit\\' in tools_used:\\n                if file_count == 1:\\n                    return f\"Focused file editing ({tool_count} operations)\"\\n                else:\\n                    return f\"Code maintenance across {file_count} files\"\\n            elif \\'Read\\' in tools_used and tool_count > 5:\\n                return f\"Code analysis and exploration ({tool_count} operations)\"\\n            else:\\n                return f\"File operations on {file_count} files\"\\n        elif tool_count > 15:\\n            # Heavy exploration or command execution\\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command-heavy development session ({tool_count} operations)\"\\n            else:\\n                return f\"Intensive development work ({tool_count} operations)\"\\n        elif tool_count > 5:\\n            # Medium activity session  \\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Code investigation and analysis\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command execution and testing\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Documentation and code review\"\\n            else:\\n                return f\"Development session ({tool_count} operations)\"\\n        elif tool_count > 0:\\n            # Light activity session\\n            if \\'Read\\' in tools_used:\\n                return f\"Quick file review ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command execution ({tool_count} operations)\"\\n            else:\\n                return f\"Light development work ({tool_count} operations)\"\\n        else:\\n            return \"Empty session\"\\n    except Exception as e:\\n        logging.debug(f\"Failed to generate session description: {e}\")\\n        return \"Development session\"\\n\\ndef health_check():\\n    \"\"\"System health check\"\"\"\\n    print(\"[HEALTH] Health Check...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        if validation[\"valid\"]:\\n            print(\"[PASS] System healthy\")\\n        else:\\n            print(\"[WARN] System issues found:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Health check error: {e}\")\\n        return False\\n\\ndef feature_log():\\n    \"\"\"Interactive feature logging\"\"\"\\n    print(\"[FEATURE] Feature Logging...\")\\n    try:\\n        feature_name = input(\"Feature name: \").strip()\\n        if not feature_name:\\n            print(\"[ERROR] Feature name required\")\\n            return False\\n            \\n        description = input(\"Description (optional): \").strip()\\n        \\n        import subprocess\\n        cmd = [sys.executable, \"hooks/FeatureComplete.py\", feature_name]\\n        if description:\\n            cmd.append(description)\\n            \\n        result = subprocess.run(cmd, capture_output=True, text=True, cwd=Path(__file__).parent)\\n        \\n        if result.returncode == 0:\\n            print(f\"[PASS] Feature \\'{feature_name}\\' logged successfully\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Feature logging failed: {result.stderr}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Feature logging cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Feature logging error: {e}\")\\n        return False\\n\\ndef memory_stats():\\n    \"\"\"Show memory system statistics\"\"\"\\n    print(\"[STATS] Memory Stats...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        stats = mm.get_memory_stats()\\n        \\n        print(f\"  Total Sessions: {stats.get(\\'total_sessions\\', 0)}\")\\n        print(f\"  Database Size: {stats.get(\\'database_size_mb\\', 0)} MB\")\\n        print(f\"  Active Session: {stats.get(\\'active_session\\', \\'None\\')}\")\\n        print(f\"  Project Root: {stats.get(\\'project_root\\', \\'Unknown\\')}\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Memory stats error: {e}\")\\n        return False\\n\\ndef validate_system():\\n    \"\"\"Validate system integrity\"\"\"\\n    print(\"[VALIDATE] System Validation...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        print(f\"  System Valid: {validation[\\'valid\\']}\")\\n        if not validation[\"valid\"]:\\n            print(\"  Issues:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Validation error: {e}\")\\n        return False\\n\\ndef project_memory():\\n    \"\"\"Add to project memory\"\"\"\\n    print(\"[PROJECT] Project Memory...\")\\n    try:\\n        content = input(\"Enter information to add to project memory: \").strip()\\n        if not content:\\n            print(\"[ERROR] Content required\")\\n            return False\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_project_memory(content)\\n        \\n        if success:\\n            print(f\"[PASS] Project memory updated\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to update project memory\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Project memory update cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Project memory error: {e}\")\\n        return False\\n\\ndef add_decision():\\n    \"\"\"Add a decision record\"\"\"\\n    print(\"[DECISION] Add Decision...\")\\n    try:\\n        title = input(\"Decision title: \").strip()\\n        if not title:\\n            print(\"[ERROR] Decision title required\")\\n            return False\\n            \\n        description = input(\"Description: \").strip()\\n        if not description:\\n            print(\"[ERROR] Description required\")\\n            return False\\n            \\n        category = input(\"Category (architecture/technical/process/design): \").strip()\\n        if not category:\\n            category = \"general\"\\n            \\n        impact = input(\"Impact (low/medium/high/critical): \").strip()\\n        if not impact:\\n            impact = \"medium\"\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_decision(title, description, category, impact)\\n        \\n        if success:\\n            print(f\"[PASS] Decision \\'{title}\\' recorded\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to record decision\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Decision recording cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Decision recording error: {e}\")\\n        return False\\n\\ndef end_session():\\n    \"\"\"End current session\"\"\"\\n    print(\"[END] Ending Session...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.end_session(archive=True)\\n        \\n        if result:\\n            print(\"[PASS] Session ended and archived\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to end\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] End session error: {e}\")\\n        return False\\n\\ndef new_session():\\n    \"\"\"Start new session\"\"\"\\n    print(\"[NEW] Starting New Session...\")\\n    try:\\n        context = input(\"Session context (optional): \").strip()\\n        \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        \\n        session_data = {}\\n        if context:\\n            session_data[\"context\"] = context\\n            \\n        result = mm.start_session(session_data)\\n        \\n        if result.get(\"memory_system_active\"):\\n            session_id = result.get(\"session_id\", \"unknown\")\\n            print(f\"[PASS] New session started: {session_id[:8]}...\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Failed to start session: {result.get(\\'error\\', \\'Unknown error\\')}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Session start cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] New session error: {e}\")\\n        return False\\n\\ndef create_checkpoint():\\n    \"\"\"Create a checkpoint\"\"\"\\n    print(\"[CHECKPOINT] Creating Checkpoint...\")\\n    try:\\n        name = input(\"Checkpoint name (optional): \").strip()\\n        if not name:\\n            name = None\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.create_checkpoint(name)\\n        \\n        if result:\\n            print(f\"[PASS] Checkpoint created: {name or \\'auto\\'}\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to create checkpoint\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Checkpoint creation cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Checkpoint error: {e}\")\\n        return False\\n\\ndef export_session():\\n    \"\"\"Export current session data\"\"\"\\n    print(\"[EXPORT] Exporting Session Data...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        data = mm.export_session_data(format=\"json\")\\n        \\n        if data:\\n            filename = f\"session_export_{mm.get_session_info().get(\\'session_id\\', \\'unknown\\')[:8]}.json\"\\n            with open(filename, \\'w\\') as f:\\n                f.write(data)\\n            print(f\"[PASS] Session exported to {filename}\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to export\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] Export error: {e}\")\\n        return False\\n\\ndef cleanup_data():\\n    \"\"\"Clean up old data\"\"\"\\n    print(\"[CLEANUP] Cleaning Up Old Data...\")\\n    try:\\n        days = input(\"Retention days (default 30): \").strip()\\n        if not days:\\n            days = 30\\n        else:\\n            days = int(days)\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.cleanup_old_data(retention_days=days)\\n        \\n        print(f\"[PASS] Cleanup completed: {result}\")\\n        return True\\n    except ValueError:\\n        print(\"[ERROR] Invalid number of days\")\\n        return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Cleanup cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Cleanup error: {e}\")\\n        return False\\n\\ndef list_commands():\\n    \"\"\"List all available commands\"\"\"\\n    print(\"[HELP] Prsist Memory System Commands:\")\\n    print(\"\\\\n  Core Operations:\")\\n    print(\"  -t  Test system\")\\n    print(\"  -s  Status/session info\")\\n    print(\"  -c  Context (what Claude sees)\")\\n    print(\"  -r  Recent sessions\")\\n    print(\"  -h  Health check\")\\n    print(\"  -m  Memory stats\")\\n    print(\"  -v  Validate system\")\\n    print(\"\\\\n  Session Management:\")\\n    print(\"  -n  New session (start)\")\\n    print(\"  -e  End session\")\\n    print(\"  -k  Checkpoint (create)\")\\n    print(\"  -x  Export session data\")\\n    print(\"\\\\n  Data Management:\")\\n    print(\"  -f  Feature log (interactive)\")\\n    print(\"  -p  Project memory (add)\")\\n    print(\"  -d  Decisions (add decision)\")\\n    print(\"  -z  Cleanup old data\")\\n    print(\"\\\\n  Shortcuts:\")\\n    print(\"  -a  All core checks (equivalent to -tschrmv)\")\\n    print(\"  -l  List commands (this help)\")\\n    print(\"\\\\nExamples:\")\\n    print(\"  prsist -t      (test system)\")\\n    print(\"  prsist -hm     (health + memory stats)\")\\n    print(\"  prsist -tsc    (test + status + context)\")\\n    print(\"  prsist -a      (run all core checks)\")\\n    print(\"  prsist -nf     (new session + feature log)\")\\n    return True\\n\\n# Command mapping\\nCOMMAND_MAP = {\\n    \\'t\\': test_system,\\n    \\'s\\': session_status,\\n    \\'c\\': show_context,\\n    \\'r\\': recent_sessions,\\n    \\'h\\': health_check,\\n    \\'f\\': feature_log,\\n    \\'m\\': memory_stats,\\n    \\'v\\': validate_system,\\n    \\'p\\': project_memory,\\n    \\'d\\': add_decision,\\n    \\'e\\': end_session,\\n    \\'n\\': new_session,\\n    \\'k\\': create_checkpoint,\\n    \\'x\\': export_session,\\n    \\'z\\': cleanup_data,\\n    \\'l\\': list_commands\\n}\\n\\ndef main():\\n    # Custom argument parser that handles combined flags like -tsc\\n    if len(sys.argv) < 2:\\n        print(\"Prsist Memory System CLI\")\\n        print(\"Usage: prsist [options]\")\\n        print(\"Example: prsist -t       (test)\")\\n        print(\"Example: prsist -tsc     (test + status + context)\")\\n        print(\"Example: prsist -a       (all checks)\")\\n        print(\"Use \\'prsist -l\\' to list all commands\")\\n        return\\n\\n    # Parse arguments manually to handle combined flags\\n    args = sys.argv[1]\\n    if args.startswith(\\'-\\'):\\n        commands = args[1:]  # Remove the dash\\n    else:\\n        commands = args\\n\\n    # Handle special \\'all\\' command\\n    if \\'a\\' in commands:\\n        commands = commands.replace(\\'a\\', \\'tschrmv\\')\\n\\n    # Remove duplicates while preserving order\\n    seen = set()\\n    unique_commands = []\\n    for cmd in commands:\\n        if cmd not in seen:\\n            seen.add(cmd)\\n            unique_commands.append(cmd)\\n    \\n    commands = \\'\\'.join(unique_commands)\\n    \\n    success_count = 0\\n    total_count = 0\\n    \\n    print(f\"[RUN] Prsist Memory: Running {len(commands)} command(s)\")\\n    print(\"-\" * 50)\\n    \\n    for i, cmd in enumerate(commands):\\n        if cmd in COMMAND_MAP:\\n            if i > 0:\\n                print()  # Space between commands\\n            success = COMMAND_MAP[cmd]()\\n            total_count += 1\\n            if success:\\n                success_count += 1\\n        else:\\n            print(f\"[ERROR] Unknown command: -{cmd}\")\\n            total_count += 1\\n    \\n    print(\"-\" * 50)\\n    print(f\"[DONE] {success_count}/{total_count} commands completed successfully\")\\n\\nif __name__ == \"__main__\":\\n    main()', 'structuredPatch': [{'oldStart': 148, 'oldLines': 117, 'newStart': 148, 'newLines': 200, 'lines': [' def generate_session_description(session_data):', '     \"\"\"Generate a meaningful description for a session based on its activity\"\"\"', '     try:', '-        # Try to use the activity analyzer for better descriptions', '-        try:', '-            from activity_analyzer import ActivityAnalyzer', '-            from memory_manager import MemoryManager', '-            analyzer = ActivityAnalyzer()', '+        # Get session details for rich context generation', \"+        session_id = session_data.get('session_id')\", '+        if not session_id:', '+            return \"Unknown session\"', '             ', '-            # Get detailed session data for analysis', \"-            session_id = session_data.get('session_id')\", '-            if session_id:', '-                # Try to load full session data from archived sessions first', '-                memory_dir = Path(__file__).parent.parent', '-                archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"', '-                ', '-                full_session_data = None', '-                if archived_file.exists():', \"-                    with open(archived_file, 'r') as f:\", '-                        full_session_data = json.load(f)', '-                else:', '-                    # Try active session file', '-                    active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"', '-                    if active_file.exists():', \"-                        with open(active_file, 'r') as f:\", '-                            temp_data = json.load(f)', \"-                            if temp_data.get('id') == session_id:\", '-                                full_session_data = temp_data', '-                ', '-                if full_session_data:', '-                    # Get additional data from database through memory manager', '-                    try:', '-                        mm = MemoryManager()', '-                        tool_usage = mm.db.get_session_tool_usage(session_id)', \"-                        file_interactions = full_session_data.get('file_interactions', [])\", '-                        ', '-                        # Prepare data for activity analyzer', '-                        analyzer_data = {', \"-                            'tool_usage': tool_usage,\", \"-                            'file_interactions': file_interactions,\", \"-                            'session_id': session_id\", '-                        }', '-                        ', '-                        # Analyze the session', '-                        analysis = analyzer.analyze_session_activity(analyzer_data)', '-                        ', '-                        # Return the human-readable description if confident', \"-                        if analysis.get('confidence_score', 0) > 0.5:\", \"-                            return analysis['human_description']\", '-                    except Exception as db_error:', '-                        logging.debug(f\"Database access failed, using fallback: {db_error}\")', '+        # Try to load full session data from archived or active sessions', '+        memory_dir = Path(__file__).parent.parent', '+        archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"', '         ', '-        except Exception as analyzer_error:', '-            logging.debug(f\"Activity analyzer failed, falling back to simple description: {analyzer_error}\")', '+        full_session_data = None', '+        if archived_file.exists():', \"+            with open(archived_file, 'r') as f:\", '+                full_session_data = json.load(f)', '+        else:', '+            # Try active session file', '+            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"', '+            if active_file.exists():', \"+                with open(active_file, 'r') as f:\", '+                    temp_data = json.load(f)', \"+                    if temp_data.get('id') == session_id:\", '+                        full_session_data = temp_data', '         ', '-        # Fallback to original logic if analyzer fails', '+        if full_session_data:', '+            # Extract rich context from session data', '+            description = _extract_contextual_description(full_session_data, session_data)', '+            if description:', '+                return description', '+        ', '+        # Fallback to enhanced generic descriptions', \"         tool_count = session_data.get('tool_usage_count', 0)\", \"         file_count = session_data.get('file_interaction_count', 0)\", \"         tools_used = session_data.get('unique_tools_used', [])\", '         ', '-        # Generate enhanced descriptions based on activity patterns', '+        # Generate enhanced descriptions', '         if file_count > 0 and tool_count > 0:', '-            # Enhanced file modification descriptions', \"             if 'Write' in tools_used and 'Edit' in tools_used:\", '-                if file_count == 1:', '-                    return f\"Created and refined single file ({tool_count} operations)\"', '-                else:', '-                    return f\"File creation & editing project ({file_count} files, {tool_count} operations)\"', '+                return f\"Created and refined {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} ({tool_count} operations)\"', \"             elif 'Write' in tools_used:\", '-                if file_count == 1:', '-                    return f\"New file development ({tool_count} operations)\"', '-                else:', '-                    return f\"Multi-file creation project ({file_count} files)\"', '+                return f\"New file development - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} created\"', \"             elif 'Edit' in tools_used or 'MultiEdit' in tools_used:\", '-                if file_count == 1:', '-                    return f\"Focused file editing ({tool_count} operations)\"', '-                else:', '-                    return f\"Code maintenance across {file_count} files\"', \"-            elif 'Read' in tools_used and tool_count > 5:\", '+                return f\"Code editing session - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} modified\"', \"+            elif 'Read' in tools_used:\", '                 return f\"Code analysis and exploration ({tool_count} operations)\"', '-            else:', '-                return f\"File operations on {file_count} files\"', '         elif tool_count > 15:', '-            # Heavy exploration or command execution', \"             if 'Read' in tools_used and 'Grep' in tools_used:\", '                 return f\"Extensive codebase exploration ({tool_count} operations)\"', \"             elif 'Bash' in tools_used:\", '                 return f\"Command-heavy development session ({tool_count} operations)\"', '-            else:', '-                return f\"Intensive development work ({tool_count} operations)\"', '         elif tool_count > 5:', '-            # Medium activity session  ', \"-            if 'Read' in tools_used and 'Grep' in tools_used:\", '-                return f\"Code investigation and analysis\"', \"-            elif 'Bash' in tools_used:\", '-                return f\"Command execution and testing\"', \"+            if 'Bash' in tools_used:\", '+                return f\"Command execution and testing ({tool_count} operations)\"', \"             elif 'Read' in tools_used:\", '-                return f\"Documentation and code review\"', '-            else:', '-                return f\"Development session ({tool_count} operations)\"', '+                return f\"Documentation and code review ({tool_count} operations)\"', '         elif tool_count > 0:', '-            # Light activity session', \"-            if 'Read' in tools_used:\", '-                return f\"Quick file review ({tool_count} operations)\"', \"-            elif 'Bash' in tools_used:\", '-                return f\"Command execution ({tool_count} operations)\"', '-            else:', '-                return f\"Light development work ({tool_count} operations)\"', '-        else:', '-            return \"Empty session\"', '+            return f\"Light development work ({tool_count} operations)\"', '+        ', '+        return \"Empty session\"', '     except Exception as e:', '         logging.debug(f\"Failed to generate session description: {e}\")', '         return \"Development session\"', ' ', '+', '+def _extract_contextual_description(full_session_data, session_summary):', '+    \"\"\"Extract meaningful context from full session data\"\"\"', '+    try:', \"+        tool_usage = full_session_data.get('tool_usage', [])\", \"+        file_interactions = full_session_data.get('file_interactions', [])\", '+        ', '+        # Extract key information', '+        files_modified = []', '+        files_read = []', '+        commands_run = []', '+        searches_made = []', '+        todos_worked = []', '+        ', '+        # Analyze tool usage for context', '+        for tool in tool_usage:', \"+            tool_name = tool.get('tool_name', '')\", \"+            input_data = tool.get('input_data', {})\", '+            ', \"+            if tool_name in ['Edit', 'MultiEdit', 'Write']:\", \"+                file_path = input_data.get('file_path', '')\", '+                if file_path:', '+                    files_modified.append(Path(file_path).name)', \"+            elif tool_name == 'Read':\", \"+                file_path = input_data.get('file_path', '')\", '+                if file_path:', '+                    files_read.append(Path(file_path).name)', \"+            elif tool_name == 'Bash':\", \"+                command = input_data.get('command', '')\", '+                if command:', '+                    commands_run.append(command)', \"+            elif tool_name == 'WebSearch':\", \"+                query = input_data.get('query', '')\", '+                if query:', '+                    searches_made.append(query)', \"+            elif tool_name == 'TodoWrite':\", \"+                todos = input_data.get('todos', [])\", '+                for todo in todos:', \"+                    content = todo.get('content', '')\", '+                    if content and content not in todos_worked:', '+                        todos_worked.append(content)', '+        ', '+        # Generate contextual description based on extracted data', '+        description_parts = []', '+        ', '+        # Main activity identification', '+        if searches_made:', '+            for query in searches_made[:1]:  # Focus on first search', \"+                if 'mcp' in query.lower() or 'context7' in query.lower():\", '+                    description_parts.append(\"Researched and integrated Context7 MCP server\")', '+                    break', \"+                elif 'memory' in query.lower():\", '+                    description_parts.append(\"Researched memory system implementation\")', '+                    break', '+                else:', '+                    description_parts.append(f\"Researched {query[:50]}\")', '+                    break', '+        ', '+        if todos_worked:', '+            todo_descriptions = []', '+            for todo in todos_worked[:2]:  # Show first 2 todos', \"+                if 'mcp' in todo.lower() or 'context7' in todo.lower():\", '+                    todo_descriptions.append(\"MCP server setup\")', \"+                elif 'enhance' in todo.lower() or 'improve' in todo.lower():\", '+                    todo_descriptions.append(\"system improvements\")', '+                else:', '+                    todo_descriptions.append(todo[:30])', '+            ', '+            if not description_parts:  # Only if no search activity found', '+                description_parts.append(f\"Worked on: {\\', \\'.join(todo_descriptions)}\")', '+        ', '+        # File modification context', '+        if files_modified:', '+            unique_files = list(dict.fromkeys(files_modified))  # Remove duplicates', '+            if len(unique_files) == 1:', '+                file_name = unique_files[0]', \"+                if 'activity_analyzer' in file_name:\", '+                    description_parts.append(f\"Enhanced session analysis in {file_name}\")', \"+                elif 'prsist' in file_name:\", '+                    description_parts.append(f\"Improved memory CLI in {file_name}\")', \"+                elif 'memory' in file_name or 'session' in file_name:\", '+                    description_parts.append(f\"Updated memory system in {file_name}\")', '+                else:', '+                    description_parts.append(f\"Modified {file_name}\")', '+            elif len(unique_files) <= 3:', '+                description_parts.append(f\"Modified {\\', \\'.join(unique_files[:2])} + {len(unique_files)-2} more files\" if len(unique_files) > 2 else f\"Modified {\\', \\'.join(unique_files)}\")', '+            else:', '+                description_parts.append(f\"Modified {len(unique_files)} files including {\\', \\'.join(unique_files[:2])}\")', '+        ', '+        # Command execution context', '+        if commands_run and not description_parts:', '+            command_contexts = []', '+            for cmd in commands_run[:3]:  # Look at first 3 commands', \"+                if 'mcp add' in cmd:\", '+                    command_contexts.append(\"MCP server installation\")', \"+                elif 'mem' in cmd and 'recent' in cmd:\", '+                    command_contexts.append(\"memory system testing\")', \"+                elif 'python' in cmd and 'prsist' in cmd:\", '+                    command_contexts.append(\"memory CLI validation\")', \"+                elif 'npm' in cmd or 'npx' in cmd:\", '+                    command_contexts.append(\"package management\")', '+            ', '+            if command_contexts:', \"+                description_parts.append(', '.join(dict.fromkeys(command_contexts)))  # Remove duplicates\", '+        ', '+        # File reading context (only if no modifications)', '+        if files_read and not files_modified and not description_parts:', '+            unique_read = list(dict.fromkeys(files_read))', '+            if len(unique_read) == 1:', '+                description_parts.append(f\"Analyzed {unique_read[0]}\")', '+            elif len(unique_read) <= 3:', '+                description_parts.append(f\"Reviewed {\\', \\'.join(unique_read)}\")', '+            else:', '+                description_parts.append(f\"Explored {len(unique_read)} files\")', '+        ', '+        # Combine description parts', '+        if description_parts:', '+            main_description = description_parts[0]', '+            ', '+            # Add file context if not already included', \"+            if files_modified and 'Modified' not in main_description and 'Enhanced' not in main_description:\", '+                if len(files_modified) == 1:', '+                    main_description += f\" - modified {files_modified[0]}\"', '+                elif len(files_modified) <= 3:', '+                    main_description += f\" - modified {len(files_modified)} files\"', '+            ', '+            return main_description', '+        ', '+        return None', '+    except Exception as e:', '+        logging.debug(f\"Failed to extract contextual description: {e}\")', '+        return None', '+', ' def health_check():', '     \"\"\"System health check\"\"\"', '     print(\"[HEALTH] Health Check...\")']}], 'userModified': False, 'replaceAll': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Bash",
        "timestamp": "2025-08-24T18:59:49.701456",
        "input_data": {
          "command": "python .prsist/bin/prsist.py -r",
          "description": "Test the new contextual session descriptions"
        },
        "output_data": "{'stdout': '[RUN] Prsist Memory: Running 1 command(s)\\r\\n--------------------------------------------------\\r\\n[RECENT] Recent Sessions...\\r\\n  - 15859307: Development session\\r\\n  - fe62facb: Development session\\r\\n  - e6dca0ec: Development session\\r\\n  - f02444bf: Development session\\r\\n  - ca0cdd1e: Development session\\r\\n--------------------------------------------------\\r\\n[DONE] 1/1 commands completed successfully\\r\\n2025-08-24 18:59:48,882 - root - INFO - Memory manager initialized\\r', 'stderr': '', 'interrupted': False, 'isImage': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Bash",
        "timestamp": "2025-08-24T18:59:49.734671",
        "input_data": {
          "command": "python .prsist/bin/prsist.py -r",
          "description": "Test the new contextual session descriptions"
        },
        "output_data": "{'stdout': '[RUN] Prsist Memory: Running 1 command(s)\\r\\n--------------------------------------------------\\r\\n[RECENT] Recent Sessions...\\r\\n  - 15859307: Development session\\r\\n  - fe62facb: Development session\\r\\n  - e6dca0ec: Development session\\r\\n  - f02444bf: Development session\\r\\n  - ca0cdd1e: Development session\\r\\n--------------------------------------------------\\r\\n[DONE] 1/1 commands completed successfully\\r\\n2025-08-24 18:59:48,882 - root - INFO - Memory manager initialized\\r', 'stderr': '', 'interrupted': False, 'isImage': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Read",
        "timestamp": "2025-08-24T19:00:02.052220",
        "input_data": {
          "file_path": ".prsist/sessions/active/current-session.json",
          "limit": 20
        },
        "output_data": "{'type': 'text', 'file': {'filePath': '.prsist/sessions/active/current-session.json', 'content': '{\\n  \"id\": \"15859307-2121-4af6-a427-efe14d49355a\",\\n  \"created_at\": \"2025-08-24 22:02:28\",\\n  \"updated_at\": \"2025-08-24T18:59:49.740676\",\\n  \"project_path\": \"D:\\\\\\\\Projects\\\\\\\\Dev\\\\\\\\Memory\",\\n  \"git_info\": {},\\n  \"context_data\": {\\n    \"last_tool_used\": \"Bash\",\\n    \"last_tool_time\": \"2025-08-24T18:59:49.738675\",\\n    \"tool_count\": 1\\n  },\\n  \"status\": \"active\",\\n  \"tool_usage\": [\\n    {\\n      \"tool_name\": \"Bash\",\\n      \"timestamp\": \"2025-08-24T18:55:36.549352\",\\n      \"input_data\": {\\n        \"command\": \"python .prsist/bin/prsist.py -r\",\\n        \"description\": \"Test enhanced contextual session descriptions\"\\n      },', 'numLines': 20, 'startLine': 1, 'totalLines': 229}}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Read",
        "timestamp": "2025-08-24T19:00:02.329246",
        "input_data": {
          "file_path": ".prsist/sessions/active/current-session.json",
          "limit": 20
        },
        "output_data": "{'type': 'text', 'file': {'filePath': '.prsist/sessions/active/current-session.json', 'content': '{\\n  \"id\": \"15859307-2121-4af6-a427-efe14d49355a\",\\n  \"created_at\": \"2025-08-24 22:02:28\",\\n  \"updated_at\": \"2025-08-24T18:59:49.740676\",\\n  \"project_path\": \"D:\\\\\\\\Projects\\\\\\\\Dev\\\\\\\\Memory\",\\n  \"git_info\": {},\\n  \"context_data\": {\\n    \"last_tool_used\": \"Bash\",\\n    \"last_tool_time\": \"2025-08-24T18:59:49.738675\",\\n    \"tool_count\": 1\\n  },\\n  \"status\": \"active\",\\n  \"tool_usage\": [\\n    {\\n      \"tool_name\": \"Bash\",\\n      \"timestamp\": \"2025-08-24T18:55:36.549352\",\\n      \"input_data\": {\\n        \"command\": \"python .prsist/bin/prsist.py -r\",\\n        \"description\": \"Test enhanced contextual session descriptions\"\\n      },', 'numLines': 20, 'startLine': 1, 'totalLines': 229}}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Edit",
        "timestamp": "2025-08-24T19:00:13.620585",
        "input_data": {
          "file_path": ".prsist/bin/prsist.py",
          "old_string": "return \"Empty session\"\n    except Exception as e:\n        logging.debug(f\"Failed to generate session description: {e}\")\n        return \"Development session\"",
          "new_string": "return \"Empty session\"\n    except Exception as e:\n        print(f\"[DEBUG] Session description error: {e}\")  # Temporary debug\n        return \"Development session\""
        },
        "output_data": "{'filePath': '.prsist/bin/prsist.py', 'oldString': '        return \"Empty session\"\\n    except Exception as e:\\n        logging.debug(f\"Failed to generate session description: {e}\")\\n        return \"Development session\"', 'newString': '        return \"Empty session\"\\n    except Exception as e:\\n        print(f\"[DEBUG] Session description error: {e}\")  # Temporary debug\\n        return \"Development session\"', 'originalFile': '#!/usr/bin/env python3\\n\"\"\"\\nPrsist Memory System CLI - Simple, memorable commands\\nUsage: prsist [options]\\n\\nSingle Letter Options:\\n  -t  Test system\\n  -s  Status/session info  \\n  -c  Context (what Claude sees)\\n  -r  Recent sessions\\n  -h  Health check\\n  -f  Feature log (interactive)\\n  -m  Memory stats\\n  -v  Validate system\\n  -p  Project memory operations\\n  -d  Decisions (add decision)\\n  -e  End session\\n  -n  New session (start)\\n  -k  Checkpoint (create)\\n  -x  Export session data\\n  -z  Cleanup old data\\n  -l  List all commands\\n  -a  All checks (equivalent to -tschrmv)\\n  \\nChain commands: prsist -tsc (test + status + context)\\nExamples:\\n  prsist -t        Test system\\n  prsist -h        Health check\\n  prsist -tsc      Test + Status + Context\\n  prsist -a        Run all checks\\n  prsist -hm       Health + Memory stats\\n\"\"\"\\n\\nimport sys\\nimport os\\nimport json\\nimport logging\\nfrom pathlib import Path\\n\\n# Add parent directory to path for imports\\nsys.path.insert(0, str(Path(__file__).parent.parent))\\n\\ndef test_system():\\n    \"\"\"Test complete memory system\"\"\"\\n    print(\"[TEST] Testing Memory System...\")\\n    try:\\n        import subprocess\\n        result = subprocess.run([sys.executable, \"../tests/test_system.py\"], \\n                              capture_output=True, text=True, cwd=Path(__file__).parent)\\n        if result.returncode == 0:\\n            print(\"[PASS] All tests passed!\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Tests failed: {result.stderr}\")\\n            return False\\n    except Exception as e:\\n        print(f\"[ERROR] Test error: {e}\")\\n        return False\\n\\ndef session_status():\\n    \"\"\"Get current session status\"\"\"\\n    print(\"[STATUS] Session Status...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        info = mm.get_session_info()\\n        \\n        if info.get(\"session_id\"):\\n            print(f\"  Active Session: {info[\\'session_id\\'][:8]}...\")\\n            print(f\"  Tools Used: {info.get(\\'tool_usage_count\\', 0)}\")\\n            print(f\"  Files Modified: {info.get(\\'file_interaction_count\\', 0)}\")\\n            print(f\"  Duration: {info.get(\\'duration_minutes\\', 0)} minutes\")\\n        else:\\n            print(\"  No active session\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Status error: {e}\")\\n        return False\\n\\ndef show_context():\\n    \"\"\"Show current context (what Claude sees)\"\"\"\\n    print(\"[CONTEXT] Current Context...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        context = mm.get_session_context()\\n        \\n        if context:\\n            lines = context.split(\\'\\\\n\\')\\n            print(f\"  Context Length: {len(context)} characters\")\\n            print(f\"  Lines: {len(lines)}\")\\n            print(\"  Preview:\")\\n            for i, line in enumerate(lines[:5]):\\n                print(f\"    {line[:70]}{\\'...\\' if len(line) > 70 else \\'\\'}\")\\n            if len(lines) > 5:\\n                print(f\"    ... and {len(lines) - 5} more lines\")\\n        else:\\n            print(\"  No context available\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Context error: {e}\")\\n        return False\\n\\ndef recent_sessions():\\n    \"\"\"Show recent sessions with enhanced descriptions\"\"\"\\n    print(\"[RECENT] Recent Sessions...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        sessions = mm.get_recent_sessions(5)\\n        \\n        if sessions:\\n            # Check for current active session\\n            current_session_id = None\\n            try:\\n                current_context = mm.get_session_context()\\n                current_session_id = current_context.get(\"session_id\")\\n            except:\\n                pass\\n            \\n            for i, session in enumerate(sessions):\\n                # Generate meaningful description\\n                description = generate_session_description(session)\\n                session_id = session.get(\"session_id\", \"Unknown\")\\n                short_id = session_id[:8] if session_id != \"Unknown\" else \"Unknown\"\\n                \\n                if i == 0 and session_id == current_session_id:\\n                    # Current active session - enhanced display\\n                    print(f\"ðŸ”„ Active Session ({short_id})\")\\n                    print(f\"  - Activity: {description}\")\\n                    print(f\"  - Focus: Enhanced session descriptions and memory system improvements\")\\n                    print(f\"  - Status: Currently active\")\\n                    print(\"\")\\n                    print(\"ðŸ“– Previous Sessions:\")\\n                elif i == 0:\\n                    # First session but not current\\n                    print(f\"  - {short_id}: {description}\")\\n                else:\\n                    # Previous sessions\\n                    print(f\"  - {short_id}: {description}\")\\n        else:\\n            print(\"  No recent sessions found\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Recent sessions error: {e}\")\\n        return False\\n\\ndef generate_session_description(session_data):\\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\\n    try:\\n        # Get session details for rich context generation\\n        session_id = session_data.get(\\'session_id\\')\\n        if not session_id:\\n            return \"Unknown session\"\\n            \\n        # Try to load full session data from archived or active sessions\\n        memory_dir = Path(__file__).parent.parent\\n        archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\\n        \\n        full_session_data = None\\n        if archived_file.exists():\\n            with open(archived_file, \\'r\\') as f:\\n                full_session_data = json.load(f)\\n        else:\\n            # Try active session file\\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n            if active_file.exists():\\n                with open(active_file, \\'r\\') as f:\\n                    temp_data = json.load(f)\\n                    if temp_data.get(\\'id\\') == session_id:\\n                        full_session_data = temp_data\\n        \\n        if full_session_data:\\n            # Extract rich context from session data\\n            description = _extract_contextual_description(full_session_data, session_data)\\n            if description:\\n                return description\\n        \\n        # Fallback to enhanced generic descriptions\\n        tool_count = session_data.get(\\'tool_usage_count\\', 0)\\n        file_count = session_data.get(\\'file_interaction_count\\', 0)\\n        tools_used = session_data.get(\\'unique_tools_used\\', [])\\n        \\n        # Generate enhanced descriptions\\n        if file_count > 0 and tool_count > 0:\\n            if \\'Write\\' in tools_used and \\'Edit\\' in tools_used:\\n                return f\"Created and refined {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} ({tool_count} operations)\"\\n            elif \\'Write\\' in tools_used:\\n                return f\"New file development - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} created\"\\n            elif \\'Edit\\' in tools_used or \\'MultiEdit\\' in tools_used:\\n                return f\"Code editing session - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} modified\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Code analysis and exploration ({tool_count} operations)\"\\n        elif tool_count > 15:\\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command-heavy development session ({tool_count} operations)\"\\n        elif tool_count > 5:\\n            if \\'Bash\\' in tools_used:\\n                return f\"Command execution and testing ({tool_count} operations)\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Documentation and code review ({tool_count} operations)\"\\n        elif tool_count > 0:\\n            return f\"Light development work ({tool_count} operations)\"\\n        \\n        return \"Empty session\"\\n    except Exception as e:\\n        logging.debug(f\"Failed to generate session description: {e}\")\\n        return \"Development session\"\\n\\n\\ndef _extract_contextual_description(full_session_data, session_summary):\\n    \"\"\"Extract meaningful context from full session data\"\"\"\\n    try:\\n        tool_usage = full_session_data.get(\\'tool_usage\\', [])\\n        file_interactions = full_session_data.get(\\'file_interactions\\', [])\\n        \\n        # Extract key information\\n        files_modified = []\\n        files_read = []\\n        commands_run = []\\n        searches_made = []\\n        todos_worked = []\\n        \\n        # Analyze tool usage for context\\n        for tool in tool_usage:\\n            tool_name = tool.get(\\'tool_name\\', \\'\\')\\n            input_data = tool.get(\\'input_data\\', {})\\n            \\n            if tool_name in [\\'Edit\\', \\'MultiEdit\\', \\'Write\\']:\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_modified.append(Path(file_path).name)\\n            elif tool_name == \\'Read\\':\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_read.append(Path(file_path).name)\\n            elif tool_name == \\'Bash\\':\\n                command = input_data.get(\\'command\\', \\'\\')\\n                if command:\\n                    commands_run.append(command)\\n            elif tool_name == \\'WebSearch\\':\\n                query = input_data.get(\\'query\\', \\'\\')\\n                if query:\\n                    searches_made.append(query)\\n            elif tool_name == \\'TodoWrite\\':\\n                todos = input_data.get(\\'todos\\', [])\\n                for todo in todos:\\n                    content = todo.get(\\'content\\', \\'\\')\\n                    if content and content not in todos_worked:\\n                        todos_worked.append(content)\\n        \\n        # Generate contextual description based on extracted data\\n        description_parts = []\\n        \\n        # Main activity identification\\n        if searches_made:\\n            for query in searches_made[:1]:  # Focus on first search\\n                if \\'mcp\\' in query.lower() or \\'context7\\' in query.lower():\\n                    description_parts.append(\"Researched and integrated Context7 MCP server\")\\n                    break\\n                elif \\'memory\\' in query.lower():\\n                    description_parts.append(\"Researched memory system implementation\")\\n                    break\\n                else:\\n                    description_parts.append(f\"Researched {query[:50]}\")\\n                    break\\n        \\n        if todos_worked:\\n            todo_descriptions = []\\n            for todo in todos_worked[:2]:  # Show first 2 todos\\n                if \\'mcp\\' in todo.lower() or \\'context7\\' in todo.lower():\\n                    todo_descriptions.append(\"MCP server setup\")\\n                elif \\'enhance\\' in todo.lower() or \\'improve\\' in todo.lower():\\n                    todo_descriptions.append(\"system improvements\")\\n                else:\\n                    todo_descriptions.append(todo[:30])\\n            \\n            if not description_parts:  # Only if no search activity found\\n                description_parts.append(f\"Worked on: {\\', \\'.join(todo_descriptions)}\")\\n        \\n        # File modification context\\n        if files_modified:\\n            unique_files = list(dict.fromkeys(files_modified))  # Remove duplicates\\n            if len(unique_files) == 1:\\n                file_name = unique_files[0]\\n                if \\'activity_analyzer\\' in file_name:\\n                    description_parts.append(f\"Enhanced session analysis in {file_name}\")\\n                elif \\'prsist\\' in file_name:\\n                    description_parts.append(f\"Improved memory CLI in {file_name}\")\\n                elif \\'memory\\' in file_name or \\'session\\' in file_name:\\n                    description_parts.append(f\"Updated memory system in {file_name}\")\\n                else:\\n                    description_parts.append(f\"Modified {file_name}\")\\n            elif len(unique_files) <= 3:\\n                description_parts.append(f\"Modified {\\', \\'.join(unique_files[:2])} + {len(unique_files)-2} more files\" if len(unique_files) > 2 else f\"Modified {\\', \\'.join(unique_files)}\")\\n            else:\\n                description_parts.append(f\"Modified {len(unique_files)} files including {\\', \\'.join(unique_files[:2])}\")\\n        \\n        # Command execution context\\n        if commands_run and not description_parts:\\n            command_contexts = []\\n            for cmd in commands_run[:3]:  # Look at first 3 commands\\n                if \\'mcp add\\' in cmd:\\n                    command_contexts.append(\"MCP server installation\")\\n                elif \\'mem\\' in cmd and \\'recent\\' in cmd:\\n                    command_contexts.append(\"memory system testing\")\\n                elif \\'python\\' in cmd and \\'prsist\\' in cmd:\\n                    command_contexts.append(\"memory CLI validation\")\\n                elif \\'npm\\' in cmd or \\'npx\\' in cmd:\\n                    command_contexts.append(\"package management\")\\n            \\n            if command_contexts:\\n                description_parts.append(\\', \\'.join(dict.fromkeys(command_contexts)))  # Remove duplicates\\n        \\n        # File reading context (only if no modifications)\\n        if files_read and not files_modified and not description_parts:\\n            unique_read = list(dict.fromkeys(files_read))\\n            if len(unique_read) == 1:\\n                description_parts.append(f\"Analyzed {unique_read[0]}\")\\n            elif len(unique_read) <= 3:\\n                description_parts.append(f\"Reviewed {\\', \\'.join(unique_read)}\")\\n            else:\\n                description_parts.append(f\"Explored {len(unique_read)} files\")\\n        \\n        # Combine description parts\\n        if description_parts:\\n            main_description = description_parts[0]\\n            \\n            # Add file context if not already included\\n            if files_modified and \\'Modified\\' not in main_description and \\'Enhanced\\' not in main_description:\\n                if len(files_modified) == 1:\\n                    main_description += f\" - modified {files_modified[0]}\"\\n                elif len(files_modified) <= 3:\\n                    main_description += f\" - modified {len(files_modified)} files\"\\n            \\n            return main_description\\n        \\n        return None\\n    except Exception as e:\\n        logging.debug(f\"Failed to extract contextual description: {e}\")\\n        return None\\n\\ndef health_check():\\n    \"\"\"System health check\"\"\"\\n    print(\"[HEALTH] Health Check...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        if validation[\"valid\"]:\\n            print(\"[PASS] System healthy\")\\n        else:\\n            print(\"[WARN] System issues found:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Health check error: {e}\")\\n        return False\\n\\ndef feature_log():\\n    \"\"\"Interactive feature logging\"\"\"\\n    print(\"[FEATURE] Feature Logging...\")\\n    try:\\n        feature_name = input(\"Feature name: \").strip()\\n        if not feature_name:\\n            print(\"[ERROR] Feature name required\")\\n            return False\\n            \\n        description = input(\"Description (optional): \").strip()\\n        \\n        import subprocess\\n        cmd = [sys.executable, \"hooks/FeatureComplete.py\", feature_name]\\n        if description:\\n            cmd.append(description)\\n            \\n        result = subprocess.run(cmd, capture_output=True, text=True, cwd=Path(__file__).parent)\\n        \\n        if result.returncode == 0:\\n            print(f\"[PASS] Feature \\'{feature_name}\\' logged successfully\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Feature logging failed: {result.stderr}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Feature logging cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Feature logging error: {e}\")\\n        return False\\n\\ndef memory_stats():\\n    \"\"\"Show memory system statistics\"\"\"\\n    print(\"[STATS] Memory Stats...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        stats = mm.get_memory_stats()\\n        \\n        print(f\"  Total Sessions: {stats.get(\\'total_sessions\\', 0)}\")\\n        print(f\"  Database Size: {stats.get(\\'database_size_mb\\', 0)} MB\")\\n        print(f\"  Active Session: {stats.get(\\'active_session\\', \\'None\\')}\")\\n        print(f\"  Project Root: {stats.get(\\'project_root\\', \\'Unknown\\')}\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Memory stats error: {e}\")\\n        return False\\n\\ndef validate_system():\\n    \"\"\"Validate system integrity\"\"\"\\n    print(\"[VALIDATE] System Validation...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        print(f\"  System Valid: {validation[\\'valid\\']}\")\\n        if not validation[\"valid\"]:\\n            print(\"  Issues:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Validation error: {e}\")\\n        return False\\n\\ndef project_memory():\\n    \"\"\"Add to project memory\"\"\"\\n    print(\"[PROJECT] Project Memory...\")\\n    try:\\n        content = input(\"Enter information to add to project memory: \").strip()\\n        if not content:\\n            print(\"[ERROR] Content required\")\\n            return False\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_project_memory(content)\\n        \\n        if success:\\n            print(f\"[PASS] Project memory updated\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to update project memory\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Project memory update cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Project memory error: {e}\")\\n        return False\\n\\ndef add_decision():\\n    \"\"\"Add a decision record\"\"\"\\n    print(\"[DECISION] Add Decision...\")\\n    try:\\n        title = input(\"Decision title: \").strip()\\n        if not title:\\n            print(\"[ERROR] Decision title required\")\\n            return False\\n            \\n        description = input(\"Description: \").strip()\\n        if not description:\\n            print(\"[ERROR] Description required\")\\n            return False\\n            \\n        category = input(\"Category (architecture/technical/process/design): \").strip()\\n        if not category:\\n            category = \"general\"\\n            \\n        impact = input(\"Impact (low/medium/high/critical): \").strip()\\n        if not impact:\\n            impact = \"medium\"\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_decision(title, description, category, impact)\\n        \\n        if success:\\n            print(f\"[PASS] Decision \\'{title}\\' recorded\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to record decision\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Decision recording cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Decision recording error: {e}\")\\n        return False\\n\\ndef end_session():\\n    \"\"\"End current session\"\"\"\\n    print(\"[END] Ending Session...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.end_session(archive=True)\\n        \\n        if result:\\n            print(\"[PASS] Session ended and archived\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to end\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] End session error: {e}\")\\n        return False\\n\\ndef new_session():\\n    \"\"\"Start new session\"\"\"\\n    print(\"[NEW] Starting New Session...\")\\n    try:\\n        context = input(\"Session context (optional): \").strip()\\n        \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        \\n        session_data = {}\\n        if context:\\n            session_data[\"context\"] = context\\n            \\n        result = mm.start_session(session_data)\\n        \\n        if result.get(\"memory_system_active\"):\\n            session_id = result.get(\"session_id\", \"unknown\")\\n            print(f\"[PASS] New session started: {session_id[:8]}...\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Failed to start session: {result.get(\\'error\\', \\'Unknown error\\')}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Session start cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] New session error: {e}\")\\n        return False\\n\\ndef create_checkpoint():\\n    \"\"\"Create a checkpoint\"\"\"\\n    print(\"[CHECKPOINT] Creating Checkpoint...\")\\n    try:\\n        name = input(\"Checkpoint name (optional): \").strip()\\n        if not name:\\n            name = None\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.create_checkpoint(name)\\n        \\n        if result:\\n            print(f\"[PASS] Checkpoint created: {name or \\'auto\\'}\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to create checkpoint\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Checkpoint creation cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Checkpoint error: {e}\")\\n        return False\\n\\ndef export_session():\\n    \"\"\"Export current session data\"\"\"\\n    print(\"[EXPORT] Exporting Session Data...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        data = mm.export_session_data(format=\"json\")\\n        \\n        if data:\\n            filename = f\"session_export_{mm.get_session_info().get(\\'session_id\\', \\'unknown\\')[:8]}.json\"\\n            with open(filename, \\'w\\') as f:\\n                f.write(data)\\n            print(f\"[PASS] Session exported to {filename}\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to export\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] Export error: {e}\")\\n        return False\\n\\ndef cleanup_data():\\n    \"\"\"Clean up old data\"\"\"\\n    print(\"[CLEANUP] Cleaning Up Old Data...\")\\n    try:\\n        days = input(\"Retention days (default 30): \").strip()\\n        if not days:\\n            days = 30\\n        else:\\n            days = int(days)\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.cleanup_old_data(retention_days=days)\\n        \\n        print(f\"[PASS] Cleanup completed: {result}\")\\n        return True\\n    except ValueError:\\n        print(\"[ERROR] Invalid number of days\")\\n        return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Cleanup cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Cleanup error: {e}\")\\n        return False\\n\\ndef list_commands():\\n    \"\"\"List all available commands\"\"\"\\n    print(\"[HELP] Prsist Memory System Commands:\")\\n    print(\"\\\\n  Core Operations:\")\\n    print(\"  -t  Test system\")\\n    print(\"  -s  Status/session info\")\\n    print(\"  -c  Context (what Claude sees)\")\\n    print(\"  -r  Recent sessions\")\\n    print(\"  -h  Health check\")\\n    print(\"  -m  Memory stats\")\\n    print(\"  -v  Validate system\")\\n    print(\"\\\\n  Session Management:\")\\n    print(\"  -n  New session (start)\")\\n    print(\"  -e  End session\")\\n    print(\"  -k  Checkpoint (create)\")\\n    print(\"  -x  Export session data\")\\n    print(\"\\\\n  Data Management:\")\\n    print(\"  -f  Feature log (interactive)\")\\n    print(\"  -p  Project memory (add)\")\\n    print(\"  -d  Decisions (add decision)\")\\n    print(\"  -z  Cleanup old data\")\\n    print(\"\\\\n  Shortcuts:\")\\n    print(\"  -a  All core checks (equivalent to -tschrmv)\")\\n    print(\"  -l  List commands (this help)\")\\n    print(\"\\\\nExamples:\")\\n    print(\"  prsist -t      (test system)\")\\n    print(\"  prsist -hm     (health + memory stats)\")\\n    print(\"  prsist -tsc    (test + status + context)\")\\n    print(\"  prsist -a      (run all core checks)\")\\n    print(\"  prsist -nf     (new session + feature log)\")\\n    return True\\n\\n# Command mapping\\nCOMMAND_MAP = {\\n    \\'t\\': test_system,\\n    \\'s\\': session_status,\\n    \\'c\\': show_context,\\n    \\'r\\': recent_sessions,\\n    \\'h\\': health_check,\\n    \\'f\\': feature_log,\\n    \\'m\\': memory_stats,\\n    \\'v\\': validate_system,\\n    \\'p\\': project_memory,\\n    \\'d\\': add_decision,\\n    \\'e\\': end_session,\\n    \\'n\\': new_session,\\n    \\'k\\': create_checkpoint,\\n    \\'x\\': export_session,\\n    \\'z\\': cleanup_data,\\n    \\'l\\': list_commands\\n}\\n\\ndef main():\\n    # Custom argument parser that handles combined flags like -tsc\\n    if len(sys.argv) < 2:\\n        print(\"Prsist Memory System CLI\")\\n        print(\"Usage: prsist [options]\")\\n        print(\"Example: prsist -t       (test)\")\\n        print(\"Example: prsist -tsc     (test + status + context)\")\\n        print(\"Example: prsist -a       (all checks)\")\\n        print(\"Use \\'prsist -l\\' to list all commands\")\\n        return\\n\\n    # Parse arguments manually to handle combined flags\\n    args = sys.argv[1]\\n    if args.startswith(\\'-\\'):\\n        commands = args[1:]  # Remove the dash\\n    else:\\n        commands = args\\n\\n    # Handle special \\'all\\' command\\n    if \\'a\\' in commands:\\n        commands = commands.replace(\\'a\\', \\'tschrmv\\')\\n\\n    # Remove duplicates while preserving order\\n    seen = set()\\n    unique_commands = []\\n    for cmd in commands:\\n        if cmd not in seen:\\n            seen.add(cmd)\\n            unique_commands.append(cmd)\\n    \\n    commands = \\'\\'.join(unique_commands)\\n    \\n    success_count = 0\\n    total_count = 0\\n    \\n    print(f\"[RUN] Prsist Memory: Running {len(commands)} command(s)\")\\n    print(\"-\" * 50)\\n    \\n    for i, cmd in enumerate(commands):\\n        if cmd in COMMAND_MAP:\\n            if i > 0:\\n                print()  # Space between commands\\n            success = COMMAND_MAP[cmd]()\\n            total_count += 1\\n            if success:\\n                success_count += 1\\n        else:\\n            print(f\"[ERROR] Unknown command: -{cmd}\")\\n            total_count += 1\\n    \\n    print(\"-\" * 50)\\n    print(f\"[DONE] {success_count}/{total_count} commands completed successfully\")\\n\\nif __name__ == \"__main__\":\\n    main()', 'structuredPatch': [{'oldStart': 206, 'oldLines': 7, 'newStart': 206, 'newLines': 7, 'lines': ['         ', '         return \"Empty session\"', '     except Exception as e:', '-        logging.debug(f\"Failed to generate session description: {e}\")', '+        print(f\"[DEBUG] Session description error: {e}\")  # Temporary debug', '         return \"Development session\"', ' ', ' ']}], 'userModified': False, 'replaceAll': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Edit",
        "timestamp": "2025-08-24T19:00:13.697599",
        "input_data": {
          "file_path": ".prsist/bin/prsist.py",
          "old_string": "return \"Empty session\"\n    except Exception as e:\n        logging.debug(f\"Failed to generate session description: {e}\")\n        return \"Development session\"",
          "new_string": "return \"Empty session\"\n    except Exception as e:\n        print(f\"[DEBUG] Session description error: {e}\")  # Temporary debug\n        return \"Development session\""
        },
        "output_data": "{'filePath': '.prsist/bin/prsist.py', 'oldString': '        return \"Empty session\"\\n    except Exception as e:\\n        logging.debug(f\"Failed to generate session description: {e}\")\\n        return \"Development session\"', 'newString': '        return \"Empty session\"\\n    except Exception as e:\\n        print(f\"[DEBUG] Session description error: {e}\")  # Temporary debug\\n        return \"Development session\"', 'originalFile': '#!/usr/bin/env python3\\n\"\"\"\\nPrsist Memory System CLI - Simple, memorable commands\\nUsage: prsist [options]\\n\\nSingle Letter Options:\\n  -t  Test system\\n  -s  Status/session info  \\n  -c  Context (what Claude sees)\\n  -r  Recent sessions\\n  -h  Health check\\n  -f  Feature log (interactive)\\n  -m  Memory stats\\n  -v  Validate system\\n  -p  Project memory operations\\n  -d  Decisions (add decision)\\n  -e  End session\\n  -n  New session (start)\\n  -k  Checkpoint (create)\\n  -x  Export session data\\n  -z  Cleanup old data\\n  -l  List all commands\\n  -a  All checks (equivalent to -tschrmv)\\n  \\nChain commands: prsist -tsc (test + status + context)\\nExamples:\\n  prsist -t        Test system\\n  prsist -h        Health check\\n  prsist -tsc      Test + Status + Context\\n  prsist -a        Run all checks\\n  prsist -hm       Health + Memory stats\\n\"\"\"\\n\\nimport sys\\nimport os\\nimport json\\nimport logging\\nfrom pathlib import Path\\n\\n# Add parent directory to path for imports\\nsys.path.insert(0, str(Path(__file__).parent.parent))\\n\\ndef test_system():\\n    \"\"\"Test complete memory system\"\"\"\\n    print(\"[TEST] Testing Memory System...\")\\n    try:\\n        import subprocess\\n        result = subprocess.run([sys.executable, \"../tests/test_system.py\"], \\n                              capture_output=True, text=True, cwd=Path(__file__).parent)\\n        if result.returncode == 0:\\n            print(\"[PASS] All tests passed!\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Tests failed: {result.stderr}\")\\n            return False\\n    except Exception as e:\\n        print(f\"[ERROR] Test error: {e}\")\\n        return False\\n\\ndef session_status():\\n    \"\"\"Get current session status\"\"\"\\n    print(\"[STATUS] Session Status...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        info = mm.get_session_info()\\n        \\n        if info.get(\"session_id\"):\\n            print(f\"  Active Session: {info[\\'session_id\\'][:8]}...\")\\n            print(f\"  Tools Used: {info.get(\\'tool_usage_count\\', 0)}\")\\n            print(f\"  Files Modified: {info.get(\\'file_interaction_count\\', 0)}\")\\n            print(f\"  Duration: {info.get(\\'duration_minutes\\', 0)} minutes\")\\n        else:\\n            print(\"  No active session\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Status error: {e}\")\\n        return False\\n\\ndef show_context():\\n    \"\"\"Show current context (what Claude sees)\"\"\"\\n    print(\"[CONTEXT] Current Context...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        context = mm.get_session_context()\\n        \\n        if context:\\n            lines = context.split(\\'\\\\n\\')\\n            print(f\"  Context Length: {len(context)} characters\")\\n            print(f\"  Lines: {len(lines)}\")\\n            print(\"  Preview:\")\\n            for i, line in enumerate(lines[:5]):\\n                print(f\"    {line[:70]}{\\'...\\' if len(line) > 70 else \\'\\'}\")\\n            if len(lines) > 5:\\n                print(f\"    ... and {len(lines) - 5} more lines\")\\n        else:\\n            print(\"  No context available\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Context error: {e}\")\\n        return False\\n\\ndef recent_sessions():\\n    \"\"\"Show recent sessions with enhanced descriptions\"\"\"\\n    print(\"[RECENT] Recent Sessions...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        sessions = mm.get_recent_sessions(5)\\n        \\n        if sessions:\\n            # Check for current active session\\n            current_session_id = None\\n            try:\\n                current_context = mm.get_session_context()\\n                current_session_id = current_context.get(\"session_id\")\\n            except:\\n                pass\\n            \\n            for i, session in enumerate(sessions):\\n                # Generate meaningful description\\n                description = generate_session_description(session)\\n                session_id = session.get(\"session_id\", \"Unknown\")\\n                short_id = session_id[:8] if session_id != \"Unknown\" else \"Unknown\"\\n                \\n                if i == 0 and session_id == current_session_id:\\n                    # Current active session - enhanced display\\n                    print(f\"ðŸ”„ Active Session ({short_id})\")\\n                    print(f\"  - Activity: {description}\")\\n                    print(f\"  - Focus: Enhanced session descriptions and memory system improvements\")\\n                    print(f\"  - Status: Currently active\")\\n                    print(\"\")\\n                    print(\"ðŸ“– Previous Sessions:\")\\n                elif i == 0:\\n                    # First session but not current\\n                    print(f\"  - {short_id}: {description}\")\\n                else:\\n                    # Previous sessions\\n                    print(f\"  - {short_id}: {description}\")\\n        else:\\n            print(\"  No recent sessions found\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Recent sessions error: {e}\")\\n        return False\\n\\ndef generate_session_description(session_data):\\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\\n    try:\\n        # Get session details for rich context generation\\n        session_id = session_data.get(\\'session_id\\')\\n        if not session_id:\\n            return \"Unknown session\"\\n            \\n        # Try to load full session data from archived or active sessions\\n        memory_dir = Path(__file__).parent.parent\\n        archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\\n        \\n        full_session_data = None\\n        if archived_file.exists():\\n            with open(archived_file, \\'r\\') as f:\\n                full_session_data = json.load(f)\\n        else:\\n            # Try active session file\\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n            if active_file.exists():\\n                with open(active_file, \\'r\\') as f:\\n                    temp_data = json.load(f)\\n                    if temp_data.get(\\'id\\') == session_id:\\n                        full_session_data = temp_data\\n        \\n        if full_session_data:\\n            # Extract rich context from session data\\n            description = _extract_contextual_description(full_session_data, session_data)\\n            if description:\\n                return description\\n        \\n        # Fallback to enhanced generic descriptions\\n        tool_count = session_data.get(\\'tool_usage_count\\', 0)\\n        file_count = session_data.get(\\'file_interaction_count\\', 0)\\n        tools_used = session_data.get(\\'unique_tools_used\\', [])\\n        \\n        # Generate enhanced descriptions\\n        if file_count > 0 and tool_count > 0:\\n            if \\'Write\\' in tools_used and \\'Edit\\' in tools_used:\\n                return f\"Created and refined {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} ({tool_count} operations)\"\\n            elif \\'Write\\' in tools_used:\\n                return f\"New file development - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} created\"\\n            elif \\'Edit\\' in tools_used or \\'MultiEdit\\' in tools_used:\\n                return f\"Code editing session - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} modified\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Code analysis and exploration ({tool_count} operations)\"\\n        elif tool_count > 15:\\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command-heavy development session ({tool_count} operations)\"\\n        elif tool_count > 5:\\n            if \\'Bash\\' in tools_used:\\n                return f\"Command execution and testing ({tool_count} operations)\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Documentation and code review ({tool_count} operations)\"\\n        elif tool_count > 0:\\n            return f\"Light development work ({tool_count} operations)\"\\n        \\n        return \"Empty session\"\\n    except Exception as e:\\n        logging.debug(f\"Failed to generate session description: {e}\")\\n        return \"Development session\"\\n\\n\\ndef _extract_contextual_description(full_session_data, session_summary):\\n    \"\"\"Extract meaningful context from full session data\"\"\"\\n    try:\\n        tool_usage = full_session_data.get(\\'tool_usage\\', [])\\n        file_interactions = full_session_data.get(\\'file_interactions\\', [])\\n        \\n        # Extract key information\\n        files_modified = []\\n        files_read = []\\n        commands_run = []\\n        searches_made = []\\n        todos_worked = []\\n        \\n        # Analyze tool usage for context\\n        for tool in tool_usage:\\n            tool_name = tool.get(\\'tool_name\\', \\'\\')\\n            input_data = tool.get(\\'input_data\\', {})\\n            \\n            if tool_name in [\\'Edit\\', \\'MultiEdit\\', \\'Write\\']:\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_modified.append(Path(file_path).name)\\n            elif tool_name == \\'Read\\':\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_read.append(Path(file_path).name)\\n            elif tool_name == \\'Bash\\':\\n                command = input_data.get(\\'command\\', \\'\\')\\n                if command:\\n                    commands_run.append(command)\\n            elif tool_name == \\'WebSearch\\':\\n                query = input_data.get(\\'query\\', \\'\\')\\n                if query:\\n                    searches_made.append(query)\\n            elif tool_name == \\'TodoWrite\\':\\n                todos = input_data.get(\\'todos\\', [])\\n                for todo in todos:\\n                    content = todo.get(\\'content\\', \\'\\')\\n                    if content and content not in todos_worked:\\n                        todos_worked.append(content)\\n        \\n        # Generate contextual description based on extracted data\\n        description_parts = []\\n        \\n        # Main activity identification\\n        if searches_made:\\n            for query in searches_made[:1]:  # Focus on first search\\n                if \\'mcp\\' in query.lower() or \\'context7\\' in query.lower():\\n                    description_parts.append(\"Researched and integrated Context7 MCP server\")\\n                    break\\n                elif \\'memory\\' in query.lower():\\n                    description_parts.append(\"Researched memory system implementation\")\\n                    break\\n                else:\\n                    description_parts.append(f\"Researched {query[:50]}\")\\n                    break\\n        \\n        if todos_worked:\\n            todo_descriptions = []\\n            for todo in todos_worked[:2]:  # Show first 2 todos\\n                if \\'mcp\\' in todo.lower() or \\'context7\\' in todo.lower():\\n                    todo_descriptions.append(\"MCP server setup\")\\n                elif \\'enhance\\' in todo.lower() or \\'improve\\' in todo.lower():\\n                    todo_descriptions.append(\"system improvements\")\\n                else:\\n                    todo_descriptions.append(todo[:30])\\n            \\n            if not description_parts:  # Only if no search activity found\\n                description_parts.append(f\"Worked on: {\\', \\'.join(todo_descriptions)}\")\\n        \\n        # File modification context\\n        if files_modified:\\n            unique_files = list(dict.fromkeys(files_modified))  # Remove duplicates\\n            if len(unique_files) == 1:\\n                file_name = unique_files[0]\\n                if \\'activity_analyzer\\' in file_name:\\n                    description_parts.append(f\"Enhanced session analysis in {file_name}\")\\n                elif \\'prsist\\' in file_name:\\n                    description_parts.append(f\"Improved memory CLI in {file_name}\")\\n                elif \\'memory\\' in file_name or \\'session\\' in file_name:\\n                    description_parts.append(f\"Updated memory system in {file_name}\")\\n                else:\\n                    description_parts.append(f\"Modified {file_name}\")\\n            elif len(unique_files) <= 3:\\n                description_parts.append(f\"Modified {\\', \\'.join(unique_files[:2])} + {len(unique_files)-2} more files\" if len(unique_files) > 2 else f\"Modified {\\', \\'.join(unique_files)}\")\\n            else:\\n                description_parts.append(f\"Modified {len(unique_files)} files including {\\', \\'.join(unique_files[:2])}\")\\n        \\n        # Command execution context\\n        if commands_run and not description_parts:\\n            command_contexts = []\\n            for cmd in commands_run[:3]:  # Look at first 3 commands\\n                if \\'mcp add\\' in cmd:\\n                    command_contexts.append(\"MCP server installation\")\\n                elif \\'mem\\' in cmd and \\'recent\\' in cmd:\\n                    command_contexts.append(\"memory system testing\")\\n                elif \\'python\\' in cmd and \\'prsist\\' in cmd:\\n                    command_contexts.append(\"memory CLI validation\")\\n                elif \\'npm\\' in cmd or \\'npx\\' in cmd:\\n                    command_contexts.append(\"package management\")\\n            \\n            if command_contexts:\\n                description_parts.append(\\', \\'.join(dict.fromkeys(command_contexts)))  # Remove duplicates\\n        \\n        # File reading context (only if no modifications)\\n        if files_read and not files_modified and not description_parts:\\n            unique_read = list(dict.fromkeys(files_read))\\n            if len(unique_read) == 1:\\n                description_parts.append(f\"Analyzed {unique_read[0]}\")\\n            elif len(unique_read) <= 3:\\n                description_parts.append(f\"Reviewed {\\', \\'.join(unique_read)}\")\\n            else:\\n                description_parts.append(f\"Explored {len(unique_read)} files\")\\n        \\n        # Combine description parts\\n        if description_parts:\\n            main_description = description_parts[0]\\n            \\n            # Add file context if not already included\\n            if files_modified and \\'Modified\\' not in main_description and \\'Enhanced\\' not in main_description:\\n                if len(files_modified) == 1:\\n                    main_description += f\" - modified {files_modified[0]}\"\\n                elif len(files_modified) <= 3:\\n                    main_description += f\" - modified {len(files_modified)} files\"\\n            \\n            return main_description\\n        \\n        return None\\n    except Exception as e:\\n        logging.debug(f\"Failed to extract contextual description: {e}\")\\n        return None\\n\\ndef health_check():\\n    \"\"\"System health check\"\"\"\\n    print(\"[HEALTH] Health Check...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        if validation[\"valid\"]:\\n            print(\"[PASS] System healthy\")\\n        else:\\n            print(\"[WARN] System issues found:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Health check error: {e}\")\\n        return False\\n\\ndef feature_log():\\n    \"\"\"Interactive feature logging\"\"\"\\n    print(\"[FEATURE] Feature Logging...\")\\n    try:\\n        feature_name = input(\"Feature name: \").strip()\\n        if not feature_name:\\n            print(\"[ERROR] Feature name required\")\\n            return False\\n            \\n        description = input(\"Description (optional): \").strip()\\n        \\n        import subprocess\\n        cmd = [sys.executable, \"hooks/FeatureComplete.py\", feature_name]\\n        if description:\\n            cmd.append(description)\\n            \\n        result = subprocess.run(cmd, capture_output=True, text=True, cwd=Path(__file__).parent)\\n        \\n        if result.returncode == 0:\\n            print(f\"[PASS] Feature \\'{feature_name}\\' logged successfully\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Feature logging failed: {result.stderr}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Feature logging cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Feature logging error: {e}\")\\n        return False\\n\\ndef memory_stats():\\n    \"\"\"Show memory system statistics\"\"\"\\n    print(\"[STATS] Memory Stats...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        stats = mm.get_memory_stats()\\n        \\n        print(f\"  Total Sessions: {stats.get(\\'total_sessions\\', 0)}\")\\n        print(f\"  Database Size: {stats.get(\\'database_size_mb\\', 0)} MB\")\\n        print(f\"  Active Session: {stats.get(\\'active_session\\', \\'None\\')}\")\\n        print(f\"  Project Root: {stats.get(\\'project_root\\', \\'Unknown\\')}\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Memory stats error: {e}\")\\n        return False\\n\\ndef validate_system():\\n    \"\"\"Validate system integrity\"\"\"\\n    print(\"[VALIDATE] System Validation...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        print(f\"  System Valid: {validation[\\'valid\\']}\")\\n        if not validation[\"valid\"]:\\n            print(\"  Issues:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Validation error: {e}\")\\n        return False\\n\\ndef project_memory():\\n    \"\"\"Add to project memory\"\"\"\\n    print(\"[PROJECT] Project Memory...\")\\n    try:\\n        content = input(\"Enter information to add to project memory: \").strip()\\n        if not content:\\n            print(\"[ERROR] Content required\")\\n            return False\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_project_memory(content)\\n        \\n        if success:\\n            print(f\"[PASS] Project memory updated\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to update project memory\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Project memory update cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Project memory error: {e}\")\\n        return False\\n\\ndef add_decision():\\n    \"\"\"Add a decision record\"\"\"\\n    print(\"[DECISION] Add Decision...\")\\n    try:\\n        title = input(\"Decision title: \").strip()\\n        if not title:\\n            print(\"[ERROR] Decision title required\")\\n            return False\\n            \\n        description = input(\"Description: \").strip()\\n        if not description:\\n            print(\"[ERROR] Description required\")\\n            return False\\n            \\n        category = input(\"Category (architecture/technical/process/design): \").strip()\\n        if not category:\\n            category = \"general\"\\n            \\n        impact = input(\"Impact (low/medium/high/critical): \").strip()\\n        if not impact:\\n            impact = \"medium\"\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_decision(title, description, category, impact)\\n        \\n        if success:\\n            print(f\"[PASS] Decision \\'{title}\\' recorded\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to record decision\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Decision recording cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Decision recording error: {e}\")\\n        return False\\n\\ndef end_session():\\n    \"\"\"End current session\"\"\"\\n    print(\"[END] Ending Session...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.end_session(archive=True)\\n        \\n        if result:\\n            print(\"[PASS] Session ended and archived\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to end\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] End session error: {e}\")\\n        return False\\n\\ndef new_session():\\n    \"\"\"Start new session\"\"\"\\n    print(\"[NEW] Starting New Session...\")\\n    try:\\n        context = input(\"Session context (optional): \").strip()\\n        \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        \\n        session_data = {}\\n        if context:\\n            session_data[\"context\"] = context\\n            \\n        result = mm.start_session(session_data)\\n        \\n        if result.get(\"memory_system_active\"):\\n            session_id = result.get(\"session_id\", \"unknown\")\\n            print(f\"[PASS] New session started: {session_id[:8]}...\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Failed to start session: {result.get(\\'error\\', \\'Unknown error\\')}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Session start cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] New session error: {e}\")\\n        return False\\n\\ndef create_checkpoint():\\n    \"\"\"Create a checkpoint\"\"\"\\n    print(\"[CHECKPOINT] Creating Checkpoint...\")\\n    try:\\n        name = input(\"Checkpoint name (optional): \").strip()\\n        if not name:\\n            name = None\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.create_checkpoint(name)\\n        \\n        if result:\\n            print(f\"[PASS] Checkpoint created: {name or \\'auto\\'}\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to create checkpoint\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Checkpoint creation cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Checkpoint error: {e}\")\\n        return False\\n\\ndef export_session():\\n    \"\"\"Export current session data\"\"\"\\n    print(\"[EXPORT] Exporting Session Data...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        data = mm.export_session_data(format=\"json\")\\n        \\n        if data:\\n            filename = f\"session_export_{mm.get_session_info().get(\\'session_id\\', \\'unknown\\')[:8]}.json\"\\n            with open(filename, \\'w\\') as f:\\n                f.write(data)\\n            print(f\"[PASS] Session exported to {filename}\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to export\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] Export error: {e}\")\\n        return False\\n\\ndef cleanup_data():\\n    \"\"\"Clean up old data\"\"\"\\n    print(\"[CLEANUP] Cleaning Up Old Data...\")\\n    try:\\n        days = input(\"Retention days (default 30): \").strip()\\n        if not days:\\n            days = 30\\n        else:\\n            days = int(days)\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.cleanup_old_data(retention_days=days)\\n        \\n        print(f\"[PASS] Cleanup completed: {result}\")\\n        return True\\n    except ValueError:\\n        print(\"[ERROR] Invalid number of days\")\\n        return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Cleanup cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Cleanup error: {e}\")\\n        return False\\n\\ndef list_commands():\\n    \"\"\"List all available commands\"\"\"\\n    print(\"[HELP] Prsist Memory System Commands:\")\\n    print(\"\\\\n  Core Operations:\")\\n    print(\"  -t  Test system\")\\n    print(\"  -s  Status/session info\")\\n    print(\"  -c  Context (what Claude sees)\")\\n    print(\"  -r  Recent sessions\")\\n    print(\"  -h  Health check\")\\n    print(\"  -m  Memory stats\")\\n    print(\"  -v  Validate system\")\\n    print(\"\\\\n  Session Management:\")\\n    print(\"  -n  New session (start)\")\\n    print(\"  -e  End session\")\\n    print(\"  -k  Checkpoint (create)\")\\n    print(\"  -x  Export session data\")\\n    print(\"\\\\n  Data Management:\")\\n    print(\"  -f  Feature log (interactive)\")\\n    print(\"  -p  Project memory (add)\")\\n    print(\"  -d  Decisions (add decision)\")\\n    print(\"  -z  Cleanup old data\")\\n    print(\"\\\\n  Shortcuts:\")\\n    print(\"  -a  All core checks (equivalent to -tschrmv)\")\\n    print(\"  -l  List commands (this help)\")\\n    print(\"\\\\nExamples:\")\\n    print(\"  prsist -t      (test system)\")\\n    print(\"  prsist -hm     (health + memory stats)\")\\n    print(\"  prsist -tsc    (test + status + context)\")\\n    print(\"  prsist -a      (run all core checks)\")\\n    print(\"  prsist -nf     (new session + feature log)\")\\n    return True\\n\\n# Command mapping\\nCOMMAND_MAP = {\\n    \\'t\\': test_system,\\n    \\'s\\': session_status,\\n    \\'c\\': show_context,\\n    \\'r\\': recent_sessions,\\n    \\'h\\': health_check,\\n    \\'f\\': feature_log,\\n    \\'m\\': memory_stats,\\n    \\'v\\': validate_system,\\n    \\'p\\': project_memory,\\n    \\'d\\': add_decision,\\n    \\'e\\': end_session,\\n    \\'n\\': new_session,\\n    \\'k\\': create_checkpoint,\\n    \\'x\\': export_session,\\n    \\'z\\': cleanup_data,\\n    \\'l\\': list_commands\\n}\\n\\ndef main():\\n    # Custom argument parser that handles combined flags like -tsc\\n    if len(sys.argv) < 2:\\n        print(\"Prsist Memory System CLI\")\\n        print(\"Usage: prsist [options]\")\\n        print(\"Example: prsist -t       (test)\")\\n        print(\"Example: prsist -tsc     (test + status + context)\")\\n        print(\"Example: prsist -a       (all checks)\")\\n        print(\"Use \\'prsist -l\\' to list all commands\")\\n        return\\n\\n    # Parse arguments manually to handle combined flags\\n    args = sys.argv[1]\\n    if args.startswith(\\'-\\'):\\n        commands = args[1:]  # Remove the dash\\n    else:\\n        commands = args\\n\\n    # Handle special \\'all\\' command\\n    if \\'a\\' in commands:\\n        commands = commands.replace(\\'a\\', \\'tschrmv\\')\\n\\n    # Remove duplicates while preserving order\\n    seen = set()\\n    unique_commands = []\\n    for cmd in commands:\\n        if cmd not in seen:\\n            seen.add(cmd)\\n            unique_commands.append(cmd)\\n    \\n    commands = \\'\\'.join(unique_commands)\\n    \\n    success_count = 0\\n    total_count = 0\\n    \\n    print(f\"[RUN] Prsist Memory: Running {len(commands)} command(s)\")\\n    print(\"-\" * 50)\\n    \\n    for i, cmd in enumerate(commands):\\n        if cmd in COMMAND_MAP:\\n            if i > 0:\\n                print()  # Space between commands\\n            success = COMMAND_MAP[cmd]()\\n            total_count += 1\\n            if success:\\n                success_count += 1\\n        else:\\n            print(f\"[ERROR] Unknown command: -{cmd}\")\\n            total_count += 1\\n    \\n    print(\"-\" * 50)\\n    print(f\"[DONE] {success_count}/{total_count} commands completed successfully\")\\n\\nif __name__ == \"__main__\":\\n    main()', 'structuredPatch': [{'oldStart': 206, 'oldLines': 7, 'newStart': 206, 'newLines': 7, 'lines': ['         ', '         return \"Empty session\"', '     except Exception as e:', '-        logging.debug(f\"Failed to generate session description: {e}\")', '+        print(f\"[DEBUG] Session description error: {e}\")  # Temporary debug', '         return \"Development session\"', ' ', ' ']}], 'userModified': False, 'replaceAll': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Edit",
        "timestamp": "2025-08-24T19:00:23.600901",
        "input_data": {
          "file_path": ".prsist/bin/prsist.py",
          "old_string": "return None\n    except Exception as e:\n        logging.debug(f\"Failed to extract contextual description: {e}\")\n        return None",
          "new_string": "return None\n    except Exception as e:\n        print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug\n        return None"
        },
        "output_data": "{'filePath': '.prsist/bin/prsist.py', 'oldString': '        return None\\n    except Exception as e:\\n        logging.debug(f\"Failed to extract contextual description: {e}\")\\n        return None', 'newString': '        return None\\n    except Exception as e:\\n        print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug\\n        return None', 'originalFile': '#!/usr/bin/env python3\\n\"\"\"\\nPrsist Memory System CLI - Simple, memorable commands\\nUsage: prsist [options]\\n\\nSingle Letter Options:\\n  -t  Test system\\n  -s  Status/session info  \\n  -c  Context (what Claude sees)\\n  -r  Recent sessions\\n  -h  Health check\\n  -f  Feature log (interactive)\\n  -m  Memory stats\\n  -v  Validate system\\n  -p  Project memory operations\\n  -d  Decisions (add decision)\\n  -e  End session\\n  -n  New session (start)\\n  -k  Checkpoint (create)\\n  -x  Export session data\\n  -z  Cleanup old data\\n  -l  List all commands\\n  -a  All checks (equivalent to -tschrmv)\\n  \\nChain commands: prsist -tsc (test + status + context)\\nExamples:\\n  prsist -t        Test system\\n  prsist -h        Health check\\n  prsist -tsc      Test + Status + Context\\n  prsist -a        Run all checks\\n  prsist -hm       Health + Memory stats\\n\"\"\"\\n\\nimport sys\\nimport os\\nimport json\\nimport logging\\nfrom pathlib import Path\\n\\n# Add parent directory to path for imports\\nsys.path.insert(0, str(Path(__file__).parent.parent))\\n\\ndef test_system():\\n    \"\"\"Test complete memory system\"\"\"\\n    print(\"[TEST] Testing Memory System...\")\\n    try:\\n        import subprocess\\n        result = subprocess.run([sys.executable, \"../tests/test_system.py\"], \\n                              capture_output=True, text=True, cwd=Path(__file__).parent)\\n        if result.returncode == 0:\\n            print(\"[PASS] All tests passed!\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Tests failed: {result.stderr}\")\\n            return False\\n    except Exception as e:\\n        print(f\"[ERROR] Test error: {e}\")\\n        return False\\n\\ndef session_status():\\n    \"\"\"Get current session status\"\"\"\\n    print(\"[STATUS] Session Status...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        info = mm.get_session_info()\\n        \\n        if info.get(\"session_id\"):\\n            print(f\"  Active Session: {info[\\'session_id\\'][:8]}...\")\\n            print(f\"  Tools Used: {info.get(\\'tool_usage_count\\', 0)}\")\\n            print(f\"  Files Modified: {info.get(\\'file_interaction_count\\', 0)}\")\\n            print(f\"  Duration: {info.get(\\'duration_minutes\\', 0)} minutes\")\\n        else:\\n            print(\"  No active session\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Status error: {e}\")\\n        return False\\n\\ndef show_context():\\n    \"\"\"Show current context (what Claude sees)\"\"\"\\n    print(\"[CONTEXT] Current Context...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        context = mm.get_session_context()\\n        \\n        if context:\\n            lines = context.split(\\'\\\\n\\')\\n            print(f\"  Context Length: {len(context)} characters\")\\n            print(f\"  Lines: {len(lines)}\")\\n            print(\"  Preview:\")\\n            for i, line in enumerate(lines[:5]):\\n                print(f\"    {line[:70]}{\\'...\\' if len(line) > 70 else \\'\\'}\")\\n            if len(lines) > 5:\\n                print(f\"    ... and {len(lines) - 5} more lines\")\\n        else:\\n            print(\"  No context available\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Context error: {e}\")\\n        return False\\n\\ndef recent_sessions():\\n    \"\"\"Show recent sessions with enhanced descriptions\"\"\"\\n    print(\"[RECENT] Recent Sessions...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        sessions = mm.get_recent_sessions(5)\\n        \\n        if sessions:\\n            # Check for current active session\\n            current_session_id = None\\n            try:\\n                current_context = mm.get_session_context()\\n                current_session_id = current_context.get(\"session_id\")\\n            except:\\n                pass\\n            \\n            for i, session in enumerate(sessions):\\n                # Generate meaningful description\\n                description = generate_session_description(session)\\n                session_id = session.get(\"session_id\", \"Unknown\")\\n                short_id = session_id[:8] if session_id != \"Unknown\" else \"Unknown\"\\n                \\n                if i == 0 and session_id == current_session_id:\\n                    # Current active session - enhanced display\\n                    print(f\"ðŸ”„ Active Session ({short_id})\")\\n                    print(f\"  - Activity: {description}\")\\n                    print(f\"  - Focus: Enhanced session descriptions and memory system improvements\")\\n                    print(f\"  - Status: Currently active\")\\n                    print(\"\")\\n                    print(\"ðŸ“– Previous Sessions:\")\\n                elif i == 0:\\n                    # First session but not current\\n                    print(f\"  - {short_id}: {description}\")\\n                else:\\n                    # Previous sessions\\n                    print(f\"  - {short_id}: {description}\")\\n        else:\\n            print(\"  No recent sessions found\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Recent sessions error: {e}\")\\n        return False\\n\\ndef generate_session_description(session_data):\\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\\n    try:\\n        # Get session details for rich context generation\\n        session_id = session_data.get(\\'session_id\\')\\n        if not session_id:\\n            return \"Unknown session\"\\n            \\n        # Try to load full session data from archived or active sessions\\n        memory_dir = Path(__file__).parent.parent\\n        archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\\n        \\n        full_session_data = None\\n        if archived_file.exists():\\n            with open(archived_file, \\'r\\') as f:\\n                full_session_data = json.load(f)\\n        else:\\n            # Try active session file\\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n            if active_file.exists():\\n                with open(active_file, \\'r\\') as f:\\n                    temp_data = json.load(f)\\n                    if temp_data.get(\\'id\\') == session_id:\\n                        full_session_data = temp_data\\n        \\n        if full_session_data:\\n            # Extract rich context from session data\\n            description = _extract_contextual_description(full_session_data, session_data)\\n            if description:\\n                return description\\n        \\n        # Fallback to enhanced generic descriptions\\n        tool_count = session_data.get(\\'tool_usage_count\\', 0)\\n        file_count = session_data.get(\\'file_interaction_count\\', 0)\\n        tools_used = session_data.get(\\'unique_tools_used\\', [])\\n        \\n        # Generate enhanced descriptions\\n        if file_count > 0 and tool_count > 0:\\n            if \\'Write\\' in tools_used and \\'Edit\\' in tools_used:\\n                return f\"Created and refined {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} ({tool_count} operations)\"\\n            elif \\'Write\\' in tools_used:\\n                return f\"New file development - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} created\"\\n            elif \\'Edit\\' in tools_used or \\'MultiEdit\\' in tools_used:\\n                return f\"Code editing session - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} modified\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Code analysis and exploration ({tool_count} operations)\"\\n        elif tool_count > 15:\\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command-heavy development session ({tool_count} operations)\"\\n        elif tool_count > 5:\\n            if \\'Bash\\' in tools_used:\\n                return f\"Command execution and testing ({tool_count} operations)\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Documentation and code review ({tool_count} operations)\"\\n        elif tool_count > 0:\\n            return f\"Light development work ({tool_count} operations)\"\\n        \\n        return \"Empty session\"\\n    except Exception as e:\\n        print(f\"[DEBUG] Session description error: {e}\")  # Temporary debug\\n        return \"Development session\"\\n\\n\\ndef _extract_contextual_description(full_session_data, session_summary):\\n    \"\"\"Extract meaningful context from full session data\"\"\"\\n    try:\\n        tool_usage = full_session_data.get(\\'tool_usage\\', [])\\n        file_interactions = full_session_data.get(\\'file_interactions\\', [])\\n        \\n        # Extract key information\\n        files_modified = []\\n        files_read = []\\n        commands_run = []\\n        searches_made = []\\n        todos_worked = []\\n        \\n        # Analyze tool usage for context\\n        for tool in tool_usage:\\n            tool_name = tool.get(\\'tool_name\\', \\'\\')\\n            input_data = tool.get(\\'input_data\\', {})\\n            \\n            if tool_name in [\\'Edit\\', \\'MultiEdit\\', \\'Write\\']:\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_modified.append(Path(file_path).name)\\n            elif tool_name == \\'Read\\':\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_read.append(Path(file_path).name)\\n            elif tool_name == \\'Bash\\':\\n                command = input_data.get(\\'command\\', \\'\\')\\n                if command:\\n                    commands_run.append(command)\\n            elif tool_name == \\'WebSearch\\':\\n                query = input_data.get(\\'query\\', \\'\\')\\n                if query:\\n                    searches_made.append(query)\\n            elif tool_name == \\'TodoWrite\\':\\n                todos = input_data.get(\\'todos\\', [])\\n                for todo in todos:\\n                    content = todo.get(\\'content\\', \\'\\')\\n                    if content and content not in todos_worked:\\n                        todos_worked.append(content)\\n        \\n        # Generate contextual description based on extracted data\\n        description_parts = []\\n        \\n        # Main activity identification\\n        if searches_made:\\n            for query in searches_made[:1]:  # Focus on first search\\n                if \\'mcp\\' in query.lower() or \\'context7\\' in query.lower():\\n                    description_parts.append(\"Researched and integrated Context7 MCP server\")\\n                    break\\n                elif \\'memory\\' in query.lower():\\n                    description_parts.append(\"Researched memory system implementation\")\\n                    break\\n                else:\\n                    description_parts.append(f\"Researched {query[:50]}\")\\n                    break\\n        \\n        if todos_worked:\\n            todo_descriptions = []\\n            for todo in todos_worked[:2]:  # Show first 2 todos\\n                if \\'mcp\\' in todo.lower() or \\'context7\\' in todo.lower():\\n                    todo_descriptions.append(\"MCP server setup\")\\n                elif \\'enhance\\' in todo.lower() or \\'improve\\' in todo.lower():\\n                    todo_descriptions.append(\"system improvements\")\\n                else:\\n                    todo_descriptions.append(todo[:30])\\n            \\n            if not description_parts:  # Only if no search activity found\\n                description_parts.append(f\"Worked on: {\\', \\'.join(todo_descriptions)}\")\\n        \\n        # File modification context\\n        if files_modified:\\n            unique_files = list(dict.fromkeys(files_modified))  # Remove duplicates\\n            if len(unique_files) == 1:\\n                file_name = unique_files[0]\\n                if \\'activity_analyzer\\' in file_name:\\n                    description_parts.append(f\"Enhanced session analysis in {file_name}\")\\n                elif \\'prsist\\' in file_name:\\n                    description_parts.append(f\"Improved memory CLI in {file_name}\")\\n                elif \\'memory\\' in file_name or \\'session\\' in file_name:\\n                    description_parts.append(f\"Updated memory system in {file_name}\")\\n                else:\\n                    description_parts.append(f\"Modified {file_name}\")\\n            elif len(unique_files) <= 3:\\n                description_parts.append(f\"Modified {\\', \\'.join(unique_files[:2])} + {len(unique_files)-2} more files\" if len(unique_files) > 2 else f\"Modified {\\', \\'.join(unique_files)}\")\\n            else:\\n                description_parts.append(f\"Modified {len(unique_files)} files including {\\', \\'.join(unique_files[:2])}\")\\n        \\n        # Command execution context\\n        if commands_run and not description_parts:\\n            command_contexts = []\\n            for cmd in commands_run[:3]:  # Look at first 3 commands\\n                if \\'mcp add\\' in cmd:\\n                    command_contexts.append(\"MCP server installation\")\\n                elif \\'mem\\' in cmd and \\'recent\\' in cmd:\\n                    command_contexts.append(\"memory system testing\")\\n                elif \\'python\\' in cmd and \\'prsist\\' in cmd:\\n                    command_contexts.append(\"memory CLI validation\")\\n                elif \\'npm\\' in cmd or \\'npx\\' in cmd:\\n                    command_contexts.append(\"package management\")\\n            \\n            if command_contexts:\\n                description_parts.append(\\', \\'.join(dict.fromkeys(command_contexts)))  # Remove duplicates\\n        \\n        # File reading context (only if no modifications)\\n        if files_read and not files_modified and not description_parts:\\n            unique_read = list(dict.fromkeys(files_read))\\n            if len(unique_read) == 1:\\n                description_parts.append(f\"Analyzed {unique_read[0]}\")\\n            elif len(unique_read) <= 3:\\n                description_parts.append(f\"Reviewed {\\', \\'.join(unique_read)}\")\\n            else:\\n                description_parts.append(f\"Explored {len(unique_read)} files\")\\n        \\n        # Combine description parts\\n        if description_parts:\\n            main_description = description_parts[0]\\n            \\n            # Add file context if not already included\\n            if files_modified and \\'Modified\\' not in main_description and \\'Enhanced\\' not in main_description:\\n                if len(files_modified) == 1:\\n                    main_description += f\" - modified {files_modified[0]}\"\\n                elif len(files_modified) <= 3:\\n                    main_description += f\" - modified {len(files_modified)} files\"\\n            \\n            return main_description\\n        \\n        return None\\n    except Exception as e:\\n        logging.debug(f\"Failed to extract contextual description: {e}\")\\n        return None\\n\\ndef health_check():\\n    \"\"\"System health check\"\"\"\\n    print(\"[HEALTH] Health Check...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        if validation[\"valid\"]:\\n            print(\"[PASS] System healthy\")\\n        else:\\n            print(\"[WARN] System issues found:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Health check error: {e}\")\\n        return False\\n\\ndef feature_log():\\n    \"\"\"Interactive feature logging\"\"\"\\n    print(\"[FEATURE] Feature Logging...\")\\n    try:\\n        feature_name = input(\"Feature name: \").strip()\\n        if not feature_name:\\n            print(\"[ERROR] Feature name required\")\\n            return False\\n            \\n        description = input(\"Description (optional): \").strip()\\n        \\n        import subprocess\\n        cmd = [sys.executable, \"hooks/FeatureComplete.py\", feature_name]\\n        if description:\\n            cmd.append(description)\\n            \\n        result = subprocess.run(cmd, capture_output=True, text=True, cwd=Path(__file__).parent)\\n        \\n        if result.returncode == 0:\\n            print(f\"[PASS] Feature \\'{feature_name}\\' logged successfully\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Feature logging failed: {result.stderr}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Feature logging cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Feature logging error: {e}\")\\n        return False\\n\\ndef memory_stats():\\n    \"\"\"Show memory system statistics\"\"\"\\n    print(\"[STATS] Memory Stats...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        stats = mm.get_memory_stats()\\n        \\n        print(f\"  Total Sessions: {stats.get(\\'total_sessions\\', 0)}\")\\n        print(f\"  Database Size: {stats.get(\\'database_size_mb\\', 0)} MB\")\\n        print(f\"  Active Session: {stats.get(\\'active_session\\', \\'None\\')}\")\\n        print(f\"  Project Root: {stats.get(\\'project_root\\', \\'Unknown\\')}\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Memory stats error: {e}\")\\n        return False\\n\\ndef validate_system():\\n    \"\"\"Validate system integrity\"\"\"\\n    print(\"[VALIDATE] System Validation...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        print(f\"  System Valid: {validation[\\'valid\\']}\")\\n        if not validation[\"valid\"]:\\n            print(\"  Issues:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Validation error: {e}\")\\n        return False\\n\\ndef project_memory():\\n    \"\"\"Add to project memory\"\"\"\\n    print(\"[PROJECT] Project Memory...\")\\n    try:\\n        content = input(\"Enter information to add to project memory: \").strip()\\n        if not content:\\n            print(\"[ERROR] Content required\")\\n            return False\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_project_memory(content)\\n        \\n        if success:\\n            print(f\"[PASS] Project memory updated\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to update project memory\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Project memory update cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Project memory error: {e}\")\\n        return False\\n\\ndef add_decision():\\n    \"\"\"Add a decision record\"\"\"\\n    print(\"[DECISION] Add Decision...\")\\n    try:\\n        title = input(\"Decision title: \").strip()\\n        if not title:\\n            print(\"[ERROR] Decision title required\")\\n            return False\\n            \\n        description = input(\"Description: \").strip()\\n        if not description:\\n            print(\"[ERROR] Description required\")\\n            return False\\n            \\n        category = input(\"Category (architecture/technical/process/design): \").strip()\\n        if not category:\\n            category = \"general\"\\n            \\n        impact = input(\"Impact (low/medium/high/critical): \").strip()\\n        if not impact:\\n            impact = \"medium\"\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_decision(title, description, category, impact)\\n        \\n        if success:\\n            print(f\"[PASS] Decision \\'{title}\\' recorded\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to record decision\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Decision recording cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Decision recording error: {e}\")\\n        return False\\n\\ndef end_session():\\n    \"\"\"End current session\"\"\"\\n    print(\"[END] Ending Session...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.end_session(archive=True)\\n        \\n        if result:\\n            print(\"[PASS] Session ended and archived\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to end\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] End session error: {e}\")\\n        return False\\n\\ndef new_session():\\n    \"\"\"Start new session\"\"\"\\n    print(\"[NEW] Starting New Session...\")\\n    try:\\n        context = input(\"Session context (optional): \").strip()\\n        \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        \\n        session_data = {}\\n        if context:\\n            session_data[\"context\"] = context\\n            \\n        result = mm.start_session(session_data)\\n        \\n        if result.get(\"memory_system_active\"):\\n            session_id = result.get(\"session_id\", \"unknown\")\\n            print(f\"[PASS] New session started: {session_id[:8]}...\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Failed to start session: {result.get(\\'error\\', \\'Unknown error\\')}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Session start cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] New session error: {e}\")\\n        return False\\n\\ndef create_checkpoint():\\n    \"\"\"Create a checkpoint\"\"\"\\n    print(\"[CHECKPOINT] Creating Checkpoint...\")\\n    try:\\n        name = input(\"Checkpoint name (optional): \").strip()\\n        if not name:\\n            name = None\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.create_checkpoint(name)\\n        \\n        if result:\\n            print(f\"[PASS] Checkpoint created: {name or \\'auto\\'}\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to create checkpoint\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Checkpoint creation cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Checkpoint error: {e}\")\\n        return False\\n\\ndef export_session():\\n    \"\"\"Export current session data\"\"\"\\n    print(\"[EXPORT] Exporting Session Data...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        data = mm.export_session_data(format=\"json\")\\n        \\n        if data:\\n            filename = f\"session_export_{mm.get_session_info().get(\\'session_id\\', \\'unknown\\')[:8]}.json\"\\n            with open(filename, \\'w\\') as f:\\n                f.write(data)\\n            print(f\"[PASS] Session exported to {filename}\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to export\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] Export error: {e}\")\\n        return False\\n\\ndef cleanup_data():\\n    \"\"\"Clean up old data\"\"\"\\n    print(\"[CLEANUP] Cleaning Up Old Data...\")\\n    try:\\n        days = input(\"Retention days (default 30): \").strip()\\n        if not days:\\n            days = 30\\n        else:\\n            days = int(days)\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.cleanup_old_data(retention_days=days)\\n        \\n        print(f\"[PASS] Cleanup completed: {result}\")\\n        return True\\n    except ValueError:\\n        print(\"[ERROR] Invalid number of days\")\\n        return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Cleanup cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Cleanup error: {e}\")\\n        return False\\n\\ndef list_commands():\\n    \"\"\"List all available commands\"\"\"\\n    print(\"[HELP] Prsist Memory System Commands:\")\\n    print(\"\\\\n  Core Operations:\")\\n    print(\"  -t  Test system\")\\n    print(\"  -s  Status/session info\")\\n    print(\"  -c  Context (what Claude sees)\")\\n    print(\"  -r  Recent sessions\")\\n    print(\"  -h  Health check\")\\n    print(\"  -m  Memory stats\")\\n    print(\"  -v  Validate system\")\\n    print(\"\\\\n  Session Management:\")\\n    print(\"  -n  New session (start)\")\\n    print(\"  -e  End session\")\\n    print(\"  -k  Checkpoint (create)\")\\n    print(\"  -x  Export session data\")\\n    print(\"\\\\n  Data Management:\")\\n    print(\"  -f  Feature log (interactive)\")\\n    print(\"  -p  Project memory (add)\")\\n    print(\"  -d  Decisions (add decision)\")\\n    print(\"  -z  Cleanup old data\")\\n    print(\"\\\\n  Shortcuts:\")\\n    print(\"  -a  All core checks (equivalent to -tschrmv)\")\\n    print(\"  -l  List commands (this help)\")\\n    print(\"\\\\nExamples:\")\\n    print(\"  prsist -t      (test system)\")\\n    print(\"  prsist -hm     (health + memory stats)\")\\n    print(\"  prsist -tsc    (test + status + context)\")\\n    print(\"  prsist -a      (run all core checks)\")\\n    print(\"  prsist -nf     (new session + feature log)\")\\n    return True\\n\\n# Command mapping\\nCOMMAND_MAP = {\\n    \\'t\\': test_system,\\n    \\'s\\': session_status,\\n    \\'c\\': show_context,\\n    \\'r\\': recent_sessions,\\n    \\'h\\': health_check,\\n    \\'f\\': feature_log,\\n    \\'m\\': memory_stats,\\n    \\'v\\': validate_system,\\n    \\'p\\': project_memory,\\n    \\'d\\': add_decision,\\n    \\'e\\': end_session,\\n    \\'n\\': new_session,\\n    \\'k\\': create_checkpoint,\\n    \\'x\\': export_session,\\n    \\'z\\': cleanup_data,\\n    \\'l\\': list_commands\\n}\\n\\ndef main():\\n    # Custom argument parser that handles combined flags like -tsc\\n    if len(sys.argv) < 2:\\n        print(\"Prsist Memory System CLI\")\\n        print(\"Usage: prsist [options]\")\\n        print(\"Example: prsist -t       (test)\")\\n        print(\"Example: prsist -tsc     (test + status + context)\")\\n        print(\"Example: prsist -a       (all checks)\")\\n        print(\"Use \\'prsist -l\\' to list all commands\")\\n        return\\n\\n    # Parse arguments manually to handle combined flags\\n    args = sys.argv[1]\\n    if args.startswith(\\'-\\'):\\n        commands = args[1:]  # Remove the dash\\n    else:\\n        commands = args\\n\\n    # Handle special \\'all\\' command\\n    if \\'a\\' in commands:\\n        commands = commands.replace(\\'a\\', \\'tschrmv\\')\\n\\n    # Remove duplicates while preserving order\\n    seen = set()\\n    unique_commands = []\\n    for cmd in commands:\\n        if cmd not in seen:\\n            seen.add(cmd)\\n            unique_commands.append(cmd)\\n    \\n    commands = \\'\\'.join(unique_commands)\\n    \\n    success_count = 0\\n    total_count = 0\\n    \\n    print(f\"[RUN] Prsist Memory: Running {len(commands)} command(s)\")\\n    print(\"-\" * 50)\\n    \\n    for i, cmd in enumerate(commands):\\n        if cmd in COMMAND_MAP:\\n            if i > 0:\\n                print()  # Space between commands\\n            success = COMMAND_MAP[cmd]()\\n            total_count += 1\\n            if success:\\n                success_count += 1\\n        else:\\n            print(f\"[ERROR] Unknown command: -{cmd}\")\\n            total_count += 1\\n    \\n    print(\"-\" * 50)\\n    print(f\"[DONE] {success_count}/{total_count} commands completed successfully\")\\n\\nif __name__ == \"__main__\":\\n    main()', 'structuredPatch': [{'oldStart': 339, 'oldLines': 7, 'newStart': 339, 'newLines': 7, 'lines': ['         ', '         return None', '     except Exception as e:', '-        logging.debug(f\"Failed to extract contextual description: {e}\")', '+        print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug', '         return None', ' ', ' def health_check():']}], 'userModified': False, 'replaceAll': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Edit",
        "timestamp": "2025-08-24T19:00:23.961713",
        "input_data": {
          "file_path": ".prsist/bin/prsist.py",
          "old_string": "return None\n    except Exception as e:\n        logging.debug(f\"Failed to extract contextual description: {e}\")\n        return None",
          "new_string": "return None\n    except Exception as e:\n        print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug\n        return None"
        },
        "output_data": "{'filePath': '.prsist/bin/prsist.py', 'oldString': '        return None\\n    except Exception as e:\\n        logging.debug(f\"Failed to extract contextual description: {e}\")\\n        return None', 'newString': '        return None\\n    except Exception as e:\\n        print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug\\n        return None', 'originalFile': '#!/usr/bin/env python3\\n\"\"\"\\nPrsist Memory System CLI - Simple, memorable commands\\nUsage: prsist [options]\\n\\nSingle Letter Options:\\n  -t  Test system\\n  -s  Status/session info  \\n  -c  Context (what Claude sees)\\n  -r  Recent sessions\\n  -h  Health check\\n  -f  Feature log (interactive)\\n  -m  Memory stats\\n  -v  Validate system\\n  -p  Project memory operations\\n  -d  Decisions (add decision)\\n  -e  End session\\n  -n  New session (start)\\n  -k  Checkpoint (create)\\n  -x  Export session data\\n  -z  Cleanup old data\\n  -l  List all commands\\n  -a  All checks (equivalent to -tschrmv)\\n  \\nChain commands: prsist -tsc (test + status + context)\\nExamples:\\n  prsist -t        Test system\\n  prsist -h        Health check\\n  prsist -tsc      Test + Status + Context\\n  prsist -a        Run all checks\\n  prsist -hm       Health + Memory stats\\n\"\"\"\\n\\nimport sys\\nimport os\\nimport json\\nimport logging\\nfrom pathlib import Path\\n\\n# Add parent directory to path for imports\\nsys.path.insert(0, str(Path(__file__).parent.parent))\\n\\ndef test_system():\\n    \"\"\"Test complete memory system\"\"\"\\n    print(\"[TEST] Testing Memory System...\")\\n    try:\\n        import subprocess\\n        result = subprocess.run([sys.executable, \"../tests/test_system.py\"], \\n                              capture_output=True, text=True, cwd=Path(__file__).parent)\\n        if result.returncode == 0:\\n            print(\"[PASS] All tests passed!\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Tests failed: {result.stderr}\")\\n            return False\\n    except Exception as e:\\n        print(f\"[ERROR] Test error: {e}\")\\n        return False\\n\\ndef session_status():\\n    \"\"\"Get current session status\"\"\"\\n    print(\"[STATUS] Session Status...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        info = mm.get_session_info()\\n        \\n        if info.get(\"session_id\"):\\n            print(f\"  Active Session: {info[\\'session_id\\'][:8]}...\")\\n            print(f\"  Tools Used: {info.get(\\'tool_usage_count\\', 0)}\")\\n            print(f\"  Files Modified: {info.get(\\'file_interaction_count\\', 0)}\")\\n            print(f\"  Duration: {info.get(\\'duration_minutes\\', 0)} minutes\")\\n        else:\\n            print(\"  No active session\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Status error: {e}\")\\n        return False\\n\\ndef show_context():\\n    \"\"\"Show current context (what Claude sees)\"\"\"\\n    print(\"[CONTEXT] Current Context...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        context = mm.get_session_context()\\n        \\n        if context:\\n            lines = context.split(\\'\\\\n\\')\\n            print(f\"  Context Length: {len(context)} characters\")\\n            print(f\"  Lines: {len(lines)}\")\\n            print(\"  Preview:\")\\n            for i, line in enumerate(lines[:5]):\\n                print(f\"    {line[:70]}{\\'...\\' if len(line) > 70 else \\'\\'}\")\\n            if len(lines) > 5:\\n                print(f\"    ... and {len(lines) - 5} more lines\")\\n        else:\\n            print(\"  No context available\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Context error: {e}\")\\n        return False\\n\\ndef recent_sessions():\\n    \"\"\"Show recent sessions with enhanced descriptions\"\"\"\\n    print(\"[RECENT] Recent Sessions...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        sessions = mm.get_recent_sessions(5)\\n        \\n        if sessions:\\n            # Check for current active session\\n            current_session_id = None\\n            try:\\n                current_context = mm.get_session_context()\\n                current_session_id = current_context.get(\"session_id\")\\n            except:\\n                pass\\n            \\n            for i, session in enumerate(sessions):\\n                # Generate meaningful description\\n                description = generate_session_description(session)\\n                session_id = session.get(\"session_id\", \"Unknown\")\\n                short_id = session_id[:8] if session_id != \"Unknown\" else \"Unknown\"\\n                \\n                if i == 0 and session_id == current_session_id:\\n                    # Current active session - enhanced display\\n                    print(f\"ðŸ”„ Active Session ({short_id})\")\\n                    print(f\"  - Activity: {description}\")\\n                    print(f\"  - Focus: Enhanced session descriptions and memory system improvements\")\\n                    print(f\"  - Status: Currently active\")\\n                    print(\"\")\\n                    print(\"ðŸ“– Previous Sessions:\")\\n                elif i == 0:\\n                    # First session but not current\\n                    print(f\"  - {short_id}: {description}\")\\n                else:\\n                    # Previous sessions\\n                    print(f\"  - {short_id}: {description}\")\\n        else:\\n            print(\"  No recent sessions found\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Recent sessions error: {e}\")\\n        return False\\n\\ndef generate_session_description(session_data):\\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\\n    try:\\n        # Get session details for rich context generation\\n        session_id = session_data.get(\\'session_id\\')\\n        if not session_id:\\n            return \"Unknown session\"\\n            \\n        # Try to load full session data from archived or active sessions\\n        memory_dir = Path(__file__).parent.parent\\n        archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\\n        \\n        full_session_data = None\\n        if archived_file.exists():\\n            with open(archived_file, \\'r\\') as f:\\n                full_session_data = json.load(f)\\n        else:\\n            # Try active session file\\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n            if active_file.exists():\\n                with open(active_file, \\'r\\') as f:\\n                    temp_data = json.load(f)\\n                    if temp_data.get(\\'id\\') == session_id:\\n                        full_session_data = temp_data\\n        \\n        if full_session_data:\\n            # Extract rich context from session data\\n            description = _extract_contextual_description(full_session_data, session_data)\\n            if description:\\n                return description\\n        \\n        # Fallback to enhanced generic descriptions\\n        tool_count = session_data.get(\\'tool_usage_count\\', 0)\\n        file_count = session_data.get(\\'file_interaction_count\\', 0)\\n        tools_used = session_data.get(\\'unique_tools_used\\', [])\\n        \\n        # Generate enhanced descriptions\\n        if file_count > 0 and tool_count > 0:\\n            if \\'Write\\' in tools_used and \\'Edit\\' in tools_used:\\n                return f\"Created and refined {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} ({tool_count} operations)\"\\n            elif \\'Write\\' in tools_used:\\n                return f\"New file development - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} created\"\\n            elif \\'Edit\\' in tools_used or \\'MultiEdit\\' in tools_used:\\n                return f\"Code editing session - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} modified\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Code analysis and exploration ({tool_count} operations)\"\\n        elif tool_count > 15:\\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command-heavy development session ({tool_count} operations)\"\\n        elif tool_count > 5:\\n            if \\'Bash\\' in tools_used:\\n                return f\"Command execution and testing ({tool_count} operations)\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Documentation and code review ({tool_count} operations)\"\\n        elif tool_count > 0:\\n            return f\"Light development work ({tool_count} operations)\"\\n        \\n        return \"Empty session\"\\n    except Exception as e:\\n        print(f\"[DEBUG] Session description error: {e}\")  # Temporary debug\\n        return \"Development session\"\\n\\n\\ndef _extract_contextual_description(full_session_data, session_summary):\\n    \"\"\"Extract meaningful context from full session data\"\"\"\\n    try:\\n        tool_usage = full_session_data.get(\\'tool_usage\\', [])\\n        file_interactions = full_session_data.get(\\'file_interactions\\', [])\\n        \\n        # Extract key information\\n        files_modified = []\\n        files_read = []\\n        commands_run = []\\n        searches_made = []\\n        todos_worked = []\\n        \\n        # Analyze tool usage for context\\n        for tool in tool_usage:\\n            tool_name = tool.get(\\'tool_name\\', \\'\\')\\n            input_data = tool.get(\\'input_data\\', {})\\n            \\n            if tool_name in [\\'Edit\\', \\'MultiEdit\\', \\'Write\\']:\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_modified.append(Path(file_path).name)\\n            elif tool_name == \\'Read\\':\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_read.append(Path(file_path).name)\\n            elif tool_name == \\'Bash\\':\\n                command = input_data.get(\\'command\\', \\'\\')\\n                if command:\\n                    commands_run.append(command)\\n            elif tool_name == \\'WebSearch\\':\\n                query = input_data.get(\\'query\\', \\'\\')\\n                if query:\\n                    searches_made.append(query)\\n            elif tool_name == \\'TodoWrite\\':\\n                todos = input_data.get(\\'todos\\', [])\\n                for todo in todos:\\n                    content = todo.get(\\'content\\', \\'\\')\\n                    if content and content not in todos_worked:\\n                        todos_worked.append(content)\\n        \\n        # Generate contextual description based on extracted data\\n        description_parts = []\\n        \\n        # Main activity identification\\n        if searches_made:\\n            for query in searches_made[:1]:  # Focus on first search\\n                if \\'mcp\\' in query.lower() or \\'context7\\' in query.lower():\\n                    description_parts.append(\"Researched and integrated Context7 MCP server\")\\n                    break\\n                elif \\'memory\\' in query.lower():\\n                    description_parts.append(\"Researched memory system implementation\")\\n                    break\\n                else:\\n                    description_parts.append(f\"Researched {query[:50]}\")\\n                    break\\n        \\n        if todos_worked:\\n            todo_descriptions = []\\n            for todo in todos_worked[:2]:  # Show first 2 todos\\n                if \\'mcp\\' in todo.lower() or \\'context7\\' in todo.lower():\\n                    todo_descriptions.append(\"MCP server setup\")\\n                elif \\'enhance\\' in todo.lower() or \\'improve\\' in todo.lower():\\n                    todo_descriptions.append(\"system improvements\")\\n                else:\\n                    todo_descriptions.append(todo[:30])\\n            \\n            if not description_parts:  # Only if no search activity found\\n                description_parts.append(f\"Worked on: {\\', \\'.join(todo_descriptions)}\")\\n        \\n        # File modification context\\n        if files_modified:\\n            unique_files = list(dict.fromkeys(files_modified))  # Remove duplicates\\n            if len(unique_files) == 1:\\n                file_name = unique_files[0]\\n                if \\'activity_analyzer\\' in file_name:\\n                    description_parts.append(f\"Enhanced session analysis in {file_name}\")\\n                elif \\'prsist\\' in file_name:\\n                    description_parts.append(f\"Improved memory CLI in {file_name}\")\\n                elif \\'memory\\' in file_name or \\'session\\' in file_name:\\n                    description_parts.append(f\"Updated memory system in {file_name}\")\\n                else:\\n                    description_parts.append(f\"Modified {file_name}\")\\n            elif len(unique_files) <= 3:\\n                description_parts.append(f\"Modified {\\', \\'.join(unique_files[:2])} + {len(unique_files)-2} more files\" if len(unique_files) > 2 else f\"Modified {\\', \\'.join(unique_files)}\")\\n            else:\\n                description_parts.append(f\"Modified {len(unique_files)} files including {\\', \\'.join(unique_files[:2])}\")\\n        \\n        # Command execution context\\n        if commands_run and not description_parts:\\n            command_contexts = []\\n            for cmd in commands_run[:3]:  # Look at first 3 commands\\n                if \\'mcp add\\' in cmd:\\n                    command_contexts.append(\"MCP server installation\")\\n                elif \\'mem\\' in cmd and \\'recent\\' in cmd:\\n                    command_contexts.append(\"memory system testing\")\\n                elif \\'python\\' in cmd and \\'prsist\\' in cmd:\\n                    command_contexts.append(\"memory CLI validation\")\\n                elif \\'npm\\' in cmd or \\'npx\\' in cmd:\\n                    command_contexts.append(\"package management\")\\n            \\n            if command_contexts:\\n                description_parts.append(\\', \\'.join(dict.fromkeys(command_contexts)))  # Remove duplicates\\n        \\n        # File reading context (only if no modifications)\\n        if files_read and not files_modified and not description_parts:\\n            unique_read = list(dict.fromkeys(files_read))\\n            if len(unique_read) == 1:\\n                description_parts.append(f\"Analyzed {unique_read[0]}\")\\n            elif len(unique_read) <= 3:\\n                description_parts.append(f\"Reviewed {\\', \\'.join(unique_read)}\")\\n            else:\\n                description_parts.append(f\"Explored {len(unique_read)} files\")\\n        \\n        # Combine description parts\\n        if description_parts:\\n            main_description = description_parts[0]\\n            \\n            # Add file context if not already included\\n            if files_modified and \\'Modified\\' not in main_description and \\'Enhanced\\' not in main_description:\\n                if len(files_modified) == 1:\\n                    main_description += f\" - modified {files_modified[0]}\"\\n                elif len(files_modified) <= 3:\\n                    main_description += f\" - modified {len(files_modified)} files\"\\n            \\n            return main_description\\n        \\n        return None\\n    except Exception as e:\\n        logging.debug(f\"Failed to extract contextual description: {e}\")\\n        return None\\n\\ndef health_check():\\n    \"\"\"System health check\"\"\"\\n    print(\"[HEALTH] Health Check...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        if validation[\"valid\"]:\\n            print(\"[PASS] System healthy\")\\n        else:\\n            print(\"[WARN] System issues found:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Health check error: {e}\")\\n        return False\\n\\ndef feature_log():\\n    \"\"\"Interactive feature logging\"\"\"\\n    print(\"[FEATURE] Feature Logging...\")\\n    try:\\n        feature_name = input(\"Feature name: \").strip()\\n        if not feature_name:\\n            print(\"[ERROR] Feature name required\")\\n            return False\\n            \\n        description = input(\"Description (optional): \").strip()\\n        \\n        import subprocess\\n        cmd = [sys.executable, \"hooks/FeatureComplete.py\", feature_name]\\n        if description:\\n            cmd.append(description)\\n            \\n        result = subprocess.run(cmd, capture_output=True, text=True, cwd=Path(__file__).parent)\\n        \\n        if result.returncode == 0:\\n            print(f\"[PASS] Feature \\'{feature_name}\\' logged successfully\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Feature logging failed: {result.stderr}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Feature logging cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Feature logging error: {e}\")\\n        return False\\n\\ndef memory_stats():\\n    \"\"\"Show memory system statistics\"\"\"\\n    print(\"[STATS] Memory Stats...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        stats = mm.get_memory_stats()\\n        \\n        print(f\"  Total Sessions: {stats.get(\\'total_sessions\\', 0)}\")\\n        print(f\"  Database Size: {stats.get(\\'database_size_mb\\', 0)} MB\")\\n        print(f\"  Active Session: {stats.get(\\'active_session\\', \\'None\\')}\")\\n        print(f\"  Project Root: {stats.get(\\'project_root\\', \\'Unknown\\')}\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Memory stats error: {e}\")\\n        return False\\n\\ndef validate_system():\\n    \"\"\"Validate system integrity\"\"\"\\n    print(\"[VALIDATE] System Validation...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        print(f\"  System Valid: {validation[\\'valid\\']}\")\\n        if not validation[\"valid\"]:\\n            print(\"  Issues:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Validation error: {e}\")\\n        return False\\n\\ndef project_memory():\\n    \"\"\"Add to project memory\"\"\"\\n    print(\"[PROJECT] Project Memory...\")\\n    try:\\n        content = input(\"Enter information to add to project memory: \").strip()\\n        if not content:\\n            print(\"[ERROR] Content required\")\\n            return False\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_project_memory(content)\\n        \\n        if success:\\n            print(f\"[PASS] Project memory updated\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to update project memory\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Project memory update cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Project memory error: {e}\")\\n        return False\\n\\ndef add_decision():\\n    \"\"\"Add a decision record\"\"\"\\n    print(\"[DECISION] Add Decision...\")\\n    try:\\n        title = input(\"Decision title: \").strip()\\n        if not title:\\n            print(\"[ERROR] Decision title required\")\\n            return False\\n            \\n        description = input(\"Description: \").strip()\\n        if not description:\\n            print(\"[ERROR] Description required\")\\n            return False\\n            \\n        category = input(\"Category (architecture/technical/process/design): \").strip()\\n        if not category:\\n            category = \"general\"\\n            \\n        impact = input(\"Impact (low/medium/high/critical): \").strip()\\n        if not impact:\\n            impact = \"medium\"\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_decision(title, description, category, impact)\\n        \\n        if success:\\n            print(f\"[PASS] Decision \\'{title}\\' recorded\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to record decision\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Decision recording cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Decision recording error: {e}\")\\n        return False\\n\\ndef end_session():\\n    \"\"\"End current session\"\"\"\\n    print(\"[END] Ending Session...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.end_session(archive=True)\\n        \\n        if result:\\n            print(\"[PASS] Session ended and archived\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to end\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] End session error: {e}\")\\n        return False\\n\\ndef new_session():\\n    \"\"\"Start new session\"\"\"\\n    print(\"[NEW] Starting New Session...\")\\n    try:\\n        context = input(\"Session context (optional): \").strip()\\n        \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        \\n        session_data = {}\\n        if context:\\n            session_data[\"context\"] = context\\n            \\n        result = mm.start_session(session_data)\\n        \\n        if result.get(\"memory_system_active\"):\\n            session_id = result.get(\"session_id\", \"unknown\")\\n            print(f\"[PASS] New session started: {session_id[:8]}...\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Failed to start session: {result.get(\\'error\\', \\'Unknown error\\')}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Session start cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] New session error: {e}\")\\n        return False\\n\\ndef create_checkpoint():\\n    \"\"\"Create a checkpoint\"\"\"\\n    print(\"[CHECKPOINT] Creating Checkpoint...\")\\n    try:\\n        name = input(\"Checkpoint name (optional): \").strip()\\n        if not name:\\n            name = None\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.create_checkpoint(name)\\n        \\n        if result:\\n            print(f\"[PASS] Checkpoint created: {name or \\'auto\\'}\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to create checkpoint\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Checkpoint creation cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Checkpoint error: {e}\")\\n        return False\\n\\ndef export_session():\\n    \"\"\"Export current session data\"\"\"\\n    print(\"[EXPORT] Exporting Session Data...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        data = mm.export_session_data(format=\"json\")\\n        \\n        if data:\\n            filename = f\"session_export_{mm.get_session_info().get(\\'session_id\\', \\'unknown\\')[:8]}.json\"\\n            with open(filename, \\'w\\') as f:\\n                f.write(data)\\n            print(f\"[PASS] Session exported to {filename}\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to export\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] Export error: {e}\")\\n        return False\\n\\ndef cleanup_data():\\n    \"\"\"Clean up old data\"\"\"\\n    print(\"[CLEANUP] Cleaning Up Old Data...\")\\n    try:\\n        days = input(\"Retention days (default 30): \").strip()\\n        if not days:\\n            days = 30\\n        else:\\n            days = int(days)\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.cleanup_old_data(retention_days=days)\\n        \\n        print(f\"[PASS] Cleanup completed: {result}\")\\n        return True\\n    except ValueError:\\n        print(\"[ERROR] Invalid number of days\")\\n        return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Cleanup cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Cleanup error: {e}\")\\n        return False\\n\\ndef list_commands():\\n    \"\"\"List all available commands\"\"\"\\n    print(\"[HELP] Prsist Memory System Commands:\")\\n    print(\"\\\\n  Core Operations:\")\\n    print(\"  -t  Test system\")\\n    print(\"  -s  Status/session info\")\\n    print(\"  -c  Context (what Claude sees)\")\\n    print(\"  -r  Recent sessions\")\\n    print(\"  -h  Health check\")\\n    print(\"  -m  Memory stats\")\\n    print(\"  -v  Validate system\")\\n    print(\"\\\\n  Session Management:\")\\n    print(\"  -n  New session (start)\")\\n    print(\"  -e  End session\")\\n    print(\"  -k  Checkpoint (create)\")\\n    print(\"  -x  Export session data\")\\n    print(\"\\\\n  Data Management:\")\\n    print(\"  -f  Feature log (interactive)\")\\n    print(\"  -p  Project memory (add)\")\\n    print(\"  -d  Decisions (add decision)\")\\n    print(\"  -z  Cleanup old data\")\\n    print(\"\\\\n  Shortcuts:\")\\n    print(\"  -a  All core checks (equivalent to -tschrmv)\")\\n    print(\"  -l  List commands (this help)\")\\n    print(\"\\\\nExamples:\")\\n    print(\"  prsist -t      (test system)\")\\n    print(\"  prsist -hm     (health + memory stats)\")\\n    print(\"  prsist -tsc    (test + status + context)\")\\n    print(\"  prsist -a      (run all core checks)\")\\n    print(\"  prsist -nf     (new session + feature log)\")\\n    return True\\n\\n# Command mapping\\nCOMMAND_MAP = {\\n    \\'t\\': test_system,\\n    \\'s\\': session_status,\\n    \\'c\\': show_context,\\n    \\'r\\': recent_sessions,\\n    \\'h\\': health_check,\\n    \\'f\\': feature_log,\\n    \\'m\\': memory_stats,\\n    \\'v\\': validate_system,\\n    \\'p\\': project_memory,\\n    \\'d\\': add_decision,\\n    \\'e\\': end_session,\\n    \\'n\\': new_session,\\n    \\'k\\': create_checkpoint,\\n    \\'x\\': export_session,\\n    \\'z\\': cleanup_data,\\n    \\'l\\': list_commands\\n}\\n\\ndef main():\\n    # Custom argument parser that handles combined flags like -tsc\\n    if len(sys.argv) < 2:\\n        print(\"Prsist Memory System CLI\")\\n        print(\"Usage: prsist [options]\")\\n        print(\"Example: prsist -t       (test)\")\\n        print(\"Example: prsist -tsc     (test + status + context)\")\\n        print(\"Example: prsist -a       (all checks)\")\\n        print(\"Use \\'prsist -l\\' to list all commands\")\\n        return\\n\\n    # Parse arguments manually to handle combined flags\\n    args = sys.argv[1]\\n    if args.startswith(\\'-\\'):\\n        commands = args[1:]  # Remove the dash\\n    else:\\n        commands = args\\n\\n    # Handle special \\'all\\' command\\n    if \\'a\\' in commands:\\n        commands = commands.replace(\\'a\\', \\'tschrmv\\')\\n\\n    # Remove duplicates while preserving order\\n    seen = set()\\n    unique_commands = []\\n    for cmd in commands:\\n        if cmd not in seen:\\n            seen.add(cmd)\\n            unique_commands.append(cmd)\\n    \\n    commands = \\'\\'.join(unique_commands)\\n    \\n    success_count = 0\\n    total_count = 0\\n    \\n    print(f\"[RUN] Prsist Memory: Running {len(commands)} command(s)\")\\n    print(\"-\" * 50)\\n    \\n    for i, cmd in enumerate(commands):\\n        if cmd in COMMAND_MAP:\\n            if i > 0:\\n                print()  # Space between commands\\n            success = COMMAND_MAP[cmd]()\\n            total_count += 1\\n            if success:\\n                success_count += 1\\n        else:\\n            print(f\"[ERROR] Unknown command: -{cmd}\")\\n            total_count += 1\\n    \\n    print(\"-\" * 50)\\n    print(f\"[DONE] {success_count}/{total_count} commands completed successfully\")\\n\\nif __name__ == \"__main__\":\\n    main()', 'structuredPatch': [{'oldStart': 339, 'oldLines': 7, 'newStart': 339, 'newLines': 7, 'lines': ['         ', '         return None', '     except Exception as e:', '-        logging.debug(f\"Failed to extract contextual description: {e}\")', '+        print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug', '         return None', ' ', ' def health_check():']}], 'userModified': False, 'replaceAll': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Bash",
        "timestamp": "2025-08-24T19:00:40.284605",
        "input_data": {
          "command": "python .prsist/bin/prsist.py -r",
          "description": "Test with debug output to see errors"
        },
        "output_data": "{'stdout': \"[RUN] Prsist Memory: Running 1 command(s)\\r\\n--------------------------------------------------\\r\\n[RECENT] Recent Sessions...\\r\\n[DEBUG] Session description error: 'charmap' codec can't decode byte 0x9d in position 123995: character maps to <undefined>\\r\\n  - 15859307: Development session\\r\\n[DEBUG] Session description error: 'charmap' codec can't decode byte 0x9d in position 123995: character maps to <undefined>\\r\\n  - fe62facb: Development session\\r\\n[DEBUG] Session description error: 'charmap' codec can't decode byte 0x9d in position 123995: character maps to <undefined>\\r\\n  - e6dca0ec: Development session\\r\\n[DEBUG] Session description error: 'charmap' codec can't decode byte 0x9d in position 123995: character maps to <undefined>\\r\\n  - f02444bf: Development session\\r\\n[DEBUG] Session description error: 'charmap' codec can't decode byte 0x9d in position 123995: character maps to <undefined>\\r\\n  - ca0cdd1e: Development session\\r\\n--------------------------------------------------\\r\\n[DONE] 1/1 commands completed successfully\\r\\n2025-08-24 19:00:39,475 - root - INFO - Memory manager initialized\\r\", 'stderr': '', 'interrupted': False, 'isImage': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Bash",
        "timestamp": "2025-08-24T19:00:40.602855",
        "input_data": {
          "command": "python .prsist/bin/prsist.py -r",
          "description": "Test with debug output to see errors"
        },
        "output_data": "{'stdout': \"[RUN] Prsist Memory: Running 1 command(s)\\r\\n--------------------------------------------------\\r\\n[RECENT] Recent Sessions...\\r\\n[DEBUG] Session description error: 'charmap' codec can't decode byte 0x9d in position 123995: character maps to <undefined>\\r\\n  - 15859307: Development session\\r\\n[DEBUG] Session description error: 'charmap' codec can't decode byte 0x9d in position 123995: character maps to <undefined>\\r\\n  - fe62facb: Development session\\r\\n[DEBUG] Session description error: 'charmap' codec can't decode byte 0x9d in position 123995: character maps to <undefined>\\r\\n  - e6dca0ec: Development session\\r\\n[DEBUG] Session description error: 'charmap' codec can't decode byte 0x9d in position 123995: character maps to <undefined>\\r\\n  - f02444bf: Development session\\r\\n[DEBUG] Session description error: 'charmap' codec can't decode byte 0x9d in position 123995: character maps to <undefined>\\r\\n  - ca0cdd1e: Development session\\r\\n--------------------------------------------------\\r\\n[DONE] 1/1 commands completed successfully\\r\\n2025-08-24 19:00:39,475 - root - INFO - Memory manager initialized\\r\", 'stderr': '', 'interrupted': False, 'isImage': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Edit",
        "timestamp": "2025-08-24T19:00:52.767685",
        "input_data": {
          "file_path": ".prsist/bin/prsist.py",
          "old_string": "full_session_data = None\n        if archived_file.exists():\n            with open(archived_file, 'r') as f:\n                full_session_data = json.load(f)\n        else:\n            # Try active session file\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\n            if active_file.exists():\n                with open(active_file, 'r') as f:\n                    temp_data = json.load(f)\n                    if temp_data.get('id') == session_id:\n                        full_session_data = temp_data",
          "new_string": "full_session_data = None\n        if archived_file.exists():\n            with open(archived_file, 'r', encoding='utf-8') as f:\n                full_session_data = json.load(f)\n        else:\n            # Try active session file\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\n            if active_file.exists():\n                with open(active_file, 'r', encoding='utf-8') as f:\n                    temp_data = json.load(f)\n                    if temp_data.get('id') == session_id:\n                        full_session_data = temp_data"
        },
        "output_data": "{'filePath': '.prsist/bin/prsist.py', 'oldString': '        full_session_data = None\\n        if archived_file.exists():\\n            with open(archived_file, \\'r\\') as f:\\n                full_session_data = json.load(f)\\n        else:\\n            # Try active session file\\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n            if active_file.exists():\\n                with open(active_file, \\'r\\') as f:\\n                    temp_data = json.load(f)\\n                    if temp_data.get(\\'id\\') == session_id:\\n                        full_session_data = temp_data', 'newString': '        full_session_data = None\\n        if archived_file.exists():\\n            with open(archived_file, \\'r\\', encoding=\\'utf-8\\') as f:\\n                full_session_data = json.load(f)\\n        else:\\n            # Try active session file\\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n            if active_file.exists():\\n                with open(active_file, \\'r\\', encoding=\\'utf-8\\') as f:\\n                    temp_data = json.load(f)\\n                    if temp_data.get(\\'id\\') == session_id:\\n                        full_session_data = temp_data', 'originalFile': '#!/usr/bin/env python3\\n\"\"\"\\nPrsist Memory System CLI - Simple, memorable commands\\nUsage: prsist [options]\\n\\nSingle Letter Options:\\n  -t  Test system\\n  -s  Status/session info  \\n  -c  Context (what Claude sees)\\n  -r  Recent sessions\\n  -h  Health check\\n  -f  Feature log (interactive)\\n  -m  Memory stats\\n  -v  Validate system\\n  -p  Project memory operations\\n  -d  Decisions (add decision)\\n  -e  End session\\n  -n  New session (start)\\n  -k  Checkpoint (create)\\n  -x  Export session data\\n  -z  Cleanup old data\\n  -l  List all commands\\n  -a  All checks (equivalent to -tschrmv)\\n  \\nChain commands: prsist -tsc (test + status + context)\\nExamples:\\n  prsist -t        Test system\\n  prsist -h        Health check\\n  prsist -tsc      Test + Status + Context\\n  prsist -a        Run all checks\\n  prsist -hm       Health + Memory stats\\n\"\"\"\\n\\nimport sys\\nimport os\\nimport json\\nimport logging\\nfrom pathlib import Path\\n\\n# Add parent directory to path for imports\\nsys.path.insert(0, str(Path(__file__).parent.parent))\\n\\ndef test_system():\\n    \"\"\"Test complete memory system\"\"\"\\n    print(\"[TEST] Testing Memory System...\")\\n    try:\\n        import subprocess\\n        result = subprocess.run([sys.executable, \"../tests/test_system.py\"], \\n                              capture_output=True, text=True, cwd=Path(__file__).parent)\\n        if result.returncode == 0:\\n            print(\"[PASS] All tests passed!\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Tests failed: {result.stderr}\")\\n            return False\\n    except Exception as e:\\n        print(f\"[ERROR] Test error: {e}\")\\n        return False\\n\\ndef session_status():\\n    \"\"\"Get current session status\"\"\"\\n    print(\"[STATUS] Session Status...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        info = mm.get_session_info()\\n        \\n        if info.get(\"session_id\"):\\n            print(f\"  Active Session: {info[\\'session_id\\'][:8]}...\")\\n            print(f\"  Tools Used: {info.get(\\'tool_usage_count\\', 0)}\")\\n            print(f\"  Files Modified: {info.get(\\'file_interaction_count\\', 0)}\")\\n            print(f\"  Duration: {info.get(\\'duration_minutes\\', 0)} minutes\")\\n        else:\\n            print(\"  No active session\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Status error: {e}\")\\n        return False\\n\\ndef show_context():\\n    \"\"\"Show current context (what Claude sees)\"\"\"\\n    print(\"[CONTEXT] Current Context...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        context = mm.get_session_context()\\n        \\n        if context:\\n            lines = context.split(\\'\\\\n\\')\\n            print(f\"  Context Length: {len(context)} characters\")\\n            print(f\"  Lines: {len(lines)}\")\\n            print(\"  Preview:\")\\n            for i, line in enumerate(lines[:5]):\\n                print(f\"    {line[:70]}{\\'...\\' if len(line) > 70 else \\'\\'}\")\\n            if len(lines) > 5:\\n                print(f\"    ... and {len(lines) - 5} more lines\")\\n        else:\\n            print(\"  No context available\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Context error: {e}\")\\n        return False\\n\\ndef recent_sessions():\\n    \"\"\"Show recent sessions with enhanced descriptions\"\"\"\\n    print(\"[RECENT] Recent Sessions...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        sessions = mm.get_recent_sessions(5)\\n        \\n        if sessions:\\n            # Check for current active session\\n            current_session_id = None\\n            try:\\n                current_context = mm.get_session_context()\\n                current_session_id = current_context.get(\"session_id\")\\n            except:\\n                pass\\n            \\n            for i, session in enumerate(sessions):\\n                # Generate meaningful description\\n                description = generate_session_description(session)\\n                session_id = session.get(\"session_id\", \"Unknown\")\\n                short_id = session_id[:8] if session_id != \"Unknown\" else \"Unknown\"\\n                \\n                if i == 0 and session_id == current_session_id:\\n                    # Current active session - enhanced display\\n                    print(f\"ðŸ”„ Active Session ({short_id})\")\\n                    print(f\"  - Activity: {description}\")\\n                    print(f\"  - Focus: Enhanced session descriptions and memory system improvements\")\\n                    print(f\"  - Status: Currently active\")\\n                    print(\"\")\\n                    print(\"ðŸ“– Previous Sessions:\")\\n                elif i == 0:\\n                    # First session but not current\\n                    print(f\"  - {short_id}: {description}\")\\n                else:\\n                    # Previous sessions\\n                    print(f\"  - {short_id}: {description}\")\\n        else:\\n            print(\"  No recent sessions found\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Recent sessions error: {e}\")\\n        return False\\n\\ndef generate_session_description(session_data):\\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\\n    try:\\n        # Get session details for rich context generation\\n        session_id = session_data.get(\\'session_id\\')\\n        if not session_id:\\n            return \"Unknown session\"\\n            \\n        # Try to load full session data from archived or active sessions\\n        memory_dir = Path(__file__).parent.parent\\n        archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\\n        \\n        full_session_data = None\\n        if archived_file.exists():\\n            with open(archived_file, \\'r\\') as f:\\n                full_session_data = json.load(f)\\n        else:\\n            # Try active session file\\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n            if active_file.exists():\\n                with open(active_file, \\'r\\') as f:\\n                    temp_data = json.load(f)\\n                    if temp_data.get(\\'id\\') == session_id:\\n                        full_session_data = temp_data\\n        \\n        if full_session_data:\\n            # Extract rich context from session data\\n            description = _extract_contextual_description(full_session_data, session_data)\\n            if description:\\n                return description\\n        \\n        # Fallback to enhanced generic descriptions\\n        tool_count = session_data.get(\\'tool_usage_count\\', 0)\\n        file_count = session_data.get(\\'file_interaction_count\\', 0)\\n        tools_used = session_data.get(\\'unique_tools_used\\', [])\\n        \\n        # Generate enhanced descriptions\\n        if file_count > 0 and tool_count > 0:\\n            if \\'Write\\' in tools_used and \\'Edit\\' in tools_used:\\n                return f\"Created and refined {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} ({tool_count} operations)\"\\n            elif \\'Write\\' in tools_used:\\n                return f\"New file development - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} created\"\\n            elif \\'Edit\\' in tools_used or \\'MultiEdit\\' in tools_used:\\n                return f\"Code editing session - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} modified\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Code analysis and exploration ({tool_count} operations)\"\\n        elif tool_count > 15:\\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command-heavy development session ({tool_count} operations)\"\\n        elif tool_count > 5:\\n            if \\'Bash\\' in tools_used:\\n                return f\"Command execution and testing ({tool_count} operations)\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Documentation and code review ({tool_count} operations)\"\\n        elif tool_count > 0:\\n            return f\"Light development work ({tool_count} operations)\"\\n        \\n        return \"Empty session\"\\n    except Exception as e:\\n        print(f\"[DEBUG] Session description error: {e}\")  # Temporary debug\\n        return \"Development session\"\\n\\n\\ndef _extract_contextual_description(full_session_data, session_summary):\\n    \"\"\"Extract meaningful context from full session data\"\"\"\\n    try:\\n        tool_usage = full_session_data.get(\\'tool_usage\\', [])\\n        file_interactions = full_session_data.get(\\'file_interactions\\', [])\\n        \\n        # Extract key information\\n        files_modified = []\\n        files_read = []\\n        commands_run = []\\n        searches_made = []\\n        todos_worked = []\\n        \\n        # Analyze tool usage for context\\n        for tool in tool_usage:\\n            tool_name = tool.get(\\'tool_name\\', \\'\\')\\n            input_data = tool.get(\\'input_data\\', {})\\n            \\n            if tool_name in [\\'Edit\\', \\'MultiEdit\\', \\'Write\\']:\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_modified.append(Path(file_path).name)\\n            elif tool_name == \\'Read\\':\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_read.append(Path(file_path).name)\\n            elif tool_name == \\'Bash\\':\\n                command = input_data.get(\\'command\\', \\'\\')\\n                if command:\\n                    commands_run.append(command)\\n            elif tool_name == \\'WebSearch\\':\\n                query = input_data.get(\\'query\\', \\'\\')\\n                if query:\\n                    searches_made.append(query)\\n            elif tool_name == \\'TodoWrite\\':\\n                todos = input_data.get(\\'todos\\', [])\\n                for todo in todos:\\n                    content = todo.get(\\'content\\', \\'\\')\\n                    if content and content not in todos_worked:\\n                        todos_worked.append(content)\\n        \\n        # Generate contextual description based on extracted data\\n        description_parts = []\\n        \\n        # Main activity identification\\n        if searches_made:\\n            for query in searches_made[:1]:  # Focus on first search\\n                if \\'mcp\\' in query.lower() or \\'context7\\' in query.lower():\\n                    description_parts.append(\"Researched and integrated Context7 MCP server\")\\n                    break\\n                elif \\'memory\\' in query.lower():\\n                    description_parts.append(\"Researched memory system implementation\")\\n                    break\\n                else:\\n                    description_parts.append(f\"Researched {query[:50]}\")\\n                    break\\n        \\n        if todos_worked:\\n            todo_descriptions = []\\n            for todo in todos_worked[:2]:  # Show first 2 todos\\n                if \\'mcp\\' in todo.lower() or \\'context7\\' in todo.lower():\\n                    todo_descriptions.append(\"MCP server setup\")\\n                elif \\'enhance\\' in todo.lower() or \\'improve\\' in todo.lower():\\n                    todo_descriptions.append(\"system improvements\")\\n                else:\\n                    todo_descriptions.append(todo[:30])\\n            \\n            if not description_parts:  # Only if no search activity found\\n                description_parts.append(f\"Worked on: {\\', \\'.join(todo_descriptions)}\")\\n        \\n        # File modification context\\n        if files_modified:\\n            unique_files = list(dict.fromkeys(files_modified))  # Remove duplicates\\n            if len(unique_files) == 1:\\n                file_name = unique_files[0]\\n                if \\'activity_analyzer\\' in file_name:\\n                    description_parts.append(f\"Enhanced session analysis in {file_name}\")\\n                elif \\'prsist\\' in file_name:\\n                    description_parts.append(f\"Improved memory CLI in {file_name}\")\\n                elif \\'memory\\' in file_name or \\'session\\' in file_name:\\n                    description_parts.append(f\"Updated memory system in {file_name}\")\\n                else:\\n                    description_parts.append(f\"Modified {file_name}\")\\n            elif len(unique_files) <= 3:\\n                description_parts.append(f\"Modified {\\', \\'.join(unique_files[:2])} + {len(unique_files)-2} more files\" if len(unique_files) > 2 else f\"Modified {\\', \\'.join(unique_files)}\")\\n            else:\\n                description_parts.append(f\"Modified {len(unique_files)} files including {\\', \\'.join(unique_files[:2])}\")\\n        \\n        # Command execution context\\n        if commands_run and not description_parts:\\n            command_contexts = []\\n            for cmd in commands_run[:3]:  # Look at first 3 commands\\n                if \\'mcp add\\' in cmd:\\n                    command_contexts.append(\"MCP server installation\")\\n                elif \\'mem\\' in cmd and \\'recent\\' in cmd:\\n                    command_contexts.append(\"memory system testing\")\\n                elif \\'python\\' in cmd and \\'prsist\\' in cmd:\\n                    command_contexts.append(\"memory CLI validation\")\\n                elif \\'npm\\' in cmd or \\'npx\\' in cmd:\\n                    command_contexts.append(\"package management\")\\n            \\n            if command_contexts:\\n                description_parts.append(\\', \\'.join(dict.fromkeys(command_contexts)))  # Remove duplicates\\n        \\n        # File reading context (only if no modifications)\\n        if files_read and not files_modified and not description_parts:\\n            unique_read = list(dict.fromkeys(files_read))\\n            if len(unique_read) == 1:\\n                description_parts.append(f\"Analyzed {unique_read[0]}\")\\n            elif len(unique_read) <= 3:\\n                description_parts.append(f\"Reviewed {\\', \\'.join(unique_read)}\")\\n            else:\\n                description_parts.append(f\"Explored {len(unique_read)} files\")\\n        \\n        # Combine description parts\\n        if description_parts:\\n            main_description = description_parts[0]\\n            \\n            # Add file context if not already included\\n            if files_modified and \\'Modified\\' not in main_description and \\'Enhanced\\' not in main_description:\\n                if len(files_modified) == 1:\\n                    main_description += f\" - modified {files_modified[0]}\"\\n                elif len(files_modified) <= 3:\\n                    main_description += f\" - modified {len(files_modified)} files\"\\n            \\n            return main_description\\n        \\n        return None\\n    except Exception as e:\\n        print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug\\n        return None\\n\\ndef health_check():\\n    \"\"\"System health check\"\"\"\\n    print(\"[HEALTH] Health Check...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        if validation[\"valid\"]:\\n            print(\"[PASS] System healthy\")\\n        else:\\n            print(\"[WARN] System issues found:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Health check error: {e}\")\\n        return False\\n\\ndef feature_log():\\n    \"\"\"Interactive feature logging\"\"\"\\n    print(\"[FEATURE] Feature Logging...\")\\n    try:\\n        feature_name = input(\"Feature name: \").strip()\\n        if not feature_name:\\n            print(\"[ERROR] Feature name required\")\\n            return False\\n            \\n        description = input(\"Description (optional): \").strip()\\n        \\n        import subprocess\\n        cmd = [sys.executable, \"hooks/FeatureComplete.py\", feature_name]\\n        if description:\\n            cmd.append(description)\\n            \\n        result = subprocess.run(cmd, capture_output=True, text=True, cwd=Path(__file__).parent)\\n        \\n        if result.returncode == 0:\\n            print(f\"[PASS] Feature \\'{feature_name}\\' logged successfully\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Feature logging failed: {result.stderr}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Feature logging cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Feature logging error: {e}\")\\n        return False\\n\\ndef memory_stats():\\n    \"\"\"Show memory system statistics\"\"\"\\n    print(\"[STATS] Memory Stats...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        stats = mm.get_memory_stats()\\n        \\n        print(f\"  Total Sessions: {stats.get(\\'total_sessions\\', 0)}\")\\n        print(f\"  Database Size: {stats.get(\\'database_size_mb\\', 0)} MB\")\\n        print(f\"  Active Session: {stats.get(\\'active_session\\', \\'None\\')}\")\\n        print(f\"  Project Root: {stats.get(\\'project_root\\', \\'Unknown\\')}\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Memory stats error: {e}\")\\n        return False\\n\\ndef validate_system():\\n    \"\"\"Validate system integrity\"\"\"\\n    print(\"[VALIDATE] System Validation...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        print(f\"  System Valid: {validation[\\'valid\\']}\")\\n        if not validation[\"valid\"]:\\n            print(\"  Issues:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Validation error: {e}\")\\n        return False\\n\\ndef project_memory():\\n    \"\"\"Add to project memory\"\"\"\\n    print(\"[PROJECT] Project Memory...\")\\n    try:\\n        content = input(\"Enter information to add to project memory: \").strip()\\n        if not content:\\n            print(\"[ERROR] Content required\")\\n            return False\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_project_memory(content)\\n        \\n        if success:\\n            print(f\"[PASS] Project memory updated\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to update project memory\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Project memory update cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Project memory error: {e}\")\\n        return False\\n\\ndef add_decision():\\n    \"\"\"Add a decision record\"\"\"\\n    print(\"[DECISION] Add Decision...\")\\n    try:\\n        title = input(\"Decision title: \").strip()\\n        if not title:\\n            print(\"[ERROR] Decision title required\")\\n            return False\\n            \\n        description = input(\"Description: \").strip()\\n        if not description:\\n            print(\"[ERROR] Description required\")\\n            return False\\n            \\n        category = input(\"Category (architecture/technical/process/design): \").strip()\\n        if not category:\\n            category = \"general\"\\n            \\n        impact = input(\"Impact (low/medium/high/critical): \").strip()\\n        if not impact:\\n            impact = \"medium\"\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_decision(title, description, category, impact)\\n        \\n        if success:\\n            print(f\"[PASS] Decision \\'{title}\\' recorded\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to record decision\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Decision recording cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Decision recording error: {e}\")\\n        return False\\n\\ndef end_session():\\n    \"\"\"End current session\"\"\"\\n    print(\"[END] Ending Session...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.end_session(archive=True)\\n        \\n        if result:\\n            print(\"[PASS] Session ended and archived\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to end\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] End session error: {e}\")\\n        return False\\n\\ndef new_session():\\n    \"\"\"Start new session\"\"\"\\n    print(\"[NEW] Starting New Session...\")\\n    try:\\n        context = input(\"Session context (optional): \").strip()\\n        \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        \\n        session_data = {}\\n        if context:\\n            session_data[\"context\"] = context\\n            \\n        result = mm.start_session(session_data)\\n        \\n        if result.get(\"memory_system_active\"):\\n            session_id = result.get(\"session_id\", \"unknown\")\\n            print(f\"[PASS] New session started: {session_id[:8]}...\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Failed to start session: {result.get(\\'error\\', \\'Unknown error\\')}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Session start cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] New session error: {e}\")\\n        return False\\n\\ndef create_checkpoint():\\n    \"\"\"Create a checkpoint\"\"\"\\n    print(\"[CHECKPOINT] Creating Checkpoint...\")\\n    try:\\n        name = input(\"Checkpoint name (optional): \").strip()\\n        if not name:\\n            name = None\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.create_checkpoint(name)\\n        \\n        if result:\\n            print(f\"[PASS] Checkpoint created: {name or \\'auto\\'}\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to create checkpoint\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Checkpoint creation cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Checkpoint error: {e}\")\\n        return False\\n\\ndef export_session():\\n    \"\"\"Export current session data\"\"\"\\n    print(\"[EXPORT] Exporting Session Data...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        data = mm.export_session_data(format=\"json\")\\n        \\n        if data:\\n            filename = f\"session_export_{mm.get_session_info().get(\\'session_id\\', \\'unknown\\')[:8]}.json\"\\n            with open(filename, \\'w\\') as f:\\n                f.write(data)\\n            print(f\"[PASS] Session exported to {filename}\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to export\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] Export error: {e}\")\\n        return False\\n\\ndef cleanup_data():\\n    \"\"\"Clean up old data\"\"\"\\n    print(\"[CLEANUP] Cleaning Up Old Data...\")\\n    try:\\n        days = input(\"Retention days (default 30): \").strip()\\n        if not days:\\n            days = 30\\n        else:\\n            days = int(days)\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.cleanup_old_data(retention_days=days)\\n        \\n        print(f\"[PASS] Cleanup completed: {result}\")\\n        return True\\n    except ValueError:\\n        print(\"[ERROR] Invalid number of days\")\\n        return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Cleanup cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Cleanup error: {e}\")\\n        return False\\n\\ndef list_commands():\\n    \"\"\"List all available commands\"\"\"\\n    print(\"[HELP] Prsist Memory System Commands:\")\\n    print(\"\\\\n  Core Operations:\")\\n    print(\"  -t  Test system\")\\n    print(\"  -s  Status/session info\")\\n    print(\"  -c  Context (what Claude sees)\")\\n    print(\"  -r  Recent sessions\")\\n    print(\"  -h  Health check\")\\n    print(\"  -m  Memory stats\")\\n    print(\"  -v  Validate system\")\\n    print(\"\\\\n  Session Management:\")\\n    print(\"  -n  New session (start)\")\\n    print(\"  -e  End session\")\\n    print(\"  -k  Checkpoint (create)\")\\n    print(\"  -x  Export session data\")\\n    print(\"\\\\n  Data Management:\")\\n    print(\"  -f  Feature log (interactive)\")\\n    print(\"  -p  Project memory (add)\")\\n    print(\"  -d  Decisions (add decision)\")\\n    print(\"  -z  Cleanup old data\")\\n    print(\"\\\\n  Shortcuts:\")\\n    print(\"  -a  All core checks (equivalent to -tschrmv)\")\\n    print(\"  -l  List commands (this help)\")\\n    print(\"\\\\nExamples:\")\\n    print(\"  prsist -t      (test system)\")\\n    print(\"  prsist -hm     (health + memory stats)\")\\n    print(\"  prsist -tsc    (test + status + context)\")\\n    print(\"  prsist -a      (run all core checks)\")\\n    print(\"  prsist -nf     (new session + feature log)\")\\n    return True\\n\\n# Command mapping\\nCOMMAND_MAP = {\\n    \\'t\\': test_system,\\n    \\'s\\': session_status,\\n    \\'c\\': show_context,\\n    \\'r\\': recent_sessions,\\n    \\'h\\': health_check,\\n    \\'f\\': feature_log,\\n    \\'m\\': memory_stats,\\n    \\'v\\': validate_system,\\n    \\'p\\': project_memory,\\n    \\'d\\': add_decision,\\n    \\'e\\': end_session,\\n    \\'n\\': new_session,\\n    \\'k\\': create_checkpoint,\\n    \\'x\\': export_session,\\n    \\'z\\': cleanup_data,\\n    \\'l\\': list_commands\\n}\\n\\ndef main():\\n    # Custom argument parser that handles combined flags like -tsc\\n    if len(sys.argv) < 2:\\n        print(\"Prsist Memory System CLI\")\\n        print(\"Usage: prsist [options]\")\\n        print(\"Example: prsist -t       (test)\")\\n        print(\"Example: prsist -tsc     (test + status + context)\")\\n        print(\"Example: prsist -a       (all checks)\")\\n        print(\"Use \\'prsist -l\\' to list all commands\")\\n        return\\n\\n    # Parse arguments manually to handle combined flags\\n    args = sys.argv[1]\\n    if args.startswith(\\'-\\'):\\n        commands = args[1:]  # Remove the dash\\n    else:\\n        commands = args\\n\\n    # Handle special \\'all\\' command\\n    if \\'a\\' in commands:\\n        commands = commands.replace(\\'a\\', \\'tschrmv\\')\\n\\n    # Remove duplicates while preserving order\\n    seen = set()\\n    unique_commands = []\\n    for cmd in commands:\\n        if cmd not in seen:\\n            seen.add(cmd)\\n            unique_commands.append(cmd)\\n    \\n    commands = \\'\\'.join(unique_commands)\\n    \\n    success_count = 0\\n    total_count = 0\\n    \\n    print(f\"[RUN] Prsist Memory: Running {len(commands)} command(s)\")\\n    print(\"-\" * 50)\\n    \\n    for i, cmd in enumerate(commands):\\n        if cmd in COMMAND_MAP:\\n            if i > 0:\\n                print()  # Space between commands\\n            success = COMMAND_MAP[cmd]()\\n            total_count += 1\\n            if success:\\n                success_count += 1\\n        else:\\n            print(f\"[ERROR] Unknown command: -{cmd}\")\\n            total_count += 1\\n    \\n    print(\"-\" * 50)\\n    print(f\"[DONE] {success_count}/{total_count} commands completed successfully\")\\n\\nif __name__ == \"__main__\":\\n    main()', 'structuredPatch': [{'oldStart': 159, 'oldLines': 13, 'newStart': 159, 'newLines': 13, 'lines': ['         ', '         full_session_data = None', '         if archived_file.exists():', \"-            with open(archived_file, 'r') as f:\", \"+            with open(archived_file, 'r', encoding='utf-8') as f:\", '                 full_session_data = json.load(f)', '         else:', '             # Try active session file', '             active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"', '             if active_file.exists():', \"-                with open(active_file, 'r') as f:\", \"+                with open(active_file, 'r', encoding='utf-8') as f:\", '                     temp_data = json.load(f)', \"                     if temp_data.get('id') == session_id:\", '                         full_session_data = temp_data']}], 'userModified': False, 'replaceAll': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Edit",
        "timestamp": "2025-08-24T19:00:52.822674",
        "input_data": {
          "file_path": ".prsist/bin/prsist.py",
          "old_string": "full_session_data = None\n        if archived_file.exists():\n            with open(archived_file, 'r') as f:\n                full_session_data = json.load(f)\n        else:\n            # Try active session file\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\n            if active_file.exists():\n                with open(active_file, 'r') as f:\n                    temp_data = json.load(f)\n                    if temp_data.get('id') == session_id:\n                        full_session_data = temp_data",
          "new_string": "full_session_data = None\n        if archived_file.exists():\n            with open(archived_file, 'r', encoding='utf-8') as f:\n                full_session_data = json.load(f)\n        else:\n            # Try active session file\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\n            if active_file.exists():\n                with open(active_file, 'r', encoding='utf-8') as f:\n                    temp_data = json.load(f)\n                    if temp_data.get('id') == session_id:\n                        full_session_data = temp_data"
        },
        "output_data": "{'filePath': '.prsist/bin/prsist.py', 'oldString': '        full_session_data = None\\n        if archived_file.exists():\\n            with open(archived_file, \\'r\\') as f:\\n                full_session_data = json.load(f)\\n        else:\\n            # Try active session file\\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n            if active_file.exists():\\n                with open(active_file, \\'r\\') as f:\\n                    temp_data = json.load(f)\\n                    if temp_data.get(\\'id\\') == session_id:\\n                        full_session_data = temp_data', 'newString': '        full_session_data = None\\n        if archived_file.exists():\\n            with open(archived_file, \\'r\\', encoding=\\'utf-8\\') as f:\\n                full_session_data = json.load(f)\\n        else:\\n            # Try active session file\\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n            if active_file.exists():\\n                with open(active_file, \\'r\\', encoding=\\'utf-8\\') as f:\\n                    temp_data = json.load(f)\\n                    if temp_data.get(\\'id\\') == session_id:\\n                        full_session_data = temp_data', 'originalFile': '#!/usr/bin/env python3\\n\"\"\"\\nPrsist Memory System CLI - Simple, memorable commands\\nUsage: prsist [options]\\n\\nSingle Letter Options:\\n  -t  Test system\\n  -s  Status/session info  \\n  -c  Context (what Claude sees)\\n  -r  Recent sessions\\n  -h  Health check\\n  -f  Feature log (interactive)\\n  -m  Memory stats\\n  -v  Validate system\\n  -p  Project memory operations\\n  -d  Decisions (add decision)\\n  -e  End session\\n  -n  New session (start)\\n  -k  Checkpoint (create)\\n  -x  Export session data\\n  -z  Cleanup old data\\n  -l  List all commands\\n  -a  All checks (equivalent to -tschrmv)\\n  \\nChain commands: prsist -tsc (test + status + context)\\nExamples:\\n  prsist -t        Test system\\n  prsist -h        Health check\\n  prsist -tsc      Test + Status + Context\\n  prsist -a        Run all checks\\n  prsist -hm       Health + Memory stats\\n\"\"\"\\n\\nimport sys\\nimport os\\nimport json\\nimport logging\\nfrom pathlib import Path\\n\\n# Add parent directory to path for imports\\nsys.path.insert(0, str(Path(__file__).parent.parent))\\n\\ndef test_system():\\n    \"\"\"Test complete memory system\"\"\"\\n    print(\"[TEST] Testing Memory System...\")\\n    try:\\n        import subprocess\\n        result = subprocess.run([sys.executable, \"../tests/test_system.py\"], \\n                              capture_output=True, text=True, cwd=Path(__file__).parent)\\n        if result.returncode == 0:\\n            print(\"[PASS] All tests passed!\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Tests failed: {result.stderr}\")\\n            return False\\n    except Exception as e:\\n        print(f\"[ERROR] Test error: {e}\")\\n        return False\\n\\ndef session_status():\\n    \"\"\"Get current session status\"\"\"\\n    print(\"[STATUS] Session Status...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        info = mm.get_session_info()\\n        \\n        if info.get(\"session_id\"):\\n            print(f\"  Active Session: {info[\\'session_id\\'][:8]}...\")\\n            print(f\"  Tools Used: {info.get(\\'tool_usage_count\\', 0)}\")\\n            print(f\"  Files Modified: {info.get(\\'file_interaction_count\\', 0)}\")\\n            print(f\"  Duration: {info.get(\\'duration_minutes\\', 0)} minutes\")\\n        else:\\n            print(\"  No active session\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Status error: {e}\")\\n        return False\\n\\ndef show_context():\\n    \"\"\"Show current context (what Claude sees)\"\"\"\\n    print(\"[CONTEXT] Current Context...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        context = mm.get_session_context()\\n        \\n        if context:\\n            lines = context.split(\\'\\\\n\\')\\n            print(f\"  Context Length: {len(context)} characters\")\\n            print(f\"  Lines: {len(lines)}\")\\n            print(\"  Preview:\")\\n            for i, line in enumerate(lines[:5]):\\n                print(f\"    {line[:70]}{\\'...\\' if len(line) > 70 else \\'\\'}\")\\n            if len(lines) > 5:\\n                print(f\"    ... and {len(lines) - 5} more lines\")\\n        else:\\n            print(\"  No context available\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Context error: {e}\")\\n        return False\\n\\ndef recent_sessions():\\n    \"\"\"Show recent sessions with enhanced descriptions\"\"\"\\n    print(\"[RECENT] Recent Sessions...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        sessions = mm.get_recent_sessions(5)\\n        \\n        if sessions:\\n            # Check for current active session\\n            current_session_id = None\\n            try:\\n                current_context = mm.get_session_context()\\n                current_session_id = current_context.get(\"session_id\")\\n            except:\\n                pass\\n            \\n            for i, session in enumerate(sessions):\\n                # Generate meaningful description\\n                description = generate_session_description(session)\\n                session_id = session.get(\"session_id\", \"Unknown\")\\n                short_id = session_id[:8] if session_id != \"Unknown\" else \"Unknown\"\\n                \\n                if i == 0 and session_id == current_session_id:\\n                    # Current active session - enhanced display\\n                    print(f\"ðŸ”„ Active Session ({short_id})\")\\n                    print(f\"  - Activity: {description}\")\\n                    print(f\"  - Focus: Enhanced session descriptions and memory system improvements\")\\n                    print(f\"  - Status: Currently active\")\\n                    print(\"\")\\n                    print(\"ðŸ“– Previous Sessions:\")\\n                elif i == 0:\\n                    # First session but not current\\n                    print(f\"  - {short_id}: {description}\")\\n                else:\\n                    # Previous sessions\\n                    print(f\"  - {short_id}: {description}\")\\n        else:\\n            print(\"  No recent sessions found\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Recent sessions error: {e}\")\\n        return False\\n\\ndef generate_session_description(session_data):\\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\\n    try:\\n        # Get session details for rich context generation\\n        session_id = session_data.get(\\'session_id\\')\\n        if not session_id:\\n            return \"Unknown session\"\\n            \\n        # Try to load full session data from archived or active sessions\\n        memory_dir = Path(__file__).parent.parent\\n        archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\\n        \\n        full_session_data = None\\n        if archived_file.exists():\\n            with open(archived_file, \\'r\\') as f:\\n                full_session_data = json.load(f)\\n        else:\\n            # Try active session file\\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n            if active_file.exists():\\n                with open(active_file, \\'r\\') as f:\\n                    temp_data = json.load(f)\\n                    if temp_data.get(\\'id\\') == session_id:\\n                        full_session_data = temp_data\\n        \\n        if full_session_data:\\n            # Extract rich context from session data\\n            description = _extract_contextual_description(full_session_data, session_data)\\n            if description:\\n                return description\\n        \\n        # Fallback to enhanced generic descriptions\\n        tool_count = session_data.get(\\'tool_usage_count\\', 0)\\n        file_count = session_data.get(\\'file_interaction_count\\', 0)\\n        tools_used = session_data.get(\\'unique_tools_used\\', [])\\n        \\n        # Generate enhanced descriptions\\n        if file_count > 0 and tool_count > 0:\\n            if \\'Write\\' in tools_used and \\'Edit\\' in tools_used:\\n                return f\"Created and refined {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} ({tool_count} operations)\"\\n            elif \\'Write\\' in tools_used:\\n                return f\"New file development - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} created\"\\n            elif \\'Edit\\' in tools_used or \\'MultiEdit\\' in tools_used:\\n                return f\"Code editing session - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} modified\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Code analysis and exploration ({tool_count} operations)\"\\n        elif tool_count > 15:\\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command-heavy development session ({tool_count} operations)\"\\n        elif tool_count > 5:\\n            if \\'Bash\\' in tools_used:\\n                return f\"Command execution and testing ({tool_count} operations)\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Documentation and code review ({tool_count} operations)\"\\n        elif tool_count > 0:\\n            return f\"Light development work ({tool_count} operations)\"\\n        \\n        return \"Empty session\"\\n    except Exception as e:\\n        print(f\"[DEBUG] Session description error: {e}\")  # Temporary debug\\n        return \"Development session\"\\n\\n\\ndef _extract_contextual_description(full_session_data, session_summary):\\n    \"\"\"Extract meaningful context from full session data\"\"\"\\n    try:\\n        tool_usage = full_session_data.get(\\'tool_usage\\', [])\\n        file_interactions = full_session_data.get(\\'file_interactions\\', [])\\n        \\n        # Extract key information\\n        files_modified = []\\n        files_read = []\\n        commands_run = []\\n        searches_made = []\\n        todos_worked = []\\n        \\n        # Analyze tool usage for context\\n        for tool in tool_usage:\\n            tool_name = tool.get(\\'tool_name\\', \\'\\')\\n            input_data = tool.get(\\'input_data\\', {})\\n            \\n            if tool_name in [\\'Edit\\', \\'MultiEdit\\', \\'Write\\']:\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_modified.append(Path(file_path).name)\\n            elif tool_name == \\'Read\\':\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_read.append(Path(file_path).name)\\n            elif tool_name == \\'Bash\\':\\n                command = input_data.get(\\'command\\', \\'\\')\\n                if command:\\n                    commands_run.append(command)\\n            elif tool_name == \\'WebSearch\\':\\n                query = input_data.get(\\'query\\', \\'\\')\\n                if query:\\n                    searches_made.append(query)\\n            elif tool_name == \\'TodoWrite\\':\\n                todos = input_data.get(\\'todos\\', [])\\n                for todo in todos:\\n                    content = todo.get(\\'content\\', \\'\\')\\n                    if content and content not in todos_worked:\\n                        todos_worked.append(content)\\n        \\n        # Generate contextual description based on extracted data\\n        description_parts = []\\n        \\n        # Main activity identification\\n        if searches_made:\\n            for query in searches_made[:1]:  # Focus on first search\\n                if \\'mcp\\' in query.lower() or \\'context7\\' in query.lower():\\n                    description_parts.append(\"Researched and integrated Context7 MCP server\")\\n                    break\\n                elif \\'memory\\' in query.lower():\\n                    description_parts.append(\"Researched memory system implementation\")\\n                    break\\n                else:\\n                    description_parts.append(f\"Researched {query[:50]}\")\\n                    break\\n        \\n        if todos_worked:\\n            todo_descriptions = []\\n            for todo in todos_worked[:2]:  # Show first 2 todos\\n                if \\'mcp\\' in todo.lower() or \\'context7\\' in todo.lower():\\n                    todo_descriptions.append(\"MCP server setup\")\\n                elif \\'enhance\\' in todo.lower() or \\'improve\\' in todo.lower():\\n                    todo_descriptions.append(\"system improvements\")\\n                else:\\n                    todo_descriptions.append(todo[:30])\\n            \\n            if not description_parts:  # Only if no search activity found\\n                description_parts.append(f\"Worked on: {\\', \\'.join(todo_descriptions)}\")\\n        \\n        # File modification context\\n        if files_modified:\\n            unique_files = list(dict.fromkeys(files_modified))  # Remove duplicates\\n            if len(unique_files) == 1:\\n                file_name = unique_files[0]\\n                if \\'activity_analyzer\\' in file_name:\\n                    description_parts.append(f\"Enhanced session analysis in {file_name}\")\\n                elif \\'prsist\\' in file_name:\\n                    description_parts.append(f\"Improved memory CLI in {file_name}\")\\n                elif \\'memory\\' in file_name or \\'session\\' in file_name:\\n                    description_parts.append(f\"Updated memory system in {file_name}\")\\n                else:\\n                    description_parts.append(f\"Modified {file_name}\")\\n            elif len(unique_files) <= 3:\\n                description_parts.append(f\"Modified {\\', \\'.join(unique_files[:2])} + {len(unique_files)-2} more files\" if len(unique_files) > 2 else f\"Modified {\\', \\'.join(unique_files)}\")\\n            else:\\n                description_parts.append(f\"Modified {len(unique_files)} files including {\\', \\'.join(unique_files[:2])}\")\\n        \\n        # Command execution context\\n        if commands_run and not description_parts:\\n            command_contexts = []\\n            for cmd in commands_run[:3]:  # Look at first 3 commands\\n                if \\'mcp add\\' in cmd:\\n                    command_contexts.append(\"MCP server installation\")\\n                elif \\'mem\\' in cmd and \\'recent\\' in cmd:\\n                    command_contexts.append(\"memory system testing\")\\n                elif \\'python\\' in cmd and \\'prsist\\' in cmd:\\n                    command_contexts.append(\"memory CLI validation\")\\n                elif \\'npm\\' in cmd or \\'npx\\' in cmd:\\n                    command_contexts.append(\"package management\")\\n            \\n            if command_contexts:\\n                description_parts.append(\\', \\'.join(dict.fromkeys(command_contexts)))  # Remove duplicates\\n        \\n        # File reading context (only if no modifications)\\n        if files_read and not files_modified and not description_parts:\\n            unique_read = list(dict.fromkeys(files_read))\\n            if len(unique_read) == 1:\\n                description_parts.append(f\"Analyzed {unique_read[0]}\")\\n            elif len(unique_read) <= 3:\\n                description_parts.append(f\"Reviewed {\\', \\'.join(unique_read)}\")\\n            else:\\n                description_parts.append(f\"Explored {len(unique_read)} files\")\\n        \\n        # Combine description parts\\n        if description_parts:\\n            main_description = description_parts[0]\\n            \\n            # Add file context if not already included\\n            if files_modified and \\'Modified\\' not in main_description and \\'Enhanced\\' not in main_description:\\n                if len(files_modified) == 1:\\n                    main_description += f\" - modified {files_modified[0]}\"\\n                elif len(files_modified) <= 3:\\n                    main_description += f\" - modified {len(files_modified)} files\"\\n            \\n            return main_description\\n        \\n        return None\\n    except Exception as e:\\n        print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug\\n        return None\\n\\ndef health_check():\\n    \"\"\"System health check\"\"\"\\n    print(\"[HEALTH] Health Check...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        if validation[\"valid\"]:\\n            print(\"[PASS] System healthy\")\\n        else:\\n            print(\"[WARN] System issues found:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Health check error: {e}\")\\n        return False\\n\\ndef feature_log():\\n    \"\"\"Interactive feature logging\"\"\"\\n    print(\"[FEATURE] Feature Logging...\")\\n    try:\\n        feature_name = input(\"Feature name: \").strip()\\n        if not feature_name:\\n            print(\"[ERROR] Feature name required\")\\n            return False\\n            \\n        description = input(\"Description (optional): \").strip()\\n        \\n        import subprocess\\n        cmd = [sys.executable, \"hooks/FeatureComplete.py\", feature_name]\\n        if description:\\n            cmd.append(description)\\n            \\n        result = subprocess.run(cmd, capture_output=True, text=True, cwd=Path(__file__).parent)\\n        \\n        if result.returncode == 0:\\n            print(f\"[PASS] Feature \\'{feature_name}\\' logged successfully\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Feature logging failed: {result.stderr}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Feature logging cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Feature logging error: {e}\")\\n        return False\\n\\ndef memory_stats():\\n    \"\"\"Show memory system statistics\"\"\"\\n    print(\"[STATS] Memory Stats...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        stats = mm.get_memory_stats()\\n        \\n        print(f\"  Total Sessions: {stats.get(\\'total_sessions\\', 0)}\")\\n        print(f\"  Database Size: {stats.get(\\'database_size_mb\\', 0)} MB\")\\n        print(f\"  Active Session: {stats.get(\\'active_session\\', \\'None\\')}\")\\n        print(f\"  Project Root: {stats.get(\\'project_root\\', \\'Unknown\\')}\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Memory stats error: {e}\")\\n        return False\\n\\ndef validate_system():\\n    \"\"\"Validate system integrity\"\"\"\\n    print(\"[VALIDATE] System Validation...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        print(f\"  System Valid: {validation[\\'valid\\']}\")\\n        if not validation[\"valid\"]:\\n            print(\"  Issues:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Validation error: {e}\")\\n        return False\\n\\ndef project_memory():\\n    \"\"\"Add to project memory\"\"\"\\n    print(\"[PROJECT] Project Memory...\")\\n    try:\\n        content = input(\"Enter information to add to project memory: \").strip()\\n        if not content:\\n            print(\"[ERROR] Content required\")\\n            return False\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_project_memory(content)\\n        \\n        if success:\\n            print(f\"[PASS] Project memory updated\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to update project memory\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Project memory update cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Project memory error: {e}\")\\n        return False\\n\\ndef add_decision():\\n    \"\"\"Add a decision record\"\"\"\\n    print(\"[DECISION] Add Decision...\")\\n    try:\\n        title = input(\"Decision title: \").strip()\\n        if not title:\\n            print(\"[ERROR] Decision title required\")\\n            return False\\n            \\n        description = input(\"Description: \").strip()\\n        if not description:\\n            print(\"[ERROR] Description required\")\\n            return False\\n            \\n        category = input(\"Category (architecture/technical/process/design): \").strip()\\n        if not category:\\n            category = \"general\"\\n            \\n        impact = input(\"Impact (low/medium/high/critical): \").strip()\\n        if not impact:\\n            impact = \"medium\"\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_decision(title, description, category, impact)\\n        \\n        if success:\\n            print(f\"[PASS] Decision \\'{title}\\' recorded\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to record decision\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Decision recording cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Decision recording error: {e}\")\\n        return False\\n\\ndef end_session():\\n    \"\"\"End current session\"\"\"\\n    print(\"[END] Ending Session...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.end_session(archive=True)\\n        \\n        if result:\\n            print(\"[PASS] Session ended and archived\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to end\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] End session error: {e}\")\\n        return False\\n\\ndef new_session():\\n    \"\"\"Start new session\"\"\"\\n    print(\"[NEW] Starting New Session...\")\\n    try:\\n        context = input(\"Session context (optional): \").strip()\\n        \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        \\n        session_data = {}\\n        if context:\\n            session_data[\"context\"] = context\\n            \\n        result = mm.start_session(session_data)\\n        \\n        if result.get(\"memory_system_active\"):\\n            session_id = result.get(\"session_id\", \"unknown\")\\n            print(f\"[PASS] New session started: {session_id[:8]}...\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Failed to start session: {result.get(\\'error\\', \\'Unknown error\\')}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Session start cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] New session error: {e}\")\\n        return False\\n\\ndef create_checkpoint():\\n    \"\"\"Create a checkpoint\"\"\"\\n    print(\"[CHECKPOINT] Creating Checkpoint...\")\\n    try:\\n        name = input(\"Checkpoint name (optional): \").strip()\\n        if not name:\\n            name = None\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.create_checkpoint(name)\\n        \\n        if result:\\n            print(f\"[PASS] Checkpoint created: {name or \\'auto\\'}\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to create checkpoint\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Checkpoint creation cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Checkpoint error: {e}\")\\n        return False\\n\\ndef export_session():\\n    \"\"\"Export current session data\"\"\"\\n    print(\"[EXPORT] Exporting Session Data...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        data = mm.export_session_data(format=\"json\")\\n        \\n        if data:\\n            filename = f\"session_export_{mm.get_session_info().get(\\'session_id\\', \\'unknown\\')[:8]}.json\"\\n            with open(filename, \\'w\\') as f:\\n                f.write(data)\\n            print(f\"[PASS] Session exported to {filename}\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to export\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] Export error: {e}\")\\n        return False\\n\\ndef cleanup_data():\\n    \"\"\"Clean up old data\"\"\"\\n    print(\"[CLEANUP] Cleaning Up Old Data...\")\\n    try:\\n        days = input(\"Retention days (default 30): \").strip()\\n        if not days:\\n            days = 30\\n        else:\\n            days = int(days)\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.cleanup_old_data(retention_days=days)\\n        \\n        print(f\"[PASS] Cleanup completed: {result}\")\\n        return True\\n    except ValueError:\\n        print(\"[ERROR] Invalid number of days\")\\n        return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Cleanup cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Cleanup error: {e}\")\\n        return False\\n\\ndef list_commands():\\n    \"\"\"List all available commands\"\"\"\\n    print(\"[HELP] Prsist Memory System Commands:\")\\n    print(\"\\\\n  Core Operations:\")\\n    print(\"  -t  Test system\")\\n    print(\"  -s  Status/session info\")\\n    print(\"  -c  Context (what Claude sees)\")\\n    print(\"  -r  Recent sessions\")\\n    print(\"  -h  Health check\")\\n    print(\"  -m  Memory stats\")\\n    print(\"  -v  Validate system\")\\n    print(\"\\\\n  Session Management:\")\\n    print(\"  -n  New session (start)\")\\n    print(\"  -e  End session\")\\n    print(\"  -k  Checkpoint (create)\")\\n    print(\"  -x  Export session data\")\\n    print(\"\\\\n  Data Management:\")\\n    print(\"  -f  Feature log (interactive)\")\\n    print(\"  -p  Project memory (add)\")\\n    print(\"  -d  Decisions (add decision)\")\\n    print(\"  -z  Cleanup old data\")\\n    print(\"\\\\n  Shortcuts:\")\\n    print(\"  -a  All core checks (equivalent to -tschrmv)\")\\n    print(\"  -l  List commands (this help)\")\\n    print(\"\\\\nExamples:\")\\n    print(\"  prsist -t      (test system)\")\\n    print(\"  prsist -hm     (health + memory stats)\")\\n    print(\"  prsist -tsc    (test + status + context)\")\\n    print(\"  prsist -a      (run all core checks)\")\\n    print(\"  prsist -nf     (new session + feature log)\")\\n    return True\\n\\n# Command mapping\\nCOMMAND_MAP = {\\n    \\'t\\': test_system,\\n    \\'s\\': session_status,\\n    \\'c\\': show_context,\\n    \\'r\\': recent_sessions,\\n    \\'h\\': health_check,\\n    \\'f\\': feature_log,\\n    \\'m\\': memory_stats,\\n    \\'v\\': validate_system,\\n    \\'p\\': project_memory,\\n    \\'d\\': add_decision,\\n    \\'e\\': end_session,\\n    \\'n\\': new_session,\\n    \\'k\\': create_checkpoint,\\n    \\'x\\': export_session,\\n    \\'z\\': cleanup_data,\\n    \\'l\\': list_commands\\n}\\n\\ndef main():\\n    # Custom argument parser that handles combined flags like -tsc\\n    if len(sys.argv) < 2:\\n        print(\"Prsist Memory System CLI\")\\n        print(\"Usage: prsist [options]\")\\n        print(\"Example: prsist -t       (test)\")\\n        print(\"Example: prsist -tsc     (test + status + context)\")\\n        print(\"Example: prsist -a       (all checks)\")\\n        print(\"Use \\'prsist -l\\' to list all commands\")\\n        return\\n\\n    # Parse arguments manually to handle combined flags\\n    args = sys.argv[1]\\n    if args.startswith(\\'-\\'):\\n        commands = args[1:]  # Remove the dash\\n    else:\\n        commands = args\\n\\n    # Handle special \\'all\\' command\\n    if \\'a\\' in commands:\\n        commands = commands.replace(\\'a\\', \\'tschrmv\\')\\n\\n    # Remove duplicates while preserving order\\n    seen = set()\\n    unique_commands = []\\n    for cmd in commands:\\n        if cmd not in seen:\\n            seen.add(cmd)\\n            unique_commands.append(cmd)\\n    \\n    commands = \\'\\'.join(unique_commands)\\n    \\n    success_count = 0\\n    total_count = 0\\n    \\n    print(f\"[RUN] Prsist Memory: Running {len(commands)} command(s)\")\\n    print(\"-\" * 50)\\n    \\n    for i, cmd in enumerate(commands):\\n        if cmd in COMMAND_MAP:\\n            if i > 0:\\n                print()  # Space between commands\\n            success = COMMAND_MAP[cmd]()\\n            total_count += 1\\n            if success:\\n                success_count += 1\\n        else:\\n            print(f\"[ERROR] Unknown command: -{cmd}\")\\n            total_count += 1\\n    \\n    print(\"-\" * 50)\\n    print(f\"[DONE] {success_count}/{total_count} commands completed successfully\")\\n\\nif __name__ == \"__main__\":\\n    main()', 'structuredPatch': [{'oldStart': 159, 'oldLines': 13, 'newStart': 159, 'newLines': 13, 'lines': ['         ', '         full_session_data = None', '         if archived_file.exists():', \"-            with open(archived_file, 'r') as f:\", \"+            with open(archived_file, 'r', encoding='utf-8') as f:\", '                 full_session_data = json.load(f)', '         else:', '             # Try active session file', '             active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"', '             if active_file.exists():', \"-                with open(active_file, 'r') as f:\", \"+                with open(active_file, 'r', encoding='utf-8') as f:\", '                     temp_data = json.load(f)', \"                     if temp_data.get('id') == session_id:\", '                         full_session_data = temp_data']}], 'userModified': False, 'replaceAll': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Bash",
        "timestamp": "2025-08-24T19:01:02.322380",
        "input_data": {
          "command": "python .prsist/bin/prsist.py -r",
          "description": "Test with UTF-8 encoding fix"
        },
        "output_data": "{'stdout': '[RUN] Prsist Memory: Running 1 command(s)\\r\\n--------------------------------------------------\\r\\n[RECENT] Recent Sessions...\\r\\n  - 15859307: Worked on: system improvements, Create contextual session desc\\r\\n  - fe62facb: Light development work (4 operations)\\r\\n  - e6dca0ec: Documentation and code review (12 operations)\\r\\n  - f02444bf: Light development work (2 operations)\\r\\n  - ca0cdd1e: Light development work (2 operations)\\r\\n--------------------------------------------------\\r\\n[DONE] 1/1 commands completed successfully\\r\\n2025-08-24 19:01:01,586 - root - INFO - Memory manager initialized\\r', 'stderr': '', 'interrupted': False, 'isImage': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Bash",
        "timestamp": "2025-08-24T19:01:02.654763",
        "input_data": {
          "command": "python .prsist/bin/prsist.py -r",
          "description": "Test with UTF-8 encoding fix"
        },
        "output_data": "{'stdout': '[RUN] Prsist Memory: Running 1 command(s)\\r\\n--------------------------------------------------\\r\\n[RECENT] Recent Sessions...\\r\\n  - 15859307: Worked on: system improvements, Create contextual session desc\\r\\n  - fe62facb: Light development work (4 operations)\\r\\n  - e6dca0ec: Documentation and code review (12 operations)\\r\\n  - f02444bf: Light development work (2 operations)\\r\\n  - ca0cdd1e: Light development work (2 operations)\\r\\n--------------------------------------------------\\r\\n[DONE] 1/1 commands completed successfully\\r\\n2025-08-24 19:01:01,586 - root - INFO - Memory manager initialized\\r', 'stderr': '', 'interrupted': False, 'isImage': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Edit",
        "timestamp": "2025-08-24T19:01:18.260019",
        "input_data": {
          "file_path": ".prsist/bin/prsist.py",
          "old_string": "print(f\"[DEBUG] Session description error: {e}\")  # Temporary debug",
          "new_string": "logging.debug(f\"Failed to generate session description: {e}\")"
        },
        "output_data": "{'filePath': '.prsist/bin/prsist.py', 'oldString': '        print(f\"[DEBUG] Session description error: {e}\")  # Temporary debug', 'newString': '        logging.debug(f\"Failed to generate session description: {e}\")', 'originalFile': '#!/usr/bin/env python3\\n\"\"\"\\nPrsist Memory System CLI - Simple, memorable commands\\nUsage: prsist [options]\\n\\nSingle Letter Options:\\n  -t  Test system\\n  -s  Status/session info  \\n  -c  Context (what Claude sees)\\n  -r  Recent sessions\\n  -h  Health check\\n  -f  Feature log (interactive)\\n  -m  Memory stats\\n  -v  Validate system\\n  -p  Project memory operations\\n  -d  Decisions (add decision)\\n  -e  End session\\n  -n  New session (start)\\n  -k  Checkpoint (create)\\n  -x  Export session data\\n  -z  Cleanup old data\\n  -l  List all commands\\n  -a  All checks (equivalent to -tschrmv)\\n  \\nChain commands: prsist -tsc (test + status + context)\\nExamples:\\n  prsist -t        Test system\\n  prsist -h        Health check\\n  prsist -tsc      Test + Status + Context\\n  prsist -a        Run all checks\\n  prsist -hm       Health + Memory stats\\n\"\"\"\\n\\nimport sys\\nimport os\\nimport json\\nimport logging\\nfrom pathlib import Path\\n\\n# Add parent directory to path for imports\\nsys.path.insert(0, str(Path(__file__).parent.parent))\\n\\ndef test_system():\\n    \"\"\"Test complete memory system\"\"\"\\n    print(\"[TEST] Testing Memory System...\")\\n    try:\\n        import subprocess\\n        result = subprocess.run([sys.executable, \"../tests/test_system.py\"], \\n                              capture_output=True, text=True, cwd=Path(__file__).parent)\\n        if result.returncode == 0:\\n            print(\"[PASS] All tests passed!\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Tests failed: {result.stderr}\")\\n            return False\\n    except Exception as e:\\n        print(f\"[ERROR] Test error: {e}\")\\n        return False\\n\\ndef session_status():\\n    \"\"\"Get current session status\"\"\"\\n    print(\"[STATUS] Session Status...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        info = mm.get_session_info()\\n        \\n        if info.get(\"session_id\"):\\n            print(f\"  Active Session: {info[\\'session_id\\'][:8]}...\")\\n            print(f\"  Tools Used: {info.get(\\'tool_usage_count\\', 0)}\")\\n            print(f\"  Files Modified: {info.get(\\'file_interaction_count\\', 0)}\")\\n            print(f\"  Duration: {info.get(\\'duration_minutes\\', 0)} minutes\")\\n        else:\\n            print(\"  No active session\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Status error: {e}\")\\n        return False\\n\\ndef show_context():\\n    \"\"\"Show current context (what Claude sees)\"\"\"\\n    print(\"[CONTEXT] Current Context...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        context = mm.get_session_context()\\n        \\n        if context:\\n            lines = context.split(\\'\\\\n\\')\\n            print(f\"  Context Length: {len(context)} characters\")\\n            print(f\"  Lines: {len(lines)}\")\\n            print(\"  Preview:\")\\n            for i, line in enumerate(lines[:5]):\\n                print(f\"    {line[:70]}{\\'...\\' if len(line) > 70 else \\'\\'}\")\\n            if len(lines) > 5:\\n                print(f\"    ... and {len(lines) - 5} more lines\")\\n        else:\\n            print(\"  No context available\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Context error: {e}\")\\n        return False\\n\\ndef recent_sessions():\\n    \"\"\"Show recent sessions with enhanced descriptions\"\"\"\\n    print(\"[RECENT] Recent Sessions...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        sessions = mm.get_recent_sessions(5)\\n        \\n        if sessions:\\n            # Check for current active session\\n            current_session_id = None\\n            try:\\n                current_context = mm.get_session_context()\\n                current_session_id = current_context.get(\"session_id\")\\n            except:\\n                pass\\n            \\n            for i, session in enumerate(sessions):\\n                # Generate meaningful description\\n                description = generate_session_description(session)\\n                session_id = session.get(\"session_id\", \"Unknown\")\\n                short_id = session_id[:8] if session_id != \"Unknown\" else \"Unknown\"\\n                \\n                if i == 0 and session_id == current_session_id:\\n                    # Current active session - enhanced display\\n                    print(f\"ðŸ”„ Active Session ({short_id})\")\\n                    print(f\"  - Activity: {description}\")\\n                    print(f\"  - Focus: Enhanced session descriptions and memory system improvements\")\\n                    print(f\"  - Status: Currently active\")\\n                    print(\"\")\\n                    print(\"ðŸ“– Previous Sessions:\")\\n                elif i == 0:\\n                    # First session but not current\\n                    print(f\"  - {short_id}: {description}\")\\n                else:\\n                    # Previous sessions\\n                    print(f\"  - {short_id}: {description}\")\\n        else:\\n            print(\"  No recent sessions found\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Recent sessions error: {e}\")\\n        return False\\n\\ndef generate_session_description(session_data):\\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\\n    try:\\n        # Get session details for rich context generation\\n        session_id = session_data.get(\\'session_id\\')\\n        if not session_id:\\n            return \"Unknown session\"\\n            \\n        # Try to load full session data from archived or active sessions\\n        memory_dir = Path(__file__).parent.parent\\n        archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\\n        \\n        full_session_data = None\\n        if archived_file.exists():\\n            with open(archived_file, \\'r\\', encoding=\\'utf-8\\') as f:\\n                full_session_data = json.load(f)\\n        else:\\n            # Try active session file\\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n            if active_file.exists():\\n                with open(active_file, \\'r\\', encoding=\\'utf-8\\') as f:\\n                    temp_data = json.load(f)\\n                    if temp_data.get(\\'id\\') == session_id:\\n                        full_session_data = temp_data\\n        \\n        if full_session_data:\\n            # Extract rich context from session data\\n            description = _extract_contextual_description(full_session_data, session_data)\\n            if description:\\n                return description\\n        \\n        # Fallback to enhanced generic descriptions\\n        tool_count = session_data.get(\\'tool_usage_count\\', 0)\\n        file_count = session_data.get(\\'file_interaction_count\\', 0)\\n        tools_used = session_data.get(\\'unique_tools_used\\', [])\\n        \\n        # Generate enhanced descriptions\\n        if file_count > 0 and tool_count > 0:\\n            if \\'Write\\' in tools_used and \\'Edit\\' in tools_used:\\n                return f\"Created and refined {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} ({tool_count} operations)\"\\n            elif \\'Write\\' in tools_used:\\n                return f\"New file development - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} created\"\\n            elif \\'Edit\\' in tools_used or \\'MultiEdit\\' in tools_used:\\n                return f\"Code editing session - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} modified\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Code analysis and exploration ({tool_count} operations)\"\\n        elif tool_count > 15:\\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command-heavy development session ({tool_count} operations)\"\\n        elif tool_count > 5:\\n            if \\'Bash\\' in tools_used:\\n                return f\"Command execution and testing ({tool_count} operations)\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Documentation and code review ({tool_count} operations)\"\\n        elif tool_count > 0:\\n            return f\"Light development work ({tool_count} operations)\"\\n        \\n        return \"Empty session\"\\n    except Exception as e:\\n        print(f\"[DEBUG] Session description error: {e}\")  # Temporary debug\\n        return \"Development session\"\\n\\n\\ndef _extract_contextual_description(full_session_data, session_summary):\\n    \"\"\"Extract meaningful context from full session data\"\"\"\\n    try:\\n        tool_usage = full_session_data.get(\\'tool_usage\\', [])\\n        file_interactions = full_session_data.get(\\'file_interactions\\', [])\\n        \\n        # Extract key information\\n        files_modified = []\\n        files_read = []\\n        commands_run = []\\n        searches_made = []\\n        todos_worked = []\\n        \\n        # Analyze tool usage for context\\n        for tool in tool_usage:\\n            tool_name = tool.get(\\'tool_name\\', \\'\\')\\n            input_data = tool.get(\\'input_data\\', {})\\n            \\n            if tool_name in [\\'Edit\\', \\'MultiEdit\\', \\'Write\\']:\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_modified.append(Path(file_path).name)\\n            elif tool_name == \\'Read\\':\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_read.append(Path(file_path).name)\\n            elif tool_name == \\'Bash\\':\\n                command = input_data.get(\\'command\\', \\'\\')\\n                if command:\\n                    commands_run.append(command)\\n            elif tool_name == \\'WebSearch\\':\\n                query = input_data.get(\\'query\\', \\'\\')\\n                if query:\\n                    searches_made.append(query)\\n            elif tool_name == \\'TodoWrite\\':\\n                todos = input_data.get(\\'todos\\', [])\\n                for todo in todos:\\n                    content = todo.get(\\'content\\', \\'\\')\\n                    if content and content not in todos_worked:\\n                        todos_worked.append(content)\\n        \\n        # Generate contextual description based on extracted data\\n        description_parts = []\\n        \\n        # Main activity identification\\n        if searches_made:\\n            for query in searches_made[:1]:  # Focus on first search\\n                if \\'mcp\\' in query.lower() or \\'context7\\' in query.lower():\\n                    description_parts.append(\"Researched and integrated Context7 MCP server\")\\n                    break\\n                elif \\'memory\\' in query.lower():\\n                    description_parts.append(\"Researched memory system implementation\")\\n                    break\\n                else:\\n                    description_parts.append(f\"Researched {query[:50]}\")\\n                    break\\n        \\n        if todos_worked:\\n            todo_descriptions = []\\n            for todo in todos_worked[:2]:  # Show first 2 todos\\n                if \\'mcp\\' in todo.lower() or \\'context7\\' in todo.lower():\\n                    todo_descriptions.append(\"MCP server setup\")\\n                elif \\'enhance\\' in todo.lower() or \\'improve\\' in todo.lower():\\n                    todo_descriptions.append(\"system improvements\")\\n                else:\\n                    todo_descriptions.append(todo[:30])\\n            \\n            if not description_parts:  # Only if no search activity found\\n                description_parts.append(f\"Worked on: {\\', \\'.join(todo_descriptions)}\")\\n        \\n        # File modification context\\n        if files_modified:\\n            unique_files = list(dict.fromkeys(files_modified))  # Remove duplicates\\n            if len(unique_files) == 1:\\n                file_name = unique_files[0]\\n                if \\'activity_analyzer\\' in file_name:\\n                    description_parts.append(f\"Enhanced session analysis in {file_name}\")\\n                elif \\'prsist\\' in file_name:\\n                    description_parts.append(f\"Improved memory CLI in {file_name}\")\\n                elif \\'memory\\' in file_name or \\'session\\' in file_name:\\n                    description_parts.append(f\"Updated memory system in {file_name}\")\\n                else:\\n                    description_parts.append(f\"Modified {file_name}\")\\n            elif len(unique_files) <= 3:\\n                description_parts.append(f\"Modified {\\', \\'.join(unique_files[:2])} + {len(unique_files)-2} more files\" if len(unique_files) > 2 else f\"Modified {\\', \\'.join(unique_files)}\")\\n            else:\\n                description_parts.append(f\"Modified {len(unique_files)} files including {\\', \\'.join(unique_files[:2])}\")\\n        \\n        # Command execution context\\n        if commands_run and not description_parts:\\n            command_contexts = []\\n            for cmd in commands_run[:3]:  # Look at first 3 commands\\n                if \\'mcp add\\' in cmd:\\n                    command_contexts.append(\"MCP server installation\")\\n                elif \\'mem\\' in cmd and \\'recent\\' in cmd:\\n                    command_contexts.append(\"memory system testing\")\\n                elif \\'python\\' in cmd and \\'prsist\\' in cmd:\\n                    command_contexts.append(\"memory CLI validation\")\\n                elif \\'npm\\' in cmd or \\'npx\\' in cmd:\\n                    command_contexts.append(\"package management\")\\n            \\n            if command_contexts:\\n                description_parts.append(\\', \\'.join(dict.fromkeys(command_contexts)))  # Remove duplicates\\n        \\n        # File reading context (only if no modifications)\\n        if files_read and not files_modified and not description_parts:\\n            unique_read = list(dict.fromkeys(files_read))\\n            if len(unique_read) == 1:\\n                description_parts.append(f\"Analyzed {unique_read[0]}\")\\n            elif len(unique_read) <= 3:\\n                description_parts.append(f\"Reviewed {\\', \\'.join(unique_read)}\")\\n            else:\\n                description_parts.append(f\"Explored {len(unique_read)} files\")\\n        \\n        # Combine description parts\\n        if description_parts:\\n            main_description = description_parts[0]\\n            \\n            # Add file context if not already included\\n            if files_modified and \\'Modified\\' not in main_description and \\'Enhanced\\' not in main_description:\\n                if len(files_modified) == 1:\\n                    main_description += f\" - modified {files_modified[0]}\"\\n                elif len(files_modified) <= 3:\\n                    main_description += f\" - modified {len(files_modified)} files\"\\n            \\n            return main_description\\n        \\n        return None\\n    except Exception as e:\\n        print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug\\n        return None\\n\\ndef health_check():\\n    \"\"\"System health check\"\"\"\\n    print(\"[HEALTH] Health Check...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        if validation[\"valid\"]:\\n            print(\"[PASS] System healthy\")\\n        else:\\n            print(\"[WARN] System issues found:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Health check error: {e}\")\\n        return False\\n\\ndef feature_log():\\n    \"\"\"Interactive feature logging\"\"\"\\n    print(\"[FEATURE] Feature Logging...\")\\n    try:\\n        feature_name = input(\"Feature name: \").strip()\\n        if not feature_name:\\n            print(\"[ERROR] Feature name required\")\\n            return False\\n            \\n        description = input(\"Description (optional): \").strip()\\n        \\n        import subprocess\\n        cmd = [sys.executable, \"hooks/FeatureComplete.py\", feature_name]\\n        if description:\\n            cmd.append(description)\\n            \\n        result = subprocess.run(cmd, capture_output=True, text=True, cwd=Path(__file__).parent)\\n        \\n        if result.returncode == 0:\\n            print(f\"[PASS] Feature \\'{feature_name}\\' logged successfully\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Feature logging failed: {result.stderr}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Feature logging cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Feature logging error: {e}\")\\n        return False\\n\\ndef memory_stats():\\n    \"\"\"Show memory system statistics\"\"\"\\n    print(\"[STATS] Memory Stats...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        stats = mm.get_memory_stats()\\n        \\n        print(f\"  Total Sessions: {stats.get(\\'total_sessions\\', 0)}\")\\n        print(f\"  Database Size: {stats.get(\\'database_size_mb\\', 0)} MB\")\\n        print(f\"  Active Session: {stats.get(\\'active_session\\', \\'None\\')}\")\\n        print(f\"  Project Root: {stats.get(\\'project_root\\', \\'Unknown\\')}\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Memory stats error: {e}\")\\n        return False\\n\\ndef validate_system():\\n    \"\"\"Validate system integrity\"\"\"\\n    print(\"[VALIDATE] System Validation...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        print(f\"  System Valid: {validation[\\'valid\\']}\")\\n        if not validation[\"valid\"]:\\n            print(\"  Issues:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Validation error: {e}\")\\n        return False\\n\\ndef project_memory():\\n    \"\"\"Add to project memory\"\"\"\\n    print(\"[PROJECT] Project Memory...\")\\n    try:\\n        content = input(\"Enter information to add to project memory: \").strip()\\n        if not content:\\n            print(\"[ERROR] Content required\")\\n            return False\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_project_memory(content)\\n        \\n        if success:\\n            print(f\"[PASS] Project memory updated\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to update project memory\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Project memory update cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Project memory error: {e}\")\\n        return False\\n\\ndef add_decision():\\n    \"\"\"Add a decision record\"\"\"\\n    print(\"[DECISION] Add Decision...\")\\n    try:\\n        title = input(\"Decision title: \").strip()\\n        if not title:\\n            print(\"[ERROR] Decision title required\")\\n            return False\\n            \\n        description = input(\"Description: \").strip()\\n        if not description:\\n            print(\"[ERROR] Description required\")\\n            return False\\n            \\n        category = input(\"Category (architecture/technical/process/design): \").strip()\\n        if not category:\\n            category = \"general\"\\n            \\n        impact = input(\"Impact (low/medium/high/critical): \").strip()\\n        if not impact:\\n            impact = \"medium\"\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_decision(title, description, category, impact)\\n        \\n        if success:\\n            print(f\"[PASS] Decision \\'{title}\\' recorded\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to record decision\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Decision recording cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Decision recording error: {e}\")\\n        return False\\n\\ndef end_session():\\n    \"\"\"End current session\"\"\"\\n    print(\"[END] Ending Session...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.end_session(archive=True)\\n        \\n        if result:\\n            print(\"[PASS] Session ended and archived\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to end\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] End session error: {e}\")\\n        return False\\n\\ndef new_session():\\n    \"\"\"Start new session\"\"\"\\n    print(\"[NEW] Starting New Session...\")\\n    try:\\n        context = input(\"Session context (optional): \").strip()\\n        \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        \\n        session_data = {}\\n        if context:\\n            session_data[\"context\"] = context\\n            \\n        result = mm.start_session(session_data)\\n        \\n        if result.get(\"memory_system_active\"):\\n            session_id = result.get(\"session_id\", \"unknown\")\\n            print(f\"[PASS] New session started: {session_id[:8]}...\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Failed to start session: {result.get(\\'error\\', \\'Unknown error\\')}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Session start cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] New session error: {e}\")\\n        return False\\n\\ndef create_checkpoint():\\n    \"\"\"Create a checkpoint\"\"\"\\n    print(\"[CHECKPOINT] Creating Checkpoint...\")\\n    try:\\n        name = input(\"Checkpoint name (optional): \").strip()\\n        if not name:\\n            name = None\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.create_checkpoint(name)\\n        \\n        if result:\\n            print(f\"[PASS] Checkpoint created: {name or \\'auto\\'}\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to create checkpoint\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Checkpoint creation cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Checkpoint error: {e}\")\\n        return False\\n\\ndef export_session():\\n    \"\"\"Export current session data\"\"\"\\n    print(\"[EXPORT] Exporting Session Data...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        data = mm.export_session_data(format=\"json\")\\n        \\n        if data:\\n            filename = f\"session_export_{mm.get_session_info().get(\\'session_id\\', \\'unknown\\')[:8]}.json\"\\n            with open(filename, \\'w\\') as f:\\n                f.write(data)\\n            print(f\"[PASS] Session exported to {filename}\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to export\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] Export error: {e}\")\\n        return False\\n\\ndef cleanup_data():\\n    \"\"\"Clean up old data\"\"\"\\n    print(\"[CLEANUP] Cleaning Up Old Data...\")\\n    try:\\n        days = input(\"Retention days (default 30): \").strip()\\n        if not days:\\n            days = 30\\n        else:\\n            days = int(days)\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.cleanup_old_data(retention_days=days)\\n        \\n        print(f\"[PASS] Cleanup completed: {result}\")\\n        return True\\n    except ValueError:\\n        print(\"[ERROR] Invalid number of days\")\\n        return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Cleanup cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Cleanup error: {e}\")\\n        return False\\n\\ndef list_commands():\\n    \"\"\"List all available commands\"\"\"\\n    print(\"[HELP] Prsist Memory System Commands:\")\\n    print(\"\\\\n  Core Operations:\")\\n    print(\"  -t  Test system\")\\n    print(\"  -s  Status/session info\")\\n    print(\"  -c  Context (what Claude sees)\")\\n    print(\"  -r  Recent sessions\")\\n    print(\"  -h  Health check\")\\n    print(\"  -m  Memory stats\")\\n    print(\"  -v  Validate system\")\\n    print(\"\\\\n  Session Management:\")\\n    print(\"  -n  New session (start)\")\\n    print(\"  -e  End session\")\\n    print(\"  -k  Checkpoint (create)\")\\n    print(\"  -x  Export session data\")\\n    print(\"\\\\n  Data Management:\")\\n    print(\"  -f  Feature log (interactive)\")\\n    print(\"  -p  Project memory (add)\")\\n    print(\"  -d  Decisions (add decision)\")\\n    print(\"  -z  Cleanup old data\")\\n    print(\"\\\\n  Shortcuts:\")\\n    print(\"  -a  All core checks (equivalent to -tschrmv)\")\\n    print(\"  -l  List commands (this help)\")\\n    print(\"\\\\nExamples:\")\\n    print(\"  prsist -t      (test system)\")\\n    print(\"  prsist -hm     (health + memory stats)\")\\n    print(\"  prsist -tsc    (test + status + context)\")\\n    print(\"  prsist -a      (run all core checks)\")\\n    print(\"  prsist -nf     (new session + feature log)\")\\n    return True\\n\\n# Command mapping\\nCOMMAND_MAP = {\\n    \\'t\\': test_system,\\n    \\'s\\': session_status,\\n    \\'c\\': show_context,\\n    \\'r\\': recent_sessions,\\n    \\'h\\': health_check,\\n    \\'f\\': feature_log,\\n    \\'m\\': memory_stats,\\n    \\'v\\': validate_system,\\n    \\'p\\': project_memory,\\n    \\'d\\': add_decision,\\n    \\'e\\': end_session,\\n    \\'n\\': new_session,\\n    \\'k\\': create_checkpoint,\\n    \\'x\\': export_session,\\n    \\'z\\': cleanup_data,\\n    \\'l\\': list_commands\\n}\\n\\ndef main():\\n    # Custom argument parser that handles combined flags like -tsc\\n    if len(sys.argv) < 2:\\n        print(\"Prsist Memory System CLI\")\\n        print(\"Usage: prsist [options]\")\\n        print(\"Example: prsist -t       (test)\")\\n        print(\"Example: prsist -tsc     (test + status + context)\")\\n        print(\"Example: prsist -a       (all checks)\")\\n        print(\"Use \\'prsist -l\\' to list all commands\")\\n        return\\n\\n    # Parse arguments manually to handle combined flags\\n    args = sys.argv[1]\\n    if args.startswith(\\'-\\'):\\n        commands = args[1:]  # Remove the dash\\n    else:\\n        commands = args\\n\\n    # Handle special \\'all\\' command\\n    if \\'a\\' in commands:\\n        commands = commands.replace(\\'a\\', \\'tschrmv\\')\\n\\n    # Remove duplicates while preserving order\\n    seen = set()\\n    unique_commands = []\\n    for cmd in commands:\\n        if cmd not in seen:\\n            seen.add(cmd)\\n            unique_commands.append(cmd)\\n    \\n    commands = \\'\\'.join(unique_commands)\\n    \\n    success_count = 0\\n    total_count = 0\\n    \\n    print(f\"[RUN] Prsist Memory: Running {len(commands)} command(s)\")\\n    print(\"-\" * 50)\\n    \\n    for i, cmd in enumerate(commands):\\n        if cmd in COMMAND_MAP:\\n            if i > 0:\\n                print()  # Space between commands\\n            success = COMMAND_MAP[cmd]()\\n            total_count += 1\\n            if success:\\n                success_count += 1\\n        else:\\n            print(f\"[ERROR] Unknown command: -{cmd}\")\\n            total_count += 1\\n    \\n    print(\"-\" * 50)\\n    print(f\"[DONE] {success_count}/{total_count} commands completed successfully\")\\n\\nif __name__ == \"__main__\":\\n    main()', 'structuredPatch': [{'oldStart': 206, 'oldLines': 7, 'newStart': 206, 'newLines': 7, 'lines': ['         ', '         return \"Empty session\"', '     except Exception as e:', '-        print(f\"[DEBUG] Session description error: {e}\")  # Temporary debug', '+        logging.debug(f\"Failed to generate session description: {e}\")', '         return \"Development session\"', ' ', ' ']}], 'userModified': False, 'replaceAll': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Edit",
        "timestamp": "2025-08-24T19:01:37.208783",
        "input_data": {
          "file_path": ".prsist/bin/prsist.py",
          "old_string": "print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug",
          "new_string": "logging.debug(f\"Failed to extract contextual description: {e}\")"
        },
        "output_data": "{'filePath': '.prsist/bin/prsist.py', 'oldString': '        print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug', 'newString': '        logging.debug(f\"Failed to extract contextual description: {e}\")', 'originalFile': '#!/usr/bin/env python3\\n\"\"\"\\nPrsist Memory System CLI - Simple, memorable commands\\nUsage: prsist [options]\\n\\nSingle Letter Options:\\n  -t  Test system\\n  -s  Status/session info  \\n  -c  Context (what Claude sees)\\n  -r  Recent sessions\\n  -h  Health check\\n  -f  Feature log (interactive)\\n  -m  Memory stats\\n  -v  Validate system\\n  -p  Project memory operations\\n  -d  Decisions (add decision)\\n  -e  End session\\n  -n  New session (start)\\n  -k  Checkpoint (create)\\n  -x  Export session data\\n  -z  Cleanup old data\\n  -l  List all commands\\n  -a  All checks (equivalent to -tschrmv)\\n  \\nChain commands: prsist -tsc (test + status + context)\\nExamples:\\n  prsist -t        Test system\\n  prsist -h        Health check\\n  prsist -tsc      Test + Status + Context\\n  prsist -a        Run all checks\\n  prsist -hm       Health + Memory stats\\n\"\"\"\\n\\nimport sys\\nimport os\\nimport json\\nimport logging\\nfrom pathlib import Path\\n\\n# Add parent directory to path for imports\\nsys.path.insert(0, str(Path(__file__).parent.parent))\\n\\ndef test_system():\\n    \"\"\"Test complete memory system\"\"\"\\n    print(\"[TEST] Testing Memory System...\")\\n    try:\\n        import subprocess\\n        result = subprocess.run([sys.executable, \"../tests/test_system.py\"], \\n                              capture_output=True, text=True, cwd=Path(__file__).parent)\\n        if result.returncode == 0:\\n            print(\"[PASS] All tests passed!\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Tests failed: {result.stderr}\")\\n            return False\\n    except Exception as e:\\n        print(f\"[ERROR] Test error: {e}\")\\n        return False\\n\\ndef session_status():\\n    \"\"\"Get current session status\"\"\"\\n    print(\"[STATUS] Session Status...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        info = mm.get_session_info()\\n        \\n        if info.get(\"session_id\"):\\n            print(f\"  Active Session: {info[\\'session_id\\'][:8]}...\")\\n            print(f\"  Tools Used: {info.get(\\'tool_usage_count\\', 0)}\")\\n            print(f\"  Files Modified: {info.get(\\'file_interaction_count\\', 0)}\")\\n            print(f\"  Duration: {info.get(\\'duration_minutes\\', 0)} minutes\")\\n        else:\\n            print(\"  No active session\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Status error: {e}\")\\n        return False\\n\\ndef show_context():\\n    \"\"\"Show current context (what Claude sees)\"\"\"\\n    print(\"[CONTEXT] Current Context...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        context = mm.get_session_context()\\n        \\n        if context:\\n            lines = context.split(\\'\\\\n\\')\\n            print(f\"  Context Length: {len(context)} characters\")\\n            print(f\"  Lines: {len(lines)}\")\\n            print(\"  Preview:\")\\n            for i, line in enumerate(lines[:5]):\\n                print(f\"    {line[:70]}{\\'...\\' if len(line) > 70 else \\'\\'}\")\\n            if len(lines) > 5:\\n                print(f\"    ... and {len(lines) - 5} more lines\")\\n        else:\\n            print(\"  No context available\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Context error: {e}\")\\n        return False\\n\\ndef recent_sessions():\\n    \"\"\"Show recent sessions with enhanced descriptions\"\"\"\\n    print(\"[RECENT] Recent Sessions...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        sessions = mm.get_recent_sessions(5)\\n        \\n        if sessions:\\n            # Check for current active session\\n            current_session_id = None\\n            try:\\n                current_context = mm.get_session_context()\\n                current_session_id = current_context.get(\"session_id\")\\n            except:\\n                pass\\n            \\n            for i, session in enumerate(sessions):\\n                # Generate meaningful description\\n                description = generate_session_description(session)\\n                session_id = session.get(\"session_id\", \"Unknown\")\\n                short_id = session_id[:8] if session_id != \"Unknown\" else \"Unknown\"\\n                \\n                if i == 0 and session_id == current_session_id:\\n                    # Current active session - enhanced display\\n                    print(f\"ðŸ”„ Active Session ({short_id})\")\\n                    print(f\"  - Activity: {description}\")\\n                    print(f\"  - Focus: Enhanced session descriptions and memory system improvements\")\\n                    print(f\"  - Status: Currently active\")\\n                    print(\"\")\\n                    print(\"ðŸ“– Previous Sessions:\")\\n                elif i == 0:\\n                    # First session but not current\\n                    print(f\"  - {short_id}: {description}\")\\n                else:\\n                    # Previous sessions\\n                    print(f\"  - {short_id}: {description}\")\\n        else:\\n            print(\"  No recent sessions found\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Recent sessions error: {e}\")\\n        return False\\n\\ndef generate_session_description(session_data):\\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\\n    try:\\n        # Get session details for rich context generation\\n        session_id = session_data.get(\\'session_id\\')\\n        if not session_id:\\n            return \"Unknown session\"\\n            \\n        # Try to load full session data from archived or active sessions\\n        memory_dir = Path(__file__).parent.parent\\n        archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\\n        \\n        full_session_data = None\\n        if archived_file.exists():\\n            with open(archived_file, \\'r\\', encoding=\\'utf-8\\') as f:\\n                full_session_data = json.load(f)\\n        else:\\n            # Try active session file\\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n            if active_file.exists():\\n                with open(active_file, \\'r\\', encoding=\\'utf-8\\') as f:\\n                    temp_data = json.load(f)\\n                    if temp_data.get(\\'id\\') == session_id:\\n                        full_session_data = temp_data\\n        \\n        if full_session_data:\\n            # Extract rich context from session data\\n            description = _extract_contextual_description(full_session_data, session_data)\\n            if description:\\n                return description\\n        \\n        # Fallback to enhanced generic descriptions\\n        tool_count = session_data.get(\\'tool_usage_count\\', 0)\\n        file_count = session_data.get(\\'file_interaction_count\\', 0)\\n        tools_used = session_data.get(\\'unique_tools_used\\', [])\\n        \\n        # Generate enhanced descriptions\\n        if file_count > 0 and tool_count > 0:\\n            if \\'Write\\' in tools_used and \\'Edit\\' in tools_used:\\n                return f\"Created and refined {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} ({tool_count} operations)\"\\n            elif \\'Write\\' in tools_used:\\n                return f\"New file development - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} created\"\\n            elif \\'Edit\\' in tools_used or \\'MultiEdit\\' in tools_used:\\n                return f\"Code editing session - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} modified\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Code analysis and exploration ({tool_count} operations)\"\\n        elif tool_count > 15:\\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command-heavy development session ({tool_count} operations)\"\\n        elif tool_count > 5:\\n            if \\'Bash\\' in tools_used:\\n                return f\"Command execution and testing ({tool_count} operations)\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Documentation and code review ({tool_count} operations)\"\\n        elif tool_count > 0:\\n            return f\"Light development work ({tool_count} operations)\"\\n        \\n        return \"Empty session\"\\n    except Exception as e:\\n        logging.debug(f\"Failed to generate session description: {e}\")\\n        return \"Development session\"\\n\\n\\ndef _extract_contextual_description(full_session_data, session_summary):\\n    \"\"\"Extract meaningful context from full session data\"\"\"\\n    try:\\n        tool_usage = full_session_data.get(\\'tool_usage\\', [])\\n        file_interactions = full_session_data.get(\\'file_interactions\\', [])\\n        \\n        # Extract key information\\n        files_modified = []\\n        files_read = []\\n        commands_run = []\\n        searches_made = []\\n        todos_worked = []\\n        \\n        # Analyze tool usage for context\\n        for tool in tool_usage:\\n            tool_name = tool.get(\\'tool_name\\', \\'\\')\\n            input_data = tool.get(\\'input_data\\', {})\\n            \\n            if tool_name in [\\'Edit\\', \\'MultiEdit\\', \\'Write\\']:\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_modified.append(Path(file_path).name)\\n            elif tool_name == \\'Read\\':\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_read.append(Path(file_path).name)\\n            elif tool_name == \\'Bash\\':\\n                command = input_data.get(\\'command\\', \\'\\')\\n                if command:\\n                    commands_run.append(command)\\n            elif tool_name == \\'WebSearch\\':\\n                query = input_data.get(\\'query\\', \\'\\')\\n                if query:\\n                    searches_made.append(query)\\n            elif tool_name == \\'TodoWrite\\':\\n                todos = input_data.get(\\'todos\\', [])\\n                for todo in todos:\\n                    content = todo.get(\\'content\\', \\'\\')\\n                    if content and content not in todos_worked:\\n                        todos_worked.append(content)\\n        \\n        # Generate contextual description based on extracted data\\n        description_parts = []\\n        \\n        # Main activity identification\\n        if searches_made:\\n            for query in searches_made[:1]:  # Focus on first search\\n                if \\'mcp\\' in query.lower() or \\'context7\\' in query.lower():\\n                    description_parts.append(\"Researched and integrated Context7 MCP server\")\\n                    break\\n                elif \\'memory\\' in query.lower():\\n                    description_parts.append(\"Researched memory system implementation\")\\n                    break\\n                else:\\n                    description_parts.append(f\"Researched {query[:50]}\")\\n                    break\\n        \\n        if todos_worked:\\n            todo_descriptions = []\\n            for todo in todos_worked[:2]:  # Show first 2 todos\\n                if \\'mcp\\' in todo.lower() or \\'context7\\' in todo.lower():\\n                    todo_descriptions.append(\"MCP server setup\")\\n                elif \\'enhance\\' in todo.lower() or \\'improve\\' in todo.lower():\\n                    todo_descriptions.append(\"system improvements\")\\n                else:\\n                    todo_descriptions.append(todo[:30])\\n            \\n            if not description_parts:  # Only if no search activity found\\n                description_parts.append(f\"Worked on: {\\', \\'.join(todo_descriptions)}\")\\n        \\n        # File modification context\\n        if files_modified:\\n            unique_files = list(dict.fromkeys(files_modified))  # Remove duplicates\\n            if len(unique_files) == 1:\\n                file_name = unique_files[0]\\n                if \\'activity_analyzer\\' in file_name:\\n                    description_parts.append(f\"Enhanced session analysis in {file_name}\")\\n                elif \\'prsist\\' in file_name:\\n                    description_parts.append(f\"Improved memory CLI in {file_name}\")\\n                elif \\'memory\\' in file_name or \\'session\\' in file_name:\\n                    description_parts.append(f\"Updated memory system in {file_name}\")\\n                else:\\n                    description_parts.append(f\"Modified {file_name}\")\\n            elif len(unique_files) <= 3:\\n                description_parts.append(f\"Modified {\\', \\'.join(unique_files[:2])} + {len(unique_files)-2} more files\" if len(unique_files) > 2 else f\"Modified {\\', \\'.join(unique_files)}\")\\n            else:\\n                description_parts.append(f\"Modified {len(unique_files)} files including {\\', \\'.join(unique_files[:2])}\")\\n        \\n        # Command execution context\\n        if commands_run and not description_parts:\\n            command_contexts = []\\n            for cmd in commands_run[:3]:  # Look at first 3 commands\\n                if \\'mcp add\\' in cmd:\\n                    command_contexts.append(\"MCP server installation\")\\n                elif \\'mem\\' in cmd and \\'recent\\' in cmd:\\n                    command_contexts.append(\"memory system testing\")\\n                elif \\'python\\' in cmd and \\'prsist\\' in cmd:\\n                    command_contexts.append(\"memory CLI validation\")\\n                elif \\'npm\\' in cmd or \\'npx\\' in cmd:\\n                    command_contexts.append(\"package management\")\\n            \\n            if command_contexts:\\n                description_parts.append(\\', \\'.join(dict.fromkeys(command_contexts)))  # Remove duplicates\\n        \\n        # File reading context (only if no modifications)\\n        if files_read and not files_modified and not description_parts:\\n            unique_read = list(dict.fromkeys(files_read))\\n            if len(unique_read) == 1:\\n                description_parts.append(f\"Analyzed {unique_read[0]}\")\\n            elif len(unique_read) <= 3:\\n                description_parts.append(f\"Reviewed {\\', \\'.join(unique_read)}\")\\n            else:\\n                description_parts.append(f\"Explored {len(unique_read)} files\")\\n        \\n        # Combine description parts\\n        if description_parts:\\n            main_description = description_parts[0]\\n            \\n            # Add file context if not already included\\n            if files_modified and \\'Modified\\' not in main_description and \\'Enhanced\\' not in main_description:\\n                if len(files_modified) == 1:\\n                    main_description += f\" - modified {files_modified[0]}\"\\n                elif len(files_modified) <= 3:\\n                    main_description += f\" - modified {len(files_modified)} files\"\\n            \\n            return main_description\\n        \\n        return None\\n    except Exception as e:\\n        print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug\\n        return None\\n\\ndef health_check():\\n    \"\"\"System health check\"\"\"\\n    print(\"[HEALTH] Health Check...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        if validation[\"valid\"]:\\n            print(\"[PASS] System healthy\")\\n        else:\\n            print(\"[WARN] System issues found:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Health check error: {e}\")\\n        return False\\n\\ndef feature_log():\\n    \"\"\"Interactive feature logging\"\"\"\\n    print(\"[FEATURE] Feature Logging...\")\\n    try:\\n        feature_name = input(\"Feature name: \").strip()\\n        if not feature_name:\\n            print(\"[ERROR] Feature name required\")\\n            return False\\n            \\n        description = input(\"Description (optional): \").strip()\\n        \\n        import subprocess\\n        cmd = [sys.executable, \"hooks/FeatureComplete.py\", feature_name]\\n        if description:\\n            cmd.append(description)\\n            \\n        result = subprocess.run(cmd, capture_output=True, text=True, cwd=Path(__file__).parent)\\n        \\n        if result.returncode == 0:\\n            print(f\"[PASS] Feature \\'{feature_name}\\' logged successfully\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Feature logging failed: {result.stderr}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Feature logging cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Feature logging error: {e}\")\\n        return False\\n\\ndef memory_stats():\\n    \"\"\"Show memory system statistics\"\"\"\\n    print(\"[STATS] Memory Stats...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        stats = mm.get_memory_stats()\\n        \\n        print(f\"  Total Sessions: {stats.get(\\'total_sessions\\', 0)}\")\\n        print(f\"  Database Size: {stats.get(\\'database_size_mb\\', 0)} MB\")\\n        print(f\"  Active Session: {stats.get(\\'active_session\\', \\'None\\')}\")\\n        print(f\"  Project Root: {stats.get(\\'project_root\\', \\'Unknown\\')}\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Memory stats error: {e}\")\\n        return False\\n\\ndef validate_system():\\n    \"\"\"Validate system integrity\"\"\"\\n    print(\"[VALIDATE] System Validation...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        print(f\"  System Valid: {validation[\\'valid\\']}\")\\n        if not validation[\"valid\"]:\\n            print(\"  Issues:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Validation error: {e}\")\\n        return False\\n\\ndef project_memory():\\n    \"\"\"Add to project memory\"\"\"\\n    print(\"[PROJECT] Project Memory...\")\\n    try:\\n        content = input(\"Enter information to add to project memory: \").strip()\\n        if not content:\\n            print(\"[ERROR] Content required\")\\n            return False\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_project_memory(content)\\n        \\n        if success:\\n            print(f\"[PASS] Project memory updated\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to update project memory\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Project memory update cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Project memory error: {e}\")\\n        return False\\n\\ndef add_decision():\\n    \"\"\"Add a decision record\"\"\"\\n    print(\"[DECISION] Add Decision...\")\\n    try:\\n        title = input(\"Decision title: \").strip()\\n        if not title:\\n            print(\"[ERROR] Decision title required\")\\n            return False\\n            \\n        description = input(\"Description: \").strip()\\n        if not description:\\n            print(\"[ERROR] Description required\")\\n            return False\\n            \\n        category = input(\"Category (architecture/technical/process/design): \").strip()\\n        if not category:\\n            category = \"general\"\\n            \\n        impact = input(\"Impact (low/medium/high/critical): \").strip()\\n        if not impact:\\n            impact = \"medium\"\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_decision(title, description, category, impact)\\n        \\n        if success:\\n            print(f\"[PASS] Decision \\'{title}\\' recorded\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to record decision\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Decision recording cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Decision recording error: {e}\")\\n        return False\\n\\ndef end_session():\\n    \"\"\"End current session\"\"\"\\n    print(\"[END] Ending Session...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.end_session(archive=True)\\n        \\n        if result:\\n            print(\"[PASS] Session ended and archived\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to end\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] End session error: {e}\")\\n        return False\\n\\ndef new_session():\\n    \"\"\"Start new session\"\"\"\\n    print(\"[NEW] Starting New Session...\")\\n    try:\\n        context = input(\"Session context (optional): \").strip()\\n        \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        \\n        session_data = {}\\n        if context:\\n            session_data[\"context\"] = context\\n            \\n        result = mm.start_session(session_data)\\n        \\n        if result.get(\"memory_system_active\"):\\n            session_id = result.get(\"session_id\", \"unknown\")\\n            print(f\"[PASS] New session started: {session_id[:8]}...\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Failed to start session: {result.get(\\'error\\', \\'Unknown error\\')}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Session start cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] New session error: {e}\")\\n        return False\\n\\ndef create_checkpoint():\\n    \"\"\"Create a checkpoint\"\"\"\\n    print(\"[CHECKPOINT] Creating Checkpoint...\")\\n    try:\\n        name = input(\"Checkpoint name (optional): \").strip()\\n        if not name:\\n            name = None\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.create_checkpoint(name)\\n        \\n        if result:\\n            print(f\"[PASS] Checkpoint created: {name or \\'auto\\'}\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to create checkpoint\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Checkpoint creation cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Checkpoint error: {e}\")\\n        return False\\n\\ndef export_session():\\n    \"\"\"Export current session data\"\"\"\\n    print(\"[EXPORT] Exporting Session Data...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        data = mm.export_session_data(format=\"json\")\\n        \\n        if data:\\n            filename = f\"session_export_{mm.get_session_info().get(\\'session_id\\', \\'unknown\\')[:8]}.json\"\\n            with open(filename, \\'w\\') as f:\\n                f.write(data)\\n            print(f\"[PASS] Session exported to {filename}\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to export\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] Export error: {e}\")\\n        return False\\n\\ndef cleanup_data():\\n    \"\"\"Clean up old data\"\"\"\\n    print(\"[CLEANUP] Cleaning Up Old Data...\")\\n    try:\\n        days = input(\"Retention days (default 30): \").strip()\\n        if not days:\\n            days = 30\\n        else:\\n            days = int(days)\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.cleanup_old_data(retention_days=days)\\n        \\n        print(f\"[PASS] Cleanup completed: {result}\")\\n        return True\\n    except ValueError:\\n        print(\"[ERROR] Invalid number of days\")\\n        return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Cleanup cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Cleanup error: {e}\")\\n        return False\\n\\ndef list_commands():\\n    \"\"\"List all available commands\"\"\"\\n    print(\"[HELP] Prsist Memory System Commands:\")\\n    print(\"\\\\n  Core Operations:\")\\n    print(\"  -t  Test system\")\\n    print(\"  -s  Status/session info\")\\n    print(\"  -c  Context (what Claude sees)\")\\n    print(\"  -r  Recent sessions\")\\n    print(\"  -h  Health check\")\\n    print(\"  -m  Memory stats\")\\n    print(\"  -v  Validate system\")\\n    print(\"\\\\n  Session Management:\")\\n    print(\"  -n  New session (start)\")\\n    print(\"  -e  End session\")\\n    print(\"  -k  Checkpoint (create)\")\\n    print(\"  -x  Export session data\")\\n    print(\"\\\\n  Data Management:\")\\n    print(\"  -f  Feature log (interactive)\")\\n    print(\"  -p  Project memory (add)\")\\n    print(\"  -d  Decisions (add decision)\")\\n    print(\"  -z  Cleanup old data\")\\n    print(\"\\\\n  Shortcuts:\")\\n    print(\"  -a  All core checks (equivalent to -tschrmv)\")\\n    print(\"  -l  List commands (this help)\")\\n    print(\"\\\\nExamples:\")\\n    print(\"  prsist -t      (test system)\")\\n    print(\"  prsist -hm     (health + memory stats)\")\\n    print(\"  prsist -tsc    (test + status + context)\")\\n    print(\"  prsist -a      (run all core checks)\")\\n    print(\"  prsist -nf     (new session + feature log)\")\\n    return True\\n\\n# Command mapping\\nCOMMAND_MAP = {\\n    \\'t\\': test_system,\\n    \\'s\\': session_status,\\n    \\'c\\': show_context,\\n    \\'r\\': recent_sessions,\\n    \\'h\\': health_check,\\n    \\'f\\': feature_log,\\n    \\'m\\': memory_stats,\\n    \\'v\\': validate_system,\\n    \\'p\\': project_memory,\\n    \\'d\\': add_decision,\\n    \\'e\\': end_session,\\n    \\'n\\': new_session,\\n    \\'k\\': create_checkpoint,\\n    \\'x\\': export_session,\\n    \\'z\\': cleanup_data,\\n    \\'l\\': list_commands\\n}\\n\\ndef main():\\n    # Custom argument parser that handles combined flags like -tsc\\n    if len(sys.argv) < 2:\\n        print(\"Prsist Memory System CLI\")\\n        print(\"Usage: prsist [options]\")\\n        print(\"Example: prsist -t       (test)\")\\n        print(\"Example: prsist -tsc     (test + status + context)\")\\n        print(\"Example: prsist -a       (all checks)\")\\n        print(\"Use \\'prsist -l\\' to list all commands\")\\n        return\\n\\n    # Parse arguments manually to handle combined flags\\n    args = sys.argv[1]\\n    if args.startswith(\\'-\\'):\\n        commands = args[1:]  # Remove the dash\\n    else:\\n        commands = args\\n\\n    # Handle special \\'all\\' command\\n    if \\'a\\' in commands:\\n        commands = commands.replace(\\'a\\', \\'tschrmv\\')\\n\\n    # Remove duplicates while preserving order\\n    seen = set()\\n    unique_commands = []\\n    for cmd in commands:\\n        if cmd not in seen:\\n            seen.add(cmd)\\n            unique_commands.append(cmd)\\n    \\n    commands = \\'\\'.join(unique_commands)\\n    \\n    success_count = 0\\n    total_count = 0\\n    \\n    print(f\"[RUN] Prsist Memory: Running {len(commands)} command(s)\")\\n    print(\"-\" * 50)\\n    \\n    for i, cmd in enumerate(commands):\\n        if cmd in COMMAND_MAP:\\n            if i > 0:\\n                print()  # Space between commands\\n            success = COMMAND_MAP[cmd]()\\n            total_count += 1\\n            if success:\\n                success_count += 1\\n        else:\\n            print(f\"[ERROR] Unknown command: -{cmd}\")\\n            total_count += 1\\n    \\n    print(\"-\" * 50)\\n    print(f\"[DONE] {success_count}/{total_count} commands completed successfully\")\\n\\nif __name__ == \"__main__\":\\n    main()', 'structuredPatch': [{'oldStart': 339, 'oldLines': 7, 'newStart': 339, 'newLines': 7, 'lines': ['         ', '         return None', '     except Exception as e:', '-        print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug', '+        logging.debug(f\"Failed to extract contextual description: {e}\")', '         return None', ' ', ' def health_check():']}], 'userModified': False, 'replaceAll': False}",
        "execution_time_ms": 0,
        "success": true
      },
      {
        "tool_name": "Edit",
        "timestamp": "2025-08-24T19:01:37.785879",
        "input_data": {
          "file_path": ".prsist/bin/prsist.py",
          "old_string": "print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug",
          "new_string": "logging.debug(f\"Failed to extract contextual description: {e}\")"
        },
        "output_data": "{'filePath': '.prsist/bin/prsist.py', 'oldString': '        print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug', 'newString': '        logging.debug(f\"Failed to extract contextual description: {e}\")', 'originalFile': '#!/usr/bin/env python3\\n\"\"\"\\nPrsist Memory System CLI - Simple, memorable commands\\nUsage: prsist [options]\\n\\nSingle Letter Options:\\n  -t  Test system\\n  -s  Status/session info  \\n  -c  Context (what Claude sees)\\n  -r  Recent sessions\\n  -h  Health check\\n  -f  Feature log (interactive)\\n  -m  Memory stats\\n  -v  Validate system\\n  -p  Project memory operations\\n  -d  Decisions (add decision)\\n  -e  End session\\n  -n  New session (start)\\n  -k  Checkpoint (create)\\n  -x  Export session data\\n  -z  Cleanup old data\\n  -l  List all commands\\n  -a  All checks (equivalent to -tschrmv)\\n  \\nChain commands: prsist -tsc (test + status + context)\\nExamples:\\n  prsist -t        Test system\\n  prsist -h        Health check\\n  prsist -tsc      Test + Status + Context\\n  prsist -a        Run all checks\\n  prsist -hm       Health + Memory stats\\n\"\"\"\\n\\nimport sys\\nimport os\\nimport json\\nimport logging\\nfrom pathlib import Path\\n\\n# Add parent directory to path for imports\\nsys.path.insert(0, str(Path(__file__).parent.parent))\\n\\ndef test_system():\\n    \"\"\"Test complete memory system\"\"\"\\n    print(\"[TEST] Testing Memory System...\")\\n    try:\\n        import subprocess\\n        result = subprocess.run([sys.executable, \"../tests/test_system.py\"], \\n                              capture_output=True, text=True, cwd=Path(__file__).parent)\\n        if result.returncode == 0:\\n            print(\"[PASS] All tests passed!\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Tests failed: {result.stderr}\")\\n            return False\\n    except Exception as e:\\n        print(f\"[ERROR] Test error: {e}\")\\n        return False\\n\\ndef session_status():\\n    \"\"\"Get current session status\"\"\"\\n    print(\"[STATUS] Session Status...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        info = mm.get_session_info()\\n        \\n        if info.get(\"session_id\"):\\n            print(f\"  Active Session: {info[\\'session_id\\'][:8]}...\")\\n            print(f\"  Tools Used: {info.get(\\'tool_usage_count\\', 0)}\")\\n            print(f\"  Files Modified: {info.get(\\'file_interaction_count\\', 0)}\")\\n            print(f\"  Duration: {info.get(\\'duration_minutes\\', 0)} minutes\")\\n        else:\\n            print(\"  No active session\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Status error: {e}\")\\n        return False\\n\\ndef show_context():\\n    \"\"\"Show current context (what Claude sees)\"\"\"\\n    print(\"[CONTEXT] Current Context...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        context = mm.get_session_context()\\n        \\n        if context:\\n            lines = context.split(\\'\\\\n\\')\\n            print(f\"  Context Length: {len(context)} characters\")\\n            print(f\"  Lines: {len(lines)}\")\\n            print(\"  Preview:\")\\n            for i, line in enumerate(lines[:5]):\\n                print(f\"    {line[:70]}{\\'...\\' if len(line) > 70 else \\'\\'}\")\\n            if len(lines) > 5:\\n                print(f\"    ... and {len(lines) - 5} more lines\")\\n        else:\\n            print(\"  No context available\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Context error: {e}\")\\n        return False\\n\\ndef recent_sessions():\\n    \"\"\"Show recent sessions with enhanced descriptions\"\"\"\\n    print(\"[RECENT] Recent Sessions...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        sessions = mm.get_recent_sessions(5)\\n        \\n        if sessions:\\n            # Check for current active session\\n            current_session_id = None\\n            try:\\n                current_context = mm.get_session_context()\\n                current_session_id = current_context.get(\"session_id\")\\n            except:\\n                pass\\n            \\n            for i, session in enumerate(sessions):\\n                # Generate meaningful description\\n                description = generate_session_description(session)\\n                session_id = session.get(\"session_id\", \"Unknown\")\\n                short_id = session_id[:8] if session_id != \"Unknown\" else \"Unknown\"\\n                \\n                if i == 0 and session_id == current_session_id:\\n                    # Current active session - enhanced display\\n                    print(f\"ðŸ”„ Active Session ({short_id})\")\\n                    print(f\"  - Activity: {description}\")\\n                    print(f\"  - Focus: Enhanced session descriptions and memory system improvements\")\\n                    print(f\"  - Status: Currently active\")\\n                    print(\"\")\\n                    print(\"ðŸ“– Previous Sessions:\")\\n                elif i == 0:\\n                    # First session but not current\\n                    print(f\"  - {short_id}: {description}\")\\n                else:\\n                    # Previous sessions\\n                    print(f\"  - {short_id}: {description}\")\\n        else:\\n            print(\"  No recent sessions found\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Recent sessions error: {e}\")\\n        return False\\n\\ndef generate_session_description(session_data):\\n    \"\"\"Generate a meaningful description for a session based on its activity\"\"\"\\n    try:\\n        # Get session details for rich context generation\\n        session_id = session_data.get(\\'session_id\\')\\n        if not session_id:\\n            return \"Unknown session\"\\n            \\n        # Try to load full session data from archived or active sessions\\n        memory_dir = Path(__file__).parent.parent\\n        archived_file = memory_dir / \"sessions\" / \"archived\" / f\"{session_id}.json\"\\n        \\n        full_session_data = None\\n        if archived_file.exists():\\n            with open(archived_file, \\'r\\', encoding=\\'utf-8\\') as f:\\n                full_session_data = json.load(f)\\n        else:\\n            # Try active session file\\n            active_file = memory_dir / \"sessions\" / \"active\" / \"current-session.json\"\\n            if active_file.exists():\\n                with open(active_file, \\'r\\', encoding=\\'utf-8\\') as f:\\n                    temp_data = json.load(f)\\n                    if temp_data.get(\\'id\\') == session_id:\\n                        full_session_data = temp_data\\n        \\n        if full_session_data:\\n            # Extract rich context from session data\\n            description = _extract_contextual_description(full_session_data, session_data)\\n            if description:\\n                return description\\n        \\n        # Fallback to enhanced generic descriptions\\n        tool_count = session_data.get(\\'tool_usage_count\\', 0)\\n        file_count = session_data.get(\\'file_interaction_count\\', 0)\\n        tools_used = session_data.get(\\'unique_tools_used\\', [])\\n        \\n        # Generate enhanced descriptions\\n        if file_count > 0 and tool_count > 0:\\n            if \\'Write\\' in tools_used and \\'Edit\\' in tools_used:\\n                return f\"Created and refined {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} ({tool_count} operations)\"\\n            elif \\'Write\\' in tools_used:\\n                return f\"New file development - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} created\"\\n            elif \\'Edit\\' in tools_used or \\'MultiEdit\\' in tools_used:\\n                return f\"Code editing session - {file_count} file{\\'s\\' if file_count > 1 else \\'\\'} modified\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Code analysis and exploration ({tool_count} operations)\"\\n        elif tool_count > 15:\\n            if \\'Read\\' in tools_used and \\'Grep\\' in tools_used:\\n                return f\"Extensive codebase exploration ({tool_count} operations)\"\\n            elif \\'Bash\\' in tools_used:\\n                return f\"Command-heavy development session ({tool_count} operations)\"\\n        elif tool_count > 5:\\n            if \\'Bash\\' in tools_used:\\n                return f\"Command execution and testing ({tool_count} operations)\"\\n            elif \\'Read\\' in tools_used:\\n                return f\"Documentation and code review ({tool_count} operations)\"\\n        elif tool_count > 0:\\n            return f\"Light development work ({tool_count} operations)\"\\n        \\n        return \"Empty session\"\\n    except Exception as e:\\n        logging.debug(f\"Failed to generate session description: {e}\")\\n        return \"Development session\"\\n\\n\\ndef _extract_contextual_description(full_session_data, session_summary):\\n    \"\"\"Extract meaningful context from full session data\"\"\"\\n    try:\\n        tool_usage = full_session_data.get(\\'tool_usage\\', [])\\n        file_interactions = full_session_data.get(\\'file_interactions\\', [])\\n        \\n        # Extract key information\\n        files_modified = []\\n        files_read = []\\n        commands_run = []\\n        searches_made = []\\n        todos_worked = []\\n        \\n        # Analyze tool usage for context\\n        for tool in tool_usage:\\n            tool_name = tool.get(\\'tool_name\\', \\'\\')\\n            input_data = tool.get(\\'input_data\\', {})\\n            \\n            if tool_name in [\\'Edit\\', \\'MultiEdit\\', \\'Write\\']:\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_modified.append(Path(file_path).name)\\n            elif tool_name == \\'Read\\':\\n                file_path = input_data.get(\\'file_path\\', \\'\\')\\n                if file_path:\\n                    files_read.append(Path(file_path).name)\\n            elif tool_name == \\'Bash\\':\\n                command = input_data.get(\\'command\\', \\'\\')\\n                if command:\\n                    commands_run.append(command)\\n            elif tool_name == \\'WebSearch\\':\\n                query = input_data.get(\\'query\\', \\'\\')\\n                if query:\\n                    searches_made.append(query)\\n            elif tool_name == \\'TodoWrite\\':\\n                todos = input_data.get(\\'todos\\', [])\\n                for todo in todos:\\n                    content = todo.get(\\'content\\', \\'\\')\\n                    if content and content not in todos_worked:\\n                        todos_worked.append(content)\\n        \\n        # Generate contextual description based on extracted data\\n        description_parts = []\\n        \\n        # Main activity identification\\n        if searches_made:\\n            for query in searches_made[:1]:  # Focus on first search\\n                if \\'mcp\\' in query.lower() or \\'context7\\' in query.lower():\\n                    description_parts.append(\"Researched and integrated Context7 MCP server\")\\n                    break\\n                elif \\'memory\\' in query.lower():\\n                    description_parts.append(\"Researched memory system implementation\")\\n                    break\\n                else:\\n                    description_parts.append(f\"Researched {query[:50]}\")\\n                    break\\n        \\n        if todos_worked:\\n            todo_descriptions = []\\n            for todo in todos_worked[:2]:  # Show first 2 todos\\n                if \\'mcp\\' in todo.lower() or \\'context7\\' in todo.lower():\\n                    todo_descriptions.append(\"MCP server setup\")\\n                elif \\'enhance\\' in todo.lower() or \\'improve\\' in todo.lower():\\n                    todo_descriptions.append(\"system improvements\")\\n                else:\\n                    todo_descriptions.append(todo[:30])\\n            \\n            if not description_parts:  # Only if no search activity found\\n                description_parts.append(f\"Worked on: {\\', \\'.join(todo_descriptions)}\")\\n        \\n        # File modification context\\n        if files_modified:\\n            unique_files = list(dict.fromkeys(files_modified))  # Remove duplicates\\n            if len(unique_files) == 1:\\n                file_name = unique_files[0]\\n                if \\'activity_analyzer\\' in file_name:\\n                    description_parts.append(f\"Enhanced session analysis in {file_name}\")\\n                elif \\'prsist\\' in file_name:\\n                    description_parts.append(f\"Improved memory CLI in {file_name}\")\\n                elif \\'memory\\' in file_name or \\'session\\' in file_name:\\n                    description_parts.append(f\"Updated memory system in {file_name}\")\\n                else:\\n                    description_parts.append(f\"Modified {file_name}\")\\n            elif len(unique_files) <= 3:\\n                description_parts.append(f\"Modified {\\', \\'.join(unique_files[:2])} + {len(unique_files)-2} more files\" if len(unique_files) > 2 else f\"Modified {\\', \\'.join(unique_files)}\")\\n            else:\\n                description_parts.append(f\"Modified {len(unique_files)} files including {\\', \\'.join(unique_files[:2])}\")\\n        \\n        # Command execution context\\n        if commands_run and not description_parts:\\n            command_contexts = []\\n            for cmd in commands_run[:3]:  # Look at first 3 commands\\n                if \\'mcp add\\' in cmd:\\n                    command_contexts.append(\"MCP server installation\")\\n                elif \\'mem\\' in cmd and \\'recent\\' in cmd:\\n                    command_contexts.append(\"memory system testing\")\\n                elif \\'python\\' in cmd and \\'prsist\\' in cmd:\\n                    command_contexts.append(\"memory CLI validation\")\\n                elif \\'npm\\' in cmd or \\'npx\\' in cmd:\\n                    command_contexts.append(\"package management\")\\n            \\n            if command_contexts:\\n                description_parts.append(\\', \\'.join(dict.fromkeys(command_contexts)))  # Remove duplicates\\n        \\n        # File reading context (only if no modifications)\\n        if files_read and not files_modified and not description_parts:\\n            unique_read = list(dict.fromkeys(files_read))\\n            if len(unique_read) == 1:\\n                description_parts.append(f\"Analyzed {unique_read[0]}\")\\n            elif len(unique_read) <= 3:\\n                description_parts.append(f\"Reviewed {\\', \\'.join(unique_read)}\")\\n            else:\\n                description_parts.append(f\"Explored {len(unique_read)} files\")\\n        \\n        # Combine description parts\\n        if description_parts:\\n            main_description = description_parts[0]\\n            \\n            # Add file context if not already included\\n            if files_modified and \\'Modified\\' not in main_description and \\'Enhanced\\' not in main_description:\\n                if len(files_modified) == 1:\\n                    main_description += f\" - modified {files_modified[0]}\"\\n                elif len(files_modified) <= 3:\\n                    main_description += f\" - modified {len(files_modified)} files\"\\n            \\n            return main_description\\n        \\n        return None\\n    except Exception as e:\\n        print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug\\n        return None\\n\\ndef health_check():\\n    \"\"\"System health check\"\"\"\\n    print(\"[HEALTH] Health Check...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        if validation[\"valid\"]:\\n            print(\"[PASS] System healthy\")\\n        else:\\n            print(\"[WARN] System issues found:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Health check error: {e}\")\\n        return False\\n\\ndef feature_log():\\n    \"\"\"Interactive feature logging\"\"\"\\n    print(\"[FEATURE] Feature Logging...\")\\n    try:\\n        feature_name = input(\"Feature name: \").strip()\\n        if not feature_name:\\n            print(\"[ERROR] Feature name required\")\\n            return False\\n            \\n        description = input(\"Description (optional): \").strip()\\n        \\n        import subprocess\\n        cmd = [sys.executable, \"hooks/FeatureComplete.py\", feature_name]\\n        if description:\\n            cmd.append(description)\\n            \\n        result = subprocess.run(cmd, capture_output=True, text=True, cwd=Path(__file__).parent)\\n        \\n        if result.returncode == 0:\\n            print(f\"[PASS] Feature \\'{feature_name}\\' logged successfully\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Feature logging failed: {result.stderr}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Feature logging cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Feature logging error: {e}\")\\n        return False\\n\\ndef memory_stats():\\n    \"\"\"Show memory system statistics\"\"\"\\n    print(\"[STATS] Memory Stats...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        stats = mm.get_memory_stats()\\n        \\n        print(f\"  Total Sessions: {stats.get(\\'total_sessions\\', 0)}\")\\n        print(f\"  Database Size: {stats.get(\\'database_size_mb\\', 0)} MB\")\\n        print(f\"  Active Session: {stats.get(\\'active_session\\', \\'None\\')}\")\\n        print(f\"  Project Root: {stats.get(\\'project_root\\', \\'Unknown\\')}\")\\n        return True\\n    except Exception as e:\\n        print(f\"[ERROR] Memory stats error: {e}\")\\n        return False\\n\\ndef validate_system():\\n    \"\"\"Validate system integrity\"\"\"\\n    print(\"[VALIDATE] System Validation...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        validation = mm.validate_system()\\n        \\n        print(f\"  System Valid: {validation[\\'valid\\']}\")\\n        if not validation[\"valid\"]:\\n            print(\"  Issues:\")\\n            for issue in validation.get(\"issues\", []):\\n                print(f\"    - {issue}\")\\n        return validation[\"valid\"]\\n    except Exception as e:\\n        print(f\"[ERROR] Validation error: {e}\")\\n        return False\\n\\ndef project_memory():\\n    \"\"\"Add to project memory\"\"\"\\n    print(\"[PROJECT] Project Memory...\")\\n    try:\\n        content = input(\"Enter information to add to project memory: \").strip()\\n        if not content:\\n            print(\"[ERROR] Content required\")\\n            return False\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_project_memory(content)\\n        \\n        if success:\\n            print(f\"[PASS] Project memory updated\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to update project memory\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Project memory update cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Project memory error: {e}\")\\n        return False\\n\\ndef add_decision():\\n    \"\"\"Add a decision record\"\"\"\\n    print(\"[DECISION] Add Decision...\")\\n    try:\\n        title = input(\"Decision title: \").strip()\\n        if not title:\\n            print(\"[ERROR] Decision title required\")\\n            return False\\n            \\n        description = input(\"Description: \").strip()\\n        if not description:\\n            print(\"[ERROR] Description required\")\\n            return False\\n            \\n        category = input(\"Category (architecture/technical/process/design): \").strip()\\n        if not category:\\n            category = \"general\"\\n            \\n        impact = input(\"Impact (low/medium/high/critical): \").strip()\\n        if not impact:\\n            impact = \"medium\"\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        success = mm.add_decision(title, description, category, impact)\\n        \\n        if success:\\n            print(f\"[PASS] Decision \\'{title}\\' recorded\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to record decision\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Decision recording cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Decision recording error: {e}\")\\n        return False\\n\\ndef end_session():\\n    \"\"\"End current session\"\"\"\\n    print(\"[END] Ending Session...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.end_session(archive=True)\\n        \\n        if result:\\n            print(\"[PASS] Session ended and archived\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to end\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] End session error: {e}\")\\n        return False\\n\\ndef new_session():\\n    \"\"\"Start new session\"\"\"\\n    print(\"[NEW] Starting New Session...\")\\n    try:\\n        context = input(\"Session context (optional): \").strip()\\n        \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        \\n        session_data = {}\\n        if context:\\n            session_data[\"context\"] = context\\n            \\n        result = mm.start_session(session_data)\\n        \\n        if result.get(\"memory_system_active\"):\\n            session_id = result.get(\"session_id\", \"unknown\")\\n            print(f\"[PASS] New session started: {session_id[:8]}...\")\\n            return True\\n        else:\\n            print(f\"[FAIL] Failed to start session: {result.get(\\'error\\', \\'Unknown error\\')}\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Session start cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] New session error: {e}\")\\n        return False\\n\\ndef create_checkpoint():\\n    \"\"\"Create a checkpoint\"\"\"\\n    print(\"[CHECKPOINT] Creating Checkpoint...\")\\n    try:\\n        name = input(\"Checkpoint name (optional): \").strip()\\n        if not name:\\n            name = None\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.create_checkpoint(name)\\n        \\n        if result:\\n            print(f\"[PASS] Checkpoint created: {name or \\'auto\\'}\")\\n            return True\\n        else:\\n            print(\"[FAIL] Failed to create checkpoint\")\\n            return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Checkpoint creation cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Checkpoint error: {e}\")\\n        return False\\n\\ndef export_session():\\n    \"\"\"Export current session data\"\"\"\\n    print(\"[EXPORT] Exporting Session Data...\")\\n    try:\\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        data = mm.export_session_data(format=\"json\")\\n        \\n        if data:\\n            filename = f\"session_export_{mm.get_session_info().get(\\'session_id\\', \\'unknown\\')[:8]}.json\"\\n            with open(filename, \\'w\\') as f:\\n                f.write(data)\\n            print(f\"[PASS] Session exported to {filename}\")\\n            return True\\n        else:\\n            print(\"[WARN] No active session to export\")\\n            return True\\n    except Exception as e:\\n        print(f\"[ERROR] Export error: {e}\")\\n        return False\\n\\ndef cleanup_data():\\n    \"\"\"Clean up old data\"\"\"\\n    print(\"[CLEANUP] Cleaning Up Old Data...\")\\n    try:\\n        days = input(\"Retention days (default 30): \").strip()\\n        if not days:\\n            days = 30\\n        else:\\n            days = int(days)\\n            \\n        from memory_manager import MemoryManager\\n        mm = MemoryManager()\\n        result = mm.cleanup_old_data(retention_days=days)\\n        \\n        print(f\"[PASS] Cleanup completed: {result}\")\\n        return True\\n    except ValueError:\\n        print(\"[ERROR] Invalid number of days\")\\n        return False\\n    except KeyboardInterrupt:\\n        print(\"\\\\n[CANCEL] Cleanup cancelled\")\\n        return False\\n    except Exception as e:\\n        print(f\"[ERROR] Cleanup error: {e}\")\\n        return False\\n\\ndef list_commands():\\n    \"\"\"List all available commands\"\"\"\\n    print(\"[HELP] Prsist Memory System Commands:\")\\n    print(\"\\\\n  Core Operations:\")\\n    print(\"  -t  Test system\")\\n    print(\"  -s  Status/session info\")\\n    print(\"  -c  Context (what Claude sees)\")\\n    print(\"  -r  Recent sessions\")\\n    print(\"  -h  Health check\")\\n    print(\"  -m  Memory stats\")\\n    print(\"  -v  Validate system\")\\n    print(\"\\\\n  Session Management:\")\\n    print(\"  -n  New session (start)\")\\n    print(\"  -e  End session\")\\n    print(\"  -k  Checkpoint (create)\")\\n    print(\"  -x  Export session data\")\\n    print(\"\\\\n  Data Management:\")\\n    print(\"  -f  Feature log (interactive)\")\\n    print(\"  -p  Project memory (add)\")\\n    print(\"  -d  Decisions (add decision)\")\\n    print(\"  -z  Cleanup old data\")\\n    print(\"\\\\n  Shortcuts:\")\\n    print(\"  -a  All core checks (equivalent to -tschrmv)\")\\n    print(\"  -l  List commands (this help)\")\\n    print(\"\\\\nExamples:\")\\n    print(\"  prsist -t      (test system)\")\\n    print(\"  prsist -hm     (health + memory stats)\")\\n    print(\"  prsist -tsc    (test + status + context)\")\\n    print(\"  prsist -a      (run all core checks)\")\\n    print(\"  prsist -nf     (new session + feature log)\")\\n    return True\\n\\n# Command mapping\\nCOMMAND_MAP = {\\n    \\'t\\': test_system,\\n    \\'s\\': session_status,\\n    \\'c\\': show_context,\\n    \\'r\\': recent_sessions,\\n    \\'h\\': health_check,\\n    \\'f\\': feature_log,\\n    \\'m\\': memory_stats,\\n    \\'v\\': validate_system,\\n    \\'p\\': project_memory,\\n    \\'d\\': add_decision,\\n    \\'e\\': end_session,\\n    \\'n\\': new_session,\\n    \\'k\\': create_checkpoint,\\n    \\'x\\': export_session,\\n    \\'z\\': cleanup_data,\\n    \\'l\\': list_commands\\n}\\n\\ndef main():\\n    # Custom argument parser that handles combined flags like -tsc\\n    if len(sys.argv) < 2:\\n        print(\"Prsist Memory System CLI\")\\n        print(\"Usage: prsist [options]\")\\n        print(\"Example: prsist -t       (test)\")\\n        print(\"Example: prsist -tsc     (test + status + context)\")\\n        print(\"Example: prsist -a       (all checks)\")\\n        print(\"Use \\'prsist -l\\' to list all commands\")\\n        return\\n\\n    # Parse arguments manually to handle combined flags\\n    args = sys.argv[1]\\n    if args.startswith(\\'-\\'):\\n        commands = args[1:]  # Remove the dash\\n    else:\\n        commands = args\\n\\n    # Handle special \\'all\\' command\\n    if \\'a\\' in commands:\\n        commands = commands.replace(\\'a\\', \\'tschrmv\\')\\n\\n    # Remove duplicates while preserving order\\n    seen = set()\\n    unique_commands = []\\n    for cmd in commands:\\n        if cmd not in seen:\\n            seen.add(cmd)\\n            unique_commands.append(cmd)\\n    \\n    commands = \\'\\'.join(unique_commands)\\n    \\n    success_count = 0\\n    total_count = 0\\n    \\n    print(f\"[RUN] Prsist Memory: Running {len(commands)} command(s)\")\\n    print(\"-\" * 50)\\n    \\n    for i, cmd in enumerate(commands):\\n        if cmd in COMMAND_MAP:\\n            if i > 0:\\n                print()  # Space between commands\\n            success = COMMAND_MAP[cmd]()\\n            total_count += 1\\n            if success:\\n                success_count += 1\\n        else:\\n            print(f\"[ERROR] Unknown command: -{cmd}\")\\n            total_count += 1\\n    \\n    print(\"-\" * 50)\\n    print(f\"[DONE] {success_count}/{total_count} commands completed successfully\")\\n\\nif __name__ == \"__main__\":\\n    main()', 'structuredPatch': [{'oldStart': 339, 'oldLines': 7, 'newStart': 339, 'newLines': 7, 'lines': ['         ', '         return None', '     except Exception as e:', '-        print(f\"[DEBUG] Contextual extraction error: {e}\")  # Temporary debug', '+        logging.debug(f\"Failed to extract contextual description: {e}\")', '         return None', ' ', ' def health_check():']}], 'userModified': False, 'replaceAll': False}",
        "execution_time_ms": 0,
        "success": true
      }
    ],
    "file_interactions": [
      {
        "file_path": ".prsist/activity_analyzer.py",
        "action_type": "edit",
        "timestamp": "2025-08-24T18:55:26.644871",
        "content_hash": "953b5ecb70a806d3563b3accce14cb5531601dd8598d91a3644701ef6021fa05",
        "line_changes": null
      },
      {
        "file_path": ".prsist/activity_analyzer.py",
        "action_type": "edit",
        "timestamp": "2025-08-24T18:56:02.765127",
        "content_hash": "e8833e7500c17b74ad413bbfc0ca397956de5f635cce3203a542b573f33c5a40",
        "line_changes": null
      },
      {
        "file_path": ".prsist/activity_analyzer.py",
        "action_type": "edit",
        "timestamp": "2025-08-24T18:56:02.828354",
        "content_hash": "e8833e7500c17b74ad413bbfc0ca397956de5f635cce3203a542b573f33c5a40",
        "line_changes": null
      },
      {
        "file_path": ".prsist/bin/prsist.py",
        "action_type": "edit",
        "timestamp": "2025-08-24T18:59:38.179120",
        "content_hash": "79ea6a3129a20c23055ceb54f1e489c4fb15f6f2c26564d74052b0995f8d63cc",
        "line_changes": null
      },
      {
        "file_path": ".prsist/bin/prsist.py",
        "action_type": "edit",
        "timestamp": "2025-08-24T18:59:38.520830",
        "content_hash": "79ea6a3129a20c23055ceb54f1e489c4fb15f6f2c26564d74052b0995f8d63cc",
        "line_changes": null
      },
      {
        "file_path": ".prsist/bin/prsist.py",
        "action_type": "edit",
        "timestamp": "2025-08-24T19:00:13.634610",
        "content_hash": "ff43d8946bc56e174be34f73bd7f034b0c558b6ad4be900a8caf8eb6f412c60d",
        "line_changes": null
      },
      {
        "file_path": ".prsist/bin/prsist.py",
        "action_type": "edit",
        "timestamp": "2025-08-24T19:00:13.704599",
        "content_hash": "ff43d8946bc56e174be34f73bd7f034b0c558b6ad4be900a8caf8eb6f412c60d",
        "line_changes": null
      },
      {
        "file_path": ".prsist/bin/prsist.py",
        "action_type": "edit",
        "timestamp": "2025-08-24T19:00:23.606901",
        "content_hash": "788ffc3b9d2534f424e5a59897b1e4d022a950c525ef275342ebefd0edf71577",
        "line_changes": null
      },
      {
        "file_path": ".prsist/bin/prsist.py",
        "action_type": "edit",
        "timestamp": "2025-08-24T19:00:23.969969",
        "content_hash": "788ffc3b9d2534f424e5a59897b1e4d022a950c525ef275342ebefd0edf71577",
        "line_changes": null
      },
      {
        "file_path": ".prsist/bin/prsist.py",
        "action_type": "edit",
        "timestamp": "2025-08-24T19:00:52.775688",
        "content_hash": "7da5dca4fc018224e203d9aa929c7fe2b2d730d174a46ec31966338cc001e3a5",
        "line_changes": null
      },
      {
        "file_path": ".prsist/bin/prsist.py",
        "action_type": "edit",
        "timestamp": "2025-08-24T19:00:52.834677",
        "content_hash": "7da5dca4fc018224e203d9aa929c7fe2b2d730d174a46ec31966338cc001e3a5",
        "line_changes": null
      },
      {
        "file_path": ".prsist/bin/prsist.py",
        "action_type": "edit",
        "timestamp": "2025-08-24T19:01:18.274873",
        "content_hash": "a03f147094917c8e7c92cafe5a510290417a62389f53fdc2acf8174a8871f765",
        "line_changes": null
      },
      {
        "file_path": ".prsist/bin/prsist.py",
        "action_type": "edit",
        "timestamp": "2025-08-24T19:01:37.224279",
        "content_hash": "2b73e6991f1f96a8a75e8e9c8a4c6c2cb421fa4a766a00054bb677a2a365eaad",
        "line_changes": null
      },
      {
        "file_path": ".prsist/bin/prsist.py",
        "action_type": "edit",
        "timestamp": "2025-08-24T19:01:37.795879",
        "content_hash": "2b73e6991f1f96a8a75e8e9c8a4c6c2cb421fa4a766a00054bb677a2a365eaad",
        "line_changes": null
      }
    ],
    "checkpoints": [
      {
        "name": "auto_checkpoint_edit",
        "timestamp": "2025-08-24T18:55:26.649889",
        "file": "D:\\Projects\\Dev\\Memory\\.prsist\\sessions\\checkpoints\\15859307-2121-4af6-a427-efe14d49355a_auto_checkpoint_edit.json"
      },
      {
        "name": "auto_checkpoint_edit",
        "timestamp": "2025-08-24T18:56:02.835355",
        "file": "D:\\Projects\\Dev\\Memory\\.prsist\\sessions\\checkpoints\\15859307-2121-4af6-a427-efe14d49355a_auto_checkpoint_edit.json"
      },
      {
        "name": "auto_checkpoint_edit",
        "timestamp": "2025-08-24T18:59:38.533782",
        "file": "D:\\Projects\\Dev\\Memory\\.prsist\\sessions\\checkpoints\\15859307-2121-4af6-a427-efe14d49355a_auto_checkpoint_edit.json"
      },
      {
        "name": "auto_checkpoint_edit",
        "timestamp": "2025-08-24T19:00:13.716584",
        "file": "D:\\Projects\\Dev\\Memory\\.prsist\\sessions\\checkpoints\\15859307-2121-4af6-a427-efe14d49355a_auto_checkpoint_edit.json"
      },
      {
        "name": "auto_checkpoint_edit",
        "timestamp": "2025-08-24T19:00:23.983966",
        "file": "D:\\Projects\\Dev\\Memory\\.prsist\\sessions\\checkpoints\\15859307-2121-4af6-a427-efe14d49355a_auto_checkpoint_edit.json"
      },
      {
        "name": "auto_checkpoint_edit",
        "timestamp": "2025-08-24T19:00:52.848675",
        "file": "D:\\Projects\\Dev\\Memory\\.prsist\\sessions\\checkpoints\\15859307-2121-4af6-a427-efe14d49355a_auto_checkpoint_edit.json"
      },
      {
        "name": "auto_checkpoint_edit",
        "timestamp": "2025-08-24T19:01:18.291077",
        "file": "D:\\Projects\\Dev\\Memory\\.prsist\\sessions\\checkpoints\\15859307-2121-4af6-a427-efe14d49355a_auto_checkpoint_edit.json"
      },
      {
        "name": "auto_checkpoint_edit",
        "timestamp": "2025-08-24T19:01:37.254808",
        "file": "D:\\Projects\\Dev\\Memory\\.prsist\\sessions\\checkpoints\\15859307-2121-4af6-a427-efe14d49355a_auto_checkpoint_edit.json"
      }
    ]
  }
}